<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试汇总, Lion Heart">
    <meta name="description" content="面试">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>面试汇总 | Lion Heart</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lion Heart" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Lion Heart</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Lion Heart</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/orgjinhc" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/orgjinhc" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试汇总</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                <span class="chip bg-color">面试</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/" class="post-category">
                                面试题精选
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-01-19
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    26.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    96 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><p>Java 语言层面：Object object = new Object()</p>
<p>Java 字节码层面：</p>
<ol>
<li>new指令</li>
<li>dup指令</li>
<li>invoke指令</li>
<li>返回引用</li>
</ol>
<p>JVM 实现：运行时数据区</p>
<ol>
<li>堆内开辟空间</li>
<li>对象field赋初始值</li>
<li>执行构造方法</li>
<li>返回地址给引用</li>
</ol>
<h5 id="标准答案-1～3-类加载流程，4～6-内存分配、初始化流程"><a href="#标准答案-1～3-类加载流程，4～6-内存分配、初始化流程" class="headerlink" title="标准答案 1～3:类加载流程，4～6:内存分配、初始化流程"></a>标准答案 1～3:类加载流程，4～6:内存分配、初始化流程</h5><ol>
<li><p>class loading</p>
</li>
<li><p>class linking</p>
<p>2.1 verification：验证文件是否符合JVM规范<br>2.2 preparation：半初始化，静态变量赋默认值<br>2.3 resolution：将类/方法/属性的符号引用解析为直接饮用</p>
</li>
<li><p>initializing：静态变量赋初始值</p>
<p>前三步：method area内生成类对象</p>
</li>
<li><p>申请对象内存</p>
</li>
<li><p>成员变量赋默认值</p>
</li>
<li><p>调用对象构造方法init</p>
<p>6.1成员变量顺序赋初始值<br>​6.2执行构造方法语句，先super()</p>
</li>
</ol>
<h4 id="Object-类中的方法"><a href="#Object-类中的方法" class="headerlink" title="Object 类中的方法"></a>Object 类中的方法</h4><p>​    hashCode<br>​    equals<br>​    toString<br>​    wait<br>​    notify<br>​    clone<br>​    finalize</p>
<p>Object的hashcode方法重写了，equals方法要不要重写？<br>    看场景,官方的建议是要重写这俩方法一起重写</p>
<p>hashcode 和 equals 方法常用地方？<br>    对象比较是否相同</p>
<h5 id="Object-toString-方法常用的地方，为什么要重写该方法"><a href="#Object-toString-方法常用的地方，为什么要重写该方法" class="headerlink" title="Object toString 方法常用的地方，为什么要重写该方法"></a>Object toString 方法常用的地方，为什么要重写该方法</h5><p>​    默认实现打印对象堆地址信息</p>
<h5 id="finally块一定会执行吗"><a href="#finally块一定会执行吗" class="headerlink" title="finally块一定会执行吗"></a>finally块一定会执行吗</h5><p>​    不一定，只有 try finally 正常执行完毕的情况下，才会执行</p>
<h5 id="正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行"><a href="#正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行" class="headerlink" title="正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行"></a>正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行</h5><p>​    返回之前</p>
<h5 id="try、catch、finally语句块的执行顺序"><a href="#try、catch、finally语句块的执行顺序" class="headerlink" title="try、catch、finally语句块的执行顺序"></a>try、catch、finally语句块的执行顺序</h5><p>​    try - catch - finally</p>
<h5 id="一个空Object对象的占多大空间"><a href="#一个空Object对象的占多大空间" class="headerlink" title="一个空Object对象的占多大空间"></a>一个空Object对象的占多大空间</h5><p>​    对象头(markword + 类型指针)<br>​    实例变量    看情况</p>
<h5 id="对象引用类型分为哪几类"><a href="#对象引用类型分为哪几类" class="headerlink" title="对象引用类型分为哪几类"></a>对象引用类型分为哪几类</h5><ol>
<li>强：普通的对象。只有发生GC 空间和地址才会被回收。</li>
<li>软：主动声明对象类型为SoftReference的对象为软引用对象。内存不够才回收<ul>
<li>适用场景：缓存</li>
</ul>
</li>
<li>弱：主动声明对象类型为WeakReference的对象为弱饮用对象。只要发生GC 就会回收。</li>
<li>虚：主动声明对象类型为PhantomReference的对象为虚引用对象，必须结合ReferenceQueue使用，要回收的对象会被加入队列，由GC线程检查队列内应用对象。<ul>
<li>使用场景：堆外内存 堆内应用指向堆外地址 nio - zero copy </li>
</ul>
</li>
</ol>
<h5 id="Java中的参数传递时传值呢？还是传引用"><a href="#Java中的参数传递时传值呢？还是传引用" class="headerlink" title="Java中的参数传递时传值呢？还是传引用"></a>Java中的参数传递时传值呢？还是传引用</h5><p>​    值传递</p>
<h5 id="动态代理的几种实现方式及优缺点"><a href="#动态代理的几种实现方式及优缺点" class="headerlink" title="动态代理的几种实现方式及优缺点"></a>动态代理的几种实现方式及优缺点</h5><p>​    静态<br>​        实现简单，由程序员实现，可读性好，变更灵活，需要源文件<br>​        类爆炸，不易维护，被代理类新增方法，代理类需要跟着变更<br>​    动态<br>​        jdk动态：java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。反射机制生成代理类的对象<br>​            针对接口进行增强<br>​        cglib动态 - 基于asm实现，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。典型实现就是Spring AOP<br>​            针对类进行增强<br>​        运行时生成，增强逻辑集中，易于维护</p>
<h5 id="类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样"><a href="#类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样" class="headerlink" title="类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样"></a>类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样</h5><h5 id="Override和Overload的区别，分别用在什么场景"><a href="#Override和Overload的区别，分别用在什么场景" class="headerlink" title="Override和Overload的区别，分别用在什么场景"></a>Override和Overload的区别，分别用在什么场景</h5><p>​    重载：同一类<br>​    重写：父子类</p>
<h5 id="java的反射是如何实现的"><a href="#java的反射是如何实现的" class="headerlink" title="java的反射是如何实现的"></a>java的反射是如何实现的</h5><p>​    Reflection APIs 需要了解 Class 文件结构</p>
<h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h5 id="Synchronized-用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？"><a href="#Synchronized-用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？" class="headerlink" title="Synchronized 用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？"></a>Synchronized 用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？</h5><p>是什么 ：多线程并发环境下保证同步和数据安全<br>    多线程访问同步方法或代码块时，线程必须先获取对象监视器才有方法执行权。获取失败进入同步队列，线程状态变为<code>BLOCKED</code>状态。只有当持有锁的线程释放锁后，唤醒阻塞在同步队列中的线程，使其重新尝试获取监视器锁，往复此流程，如果持有锁的线程调用<code>wait()</code>方法，当前线程释放<code>monitor</code>，线程状态变成<code>WAITING</code>，进入等待队列，等待其他线程唤醒，如若唤醒则从等待队列进入到同步队列继续抢夺monitor持有权</p>
<pre><code>原理：
    Java 语言层面：使用 synchronized 关键字修饰方法或代码段
    JVM 层面实现：被 synchronized 关键字修饰的代码段，通过JVM被编译为monitorenter、monitorexit指令来获取和释放互斥锁，解释器执行monitorenter时会进入到InterpreterRuntime.cpp的InterpreterRuntime::monitorenter函数，达到线程安全的目的
    被 synchronized 关键字修饰的方法，方法的访问修饰符添加 sychronized 标识

锁升级过程：
偏向锁
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。
当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。
偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态，    偏向锁在JDK6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

轻量级锁
是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。
如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁

重量级锁
升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。    </code></pre><h5 id="Monitor是什么"><a href="#Monitor是什么" class="headerlink" title="Monitor是什么"></a>Monitor是什么</h5><p>​    Monitor是一个同步工具，也可以说是一种同步机制，具体体现在它是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用<br>​    Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p>
<h5 id="“锁”到底是什么"><a href="#“锁”到底是什么" class="headerlink" title="“锁”到底是什么"></a>“锁”到底是什么</h5><p>​    锁是对象的一种状态</p>
<h5 id="如何确定对象的锁"><a href="#如何确定对象的锁" class="headerlink" title="如何确定对象的锁"></a>如何确定对象的锁</h5><p>​    获取对象头的markword，查看锁标志位，用2位来表示不同状态</p>
<h5 id="什么是可重入性，为什么说-Synchronized-是可重入锁"><a href="#什么是可重入性，为什么说-Synchronized-是可重入锁" class="headerlink" title="什么是可重入性，为什么说 Synchronized 是可重入锁"></a>什么是可重入性，为什么说 Synchronized 是可重入锁</h5><p>线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞</p>
<pre><code>可重入原理：c++代码 - entry()方法
1.通过CAS尝试把monitor的`_owner`字段设置为当前线程
2.设置成功再判断是否是第一次进去`monitor`
    如果第一次设置_recursions = 1，_owner为当前线程
    如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁，_recursions代表当前线程获取锁次数

3.设置失败更改线程状态在监视器上阻塞
4.通过自旋执行尝试等待锁的释放
5.最后如果没有获取成功，当前线程被封装成ObjectWaiter对象node，通过CAS把node节点push到_cxq列表中，则通过park将当前线程挂起，等待被唤醒</code></pre><h5 id="Synchronized-为什么是重量级锁"><a href="#Synchronized-为什么是重量级锁" class="headerlink" title="Synchronized 为什么是重量级锁"></a>Synchronized 为什么是重量级锁</h5><p>​    根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成 </p>
<p>​    ***** 阻塞和唤醒需要OS进行状态切换，上下文切换可以认为是内核在 CPU 上对于进程（包括线程）进行以下的活动：</p>
<pre><code>      1. 挂起一个进程，将这个进程在 CPU 中的状态存储于内存中的某处
        2. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复
          3. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程</code></pre><p>​    1.6之前，通过Monitor实现，对象通过ObjectMonitor的enter()方法获取锁，通过exit()方法释放锁，这也是导致我们经常会说synchronize是重量级锁的原因，因为java的线程是映射到操作系统的原生线程，如果要wait()或notify()一个线程就需要OS帮助，需要从用户态切换到内核态，俗称上下文切换<br>​    </p>
<h5 id="JVM对Java的原生锁做了哪些优化"><a href="#JVM对Java的原生锁做了哪些优化" class="headerlink" title="JVM对Java的原生锁做了哪些优化"></a>JVM对Java的原生锁做了哪些优化</h5><p>​    JDK1.6对加锁的实现引入大量的优化来减少锁操作开销<br>​    还有我们经常说的对synchronize的升级也是1.6之后对锁的实现和类型进行了优化，目的是降低加锁、释放锁的开销，出现了偏向锁、轻量级锁<br>偏向锁：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作<br>轻量级锁：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放<br>适应性自旋：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环，即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间</p>
<h5 id="为什么说-Synchronized-是非公平锁"><a href="#为什么说-Synchronized-是非公平锁" class="headerlink" title="为什么说 Synchronized 是非公平锁"></a>为什么说 Synchronized 是非公平锁</h5><p>​    entryList内的线程并行通过 cas 尝试把 owner 字段设置为当前线程，也就是无需排队获取同步资源，直接尝试获取锁</p>
<h5 id="什么是锁消除和锁粗化"><a href="#什么是锁消除和锁粗化" class="headerlink" title="什么是锁消除和锁粗化"></a>什么是锁消除和锁粗化</h5><p>​    锁粗化：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗<br>​    锁消除：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁<br>​    </p>
<h5 id="为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）"><a href="#为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）" class="headerlink" title="为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）"></a>为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）</h5><pre class=" language-html"><code class="language-html">悲观锁:
    原理：认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改
    实现：Java中，synchronized关键字和Lock的实现类都是悲观锁

乐观锁:
    原理：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。
    实现：乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法和版本号机制</code></pre>
<pre><code>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁的情况下实现多线程之间的变量同步
java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁
主要就是Unsafe类 属性：valueOffSet、voliatile value

CAS算法涉及到三个操作数：
需要读写的内存值 V
进行比较的值 A
要写入的新值 B
当且仅当A时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止

CAS 存在的问题
1.ABA问题
    CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
    JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
2.循环时间长开销大
    CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
3.只能保证一个共享变量的原子操作
    对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
    Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</code></pre><h5 id="乐观锁一定就是好的吗"><a href="#乐观锁一定就是好的吗" class="headerlink" title="乐观锁一定就是好的吗"></a>乐观锁一定就是好的吗</h5><p>​    竞争激烈的情况，乐观锁会浪费更多的cpu资源</p>
<h5 id="Synchronized、ReentrantLock-原理区别"><a href="#Synchronized、ReentrantLock-原理区别" class="headerlink" title="Synchronized、ReentrantLock 原理区别"></a>Synchronized、ReentrantLock 原理区别</h5><p>​    原理：ReentrantLock基于AQS实现，而AQS底层使用的是改进的CLH队列，CAS+阻塞+唤醒，对于暂时获取不到资源以及尚未被父节点唤醒的线程在队列中阻塞休眠，被唤醒后CAS获取资源。并不是单纯的阻塞或者CAS，兼顾了性能和效率<br>​    ReentrantLock里面有一个内部类Sync，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。<br>​    公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。<br>​    hasQueuedPredecessors()方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是就去尝试加锁并返回<br>​    综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h5 id="AQS-流程分析"><a href="#AQS-流程分析" class="headerlink" title="AQS 流程分析"></a>AQS 流程分析</h5><p>​    <a href="https://processon.com/diagraming/5f53739963768959e2d612c4" target="_blank" rel="noopener">https://processon.com/diagraming/5f53739963768959e2d612c4</a></p>
<h5 id="公平和非公平"><a href="#公平和非公平" class="headerlink" title="公平和非公平"></a>公平和非公平</h5><p>​    公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<pre><code>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</code></pre><h5 id="请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h5><p>​    相同点：<br>​    都是用来协调多线程对共享对象、变量的访问都是可重入锁，同一线程可以多次获得同一个锁都保证了可见性和互斥性<br>​    不同点：<br>​        1、底层实现不一样，synchronized它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。也就是说synchronized隐式获得释放锁，ReentrantLock 显示的获得、释放锁。<br>​        2、synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock 时需要在 finally块中释放锁<br>​        3、synchronized是同步阻塞，使用的是悲观策略，lock是同步非阻塞，采用的是乐观并发策略。<br>​        4、ReentrantLock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。通过ReentrantLock可以知道有没有成功获取锁，而synchronized却无法办到。最重要的是ReentrantLock可以提供公平锁，而synchronized只能是非公平锁</p>
<p>ReentrantLock 是如何实现可重入性的？分析可重入锁的实现（涉及AQS中同步状态如何控制）<br>    ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0<br>    当前线程获取锁成功，status = 1，当前线程再次获取锁时，判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p>
<p>除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？<br>如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。</p>
<p>CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？<br>分析Java CountDownLatch类的实现？<br>分析Java Condition类实现（同步队列和等待队列）<br>分析Java Samphore类实现（AQS）<br>分析Java 阻塞队列实现<br>读写锁设计主要解决什么问题？</p>
<p>java有哪些锁？<br>乐观锁 悲观锁 </p>
<h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><h5 id="为什么object的wait和notify还有condition-await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象"><a href="#为什么object的wait和notify还有condition-await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象" class="headerlink" title="为什么object的wait和notify还有condition.await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象"></a>为什么object的wait和notify还有condition.await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象</h5><p>​    是因为设计者防止出现lost wake up的问题出现的，就是假设一个生产者和消费者，生产消息+1，消费消息-1，那么如果刚开始count=0，消费者进来发现count=0，就准备阻塞，但是这时候生产者生产了一条消息，并且执行了notify消息，但是没有线程需要你notify，然后消费者执行下一步wait方法等待，所以这条消息就丢失了 </p>
<h5 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h5><p>​    sleep不释放锁，wait释放锁<br>​    sleep是Thread方法，wait是Object的方法<br>​    sleep必须设置时间，wait不用必须<br>​    sleep不需要被唤醒，wait需要调用唤醒</p>
<h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><p>​    start，runnable，blocked，waiting，timedwaited，terminate</p>
<h5 id="线程的阻塞的方式"><a href="#线程的阻塞的方式" class="headerlink" title="线程的阻塞的方式"></a>线程的阻塞的方式</h5><p>Blocked状态<br>    线程在等待同步锁，也就是synchronized，<br>waiting状态<br>    调用Object对象的wait方法，但没有指定超时值。<br>    调用Thread对象的join方法，但没有指定超时值。<br>    调用LockSupport对象的park方法。<br>TIMED_WAITING状态<br>    调用Thread.sleep方法。<br>    调用Object对象的wait方法，指定超时值。<br>    调用Thread对象的join方法，指定超时值。<br>    调用LockSupport对象的parkNanos方法。<br>    调用LockSupport对象的parkUntil方法。</p>
<h3 id="Java-线程池相关问题"><a href="#Java-线程池相关问题" class="headerlink" title="Java 线程池相关问题"></a>Java 线程池相关问题</h3><p>Java 中的线程池是如何实现的？<br>创建线程池的几个核心构造参数？<br>线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？<br>线程池有哪几种？有哪几种拒绝策略？如何自定义拒绝策略？<br>项目中你怎么使用线程池，为什么要使用线程池？<br>按线程池内部机制，当提交新任务时，有哪些异常要考虑？<br>java线程池中基于缓存和基于定长的两种线程池，当请求太多时分别是如何处理的？定长的事用的队列，如果队列也满了呢？交换进磁盘？基于缓存的线程池解决方法呢？</p>
<h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>如何实现普通IO和NIO一样的效果？<br>nio的底层实现？<br>虚拟机，IO相关知识点？<br>NIO是什么？适用于何种场景？<br>怎么理解零拷贝，直接ip和mmap都避免了用户态到内核态的切换，<br>（1）零拷贝：在内核态将数据直接从pagecache拷贝到socketbuffer<br>（2）直接io：通过dma直接写数据到磁盘<br>（3）mmap将物理地址和虚拟地址对应，直接写数据到pagecache<br>IO会阻塞吗？<br>readLine是不是阻塞的<br>readLine()是一个阻塞函数，当没有数据读取时，就一直会阻塞在那，而不是返回null<br>readLine()只有在数据流发生异常或者另一端被close()掉时，才会返回null值。</p>
<h3 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h3><p>谈一下设计模式有几种？<br>Spring使用了什么设计模式？<br>适配器和代理模式的区别<br>门面模式，类图(外观模式)<br>mybatis如何映射表结构<br>请列举出在 JDK 中几个常用的设计模式？<br>什么是设计模式？你是否在你的代码里面使用过任何设计模式？<br>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式<br>在 Java 中，什么叫观察者设计模式（observer design pattern）？<br>使用工厂模式最主要的好处是什么？在哪里使用？<br>举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</p>
<h3 id="Spring相关"><a href="#Spring相关" class="headerlink" title="Spring相关"></a>Spring相关</h3><p>Spring AOP的实现原理和场景<br>Spring bean的作用域和生命周期<br>Spring 5比Spring4做了哪些改进<br>Spring IOC是什么？优点是什么？<br>讲一讲FactroyBean?<br>aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理<br>通过动态代理进行对目标方法的横切，每次运行时会生成一个proxy对象，拥有目标类的所有方法，并且在在特定的切点进行增强处理，然后回调原对象的方法<br>我会疯转成工厂类<br>spring的bean配置的几种方式<br>基于XML的配置、基于注解的配置和基于Java类的配置<br>web.xml的配置<br>最终加载顺序：ServletContext -&gt; listener -&gt; filter -&gt; servlet<br>spring的监听器。<br>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息<br>spring Aop的实现原理，具体说说<br>何时会内存泄漏，内存泄漏会抛哪些异常<br>是否用过Autowire注解<br>spring的注入bean的方式<br>Spring Bean 的生命周期<br>说说Spring的IOC容器初始化流程？<br>@Transaction注解一般写在什么位置?如何控制其回滚?<br>如Spring中如何对同名Bean加载时的处理<br>答：spring会在DefaultListableBeanFactory这个类中会根据扫描到的bean进行加载到ioc容器中时，遇到重名的会进行覆盖，如果不想覆盖可以在web.xml中设置allowBeanDefinitionOverriding 为false即可<br>什么是 Spring 框架？Spring 框架有哪些主要模块？<br>使用 Spring 框架能带来哪些好处？<br>什么是控制反转(IOC)？什么是依赖注入？<br>请解释下 Spring 框架中的 IoC？<br>BeanFactory 和 ApplicationContext 有什么区别？<br>Spring 有几种配置方式？<br>如何用基于 XML 配置的方式配置 Spring？<br>如何用基于 Java 配置的方式配置 Spring？<br>怎样用注解的方式配置 Spring？<br>请解释 Spring Bean 的生命周期？<br>Spring Bean 的作用域之间有什么区别？<br>什么是 Spring inner beans？<br>Spring 框架中的单例 Beans 是线程安全的么？<br>请举例说明如何在 Spring 中注入一个 Java Collection？<br>如何向 Spring Bean 中注入一个 Java.util.Properties？<br>请解释 Spring Bean 的自动装配？<br>请解释自动装配模式的区别？<br>如何开启基于注解的自动装配？<br>请举例解释@Required 注解？<br>请举例解释@Autowired 注解？<br>请举例说明@Qualifier 注解？<br>构造方法注入和设值注入有什么区别？<br>Spring 框架中有哪些不同类型的事件？<br>FileSystemResource 和 ClassPathResource 有何区别？<br>Spring 框架中都用到了哪些设计模式？</p>
<h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><p>ConcurrentHashmap的锁是如何加的？是不是分段越多越好分段加锁<br>    并不是，参考锁粗化的优化</p>
<p>concurrenhashmap求size是如何加锁的，如果刚求完一段后这段发生了变化该如何处理<br>hashmap如果只有一个写其他全读会出什么问题<br>java有哪些容器<br>HashMap 和 hashTable 区别？</p>
<p>hashtable和ConcurrentHashMap如何实现线程安全？<br>LinkedHashmap的底层实现<br>ArrayList的原理讲一讲，扩容等<br>hashmap的底层实现<br>1.7是数组+链表  1.8是数组 + 链表 链表长度超过8并且数组元素大于64会转成红黑树，不然只是会扩容<br>Hashmap 线程不安全的出现场景</p>
<p>hashmap put 方法存放的时候怎么判断是否是重复的<br>Set 和 List 区别？<br>ArrayList 和 LinkedList 区别<br>如果存取相同的数据，ArrayList 和 LinkedList 谁占用空间更大？<br>Set 存的顺序是有序的吗？<br>常见 Set 的实现有哪些？<br>HashSet 的底层实现呢<br>TreeSet 底层源码有看过吗？<br>红黑树的实现原理和应用场景；</p>
<p>HashMap内部的数据结构是什么？底层是怎么实现的？</p>
<h1 id="熟悉Spring、SpringMVC、MyBatis"><a href="#熟悉Spring、SpringMVC、MyBatis" class="headerlink" title="熟悉Spring、SpringMVC、MyBatis"></a>熟悉Spring、SpringMVC、MyBatis</h1><h1 id="熟悉-MQ-、Redis-等常用中间件的原理与使用"><a href="#熟悉-MQ-、Redis-等常用中间件的原理与使用" class="headerlink" title="熟悉 MQ 、Redis 等常用中间件的原理与使用"></a>熟悉 MQ 、Redis 等常用中间件的原理与使用</h1><h2 id="说说你们公司线上生产环境用的是什么消息中间件"><a href="#说说你们公司线上生产环境用的是什么消息中间件" class="headerlink" title="说说你们公司线上生产环境用的是什么消息中间件?"></a>说说你们公司线上生产环境用的是什么消息中间件?</h2><h2 id="为什么要使用MQ？"><a href="#为什么要使用MQ？" class="headerlink" title="为什么要使用MQ？"></a>为什么要使用MQ？</h2><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是<strong>同步执行</strong>经常出问题，所以引入了mq</p>
<p><strong>解耦</strong></p>
<p>系统耦合度降低，没有强依赖关系</p>
<p><strong>异步</strong></p>
<p>不需要同步执行的远程调用可以有效提高响应时间</p>
<p><strong>削峰</strong></p>
<p>请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮</p>
<h3 id="多个mq如何选型？"><a href="#多个mq如何选型？" class="headerlink" title="多个mq如何选型？"></a>多个mq如何选型？</h3><p><strong>RabbitMQ</strong></p>
<p>erlang开发，延迟比较低</p>
<p><strong>RocketMQ</strong></p>
<p>java开发，面向互联网集群化功能丰富</p>
<p><strong>kafka</strong></p>
<p>Scala开发，面向日志功能丰富</p>
<p><strong>ActiveMQ</strong></p>
<p>java开发，简单，稳定</p>
<p>小项目：ActiveMQ</p>
<p>大项目：RocketMQ或kafka、RabbitMq</p>
<h2 id="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h2><p>nameserver 无状态 动态列表</p>
<p>producer</p>
<p>broker</p>
<p>consumer</p>
<h2 id="RocketMQ中的Topic和ActiveMQ有什么区别？"><a href="#RocketMQ中的Topic和ActiveMQ有什么区别？" class="headerlink" title="RocketMQ中的Topic和ActiveMQ有什么区别？"></a>RocketMQ中的Topic和ActiveMQ有什么区别？</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>有destination的概念，即消息目的地</p>
<p>destination分为两类：</p>
<ul>
<li>topic<ul>
<li>广播消息</li>
</ul>
</li>
<li>queue<ul>
<li>队列消息</li>
</ul>
</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ的Topic是一组Message Queue的集合 ConsumeQueue</p>
<p>一条消息是广播消息还是队列消息由客户端消费决定</p>
<h2 id="RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="RocketMQ Broker中的消息被消费后会立即删除吗？"></a>RocketMQ Broker中的消息被消费后会立即删除吗？</h2><p>不会，每条消息都会持久化到CommitLog中，每个consumer连接到broker后会维持消费进度信息，当有消息消费后只是当前consumer的消费进度（CommitLog的offset）更新了。</p>
<h3 id="那么消息会堆积吗？什么时候清理过期消息？"><a href="#那么消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="那么消息会堆积吗？什么时候清理过期消息？"></a>那么消息会堆积吗？什么时候清理过期消息？</h3><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p>
<ul>
<li>检查这个文件最后访问时间</li>
<li>判断是否大于过期时间</li>
<li>指定时间删除，默认凌晨4点</li>
</ul>
<h2 id="RocketMQ消费模式有几种？"><a href="#RocketMQ消费模式有几种？" class="headerlink" title="RocketMQ消费模式有几种？"></a>RocketMQ消费模式有几种？</h2><p>消费模型由consumer决定，消费维度为Topic</p>
<h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>一组consumer同时消费一个topic，可以分配消费负载均衡策略分配consumer对应消费topic下的哪些queue</p>
<p>多个group同时消费一个topic时，每个group都会消费到数据</p>
<p>一条消息只会被一个group中的consumer消费，</p>
<h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p>
<h2 id="消费消息时使用的是push还是pull？"><a href="#消费消息时使用的是push还是pull？" class="headerlink" title="消费消息时使用的是push还是pull？"></a>消费消息时使用的是push还是pull？</h2><p>在刚开始的时候就要决定使用哪种方式消费</p>
<p>两种：</p>
<p><code>DefaultLitePullConsumerImpl</code> 拉</p>
<p><code>DefaultMQPushConsumerImpl</code>推</p>
<p>两个实现 <code>DefaultLitePullConsumerImpl</code> <code>DefaultMQPushConsumerImpl</code>都实现了MQConsumerInner接口接口</p>
<p>名称上看起来是一个推，一个拉，但实际底层实现都是采用的<strong>长轮询机制</strong>，即拉取方式</p>
<p>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p>
<h3 id="为什么要主动拉取消息而不使用事件监听方式？"><a href="#为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="为什么要主动拉取消息而不使用事件监听方式？"></a>为什么要主动拉取消息而不使用事件监听方式？</h3><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p>
<h4 id="说一说几种常见的消息同步机制？"><a href="#说一说几种常见的消息同步机制？" class="headerlink" title="说一说几种常见的消息同步机制？"></a>说一说几种常见的消息同步机制？</h4><p>push：</p>
<p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p>
<p>pull：</p>
<p>轮训时间间隔，固定值的话会造成资源浪费</p>
<p>长轮询：</p>
<p>上连接 短连接（每秒） 长轮询</p>
<h3 id="broker如何处理拉取请求的？"><a href="#broker如何处理拉取请求的？" class="headerlink" title="broker如何处理拉取请求的？"></a>broker如何处理拉取请求的？</h3><p>consumer首次请求broker</p>
<ul>
<li><p>broker中是否有符合条件的消息</p>
</li>
<li><p>有 -&gt;</p>
</li>
</ul>
<ul>
<li>响应consumer</li>
<li>等待下次consumer的请求</li>
</ul>
<ul>
<li><p>没有</p>
<ul>
<li>挂起consumer的请求，即不断开连接，也不返回数据</li>
<li>挂起时间长短，写死在代码里的吗？长轮询写死，短轮询可以配</li>
<li>使用consumer的offset，<ul>
<li>DefaultMessageStore#ReputMessageService#run方法<ul>
<li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li>
<li>当有新消息的时候返回请求</li>
</ul>
</li>
<li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="RocketMQ如何做负载均衡？"><a href="#RocketMQ如何做负载均衡？" class="headerlink" title="RocketMQ如何做负载均衡？"></a>RocketMQ如何做负载均衡？</h2><p>通过Topic在多broker种分布式存储实现</p>
<h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>发送端指定Target message queue发送消息到相应的broker，来达到写入时的负载均衡</p>
<ul>
<li>提升写入吞吐量，当多个producer同时向一个broker写入数据的时候，性能会下降</li>
<li>消息分布在多broker种，为负载消费做准备</li>
</ul>
<p>每 30 秒从 nameserver获取 Topic 跟 Broker 的映射关系，近实时获取最新数据存储单元，queue落地在哪个broker中</p>
<p>在使用api中send方法的时候，可以指定Target message queue写入或者使用MessageQueueSelector</p>
<h4 id="默认策略是随机选择："><a href="#默认策略是随机选择：" class="headerlink" title="默认策略是随机选择："></a><strong>默认策略是随机选择：</strong></h4><ul>
<li>producer维护一个index</li>
<li>每次取节点会自增</li>
<li>index向所有broker个数取余</li>
<li>自带容错策略</li>
</ul>
<h4 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h4><ul>
<li>SelectMessageQueueByHash<ul>
<li>hash的是传入的args</li>
</ul>
</li>
<li>SelectMessageQueueByRandom</li>
<li>SelectMessageQueueByMachineRoom 没有实现</li>
</ul>
<p>也可以自定义实现<strong>MessageQueueSelector</strong>接口中的select方法</p>
<pre><code>MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);</code></pre><p>可以自定义规则来选择mqs</p>
<h4 id="如何知道mqs的，mqs的数据从哪儿来？"><a href="#如何知道mqs的，mqs的数据从哪儿来？" class="headerlink" title="如何知道mqs的，mqs的数据从哪儿来？"></a>如何知道mqs的，mqs的数据从哪儿来？</h4><p>producer.start()方法</p>
<p>参考源码</p>
<ul>
<li>启动producer的时候会向nameserver发送心跳包</li>
<li>获取nameserver中的topic列表</li>
<li>使用topic向nameserver获取topicRouteData</li>
</ul>
<p><strong>TopicRouteData</strong>对象表示与某一个topic有关系的broker节点信息，内部包含多个QueueData对象（可以有多个broker集群支持该topic）和多个BrokerData信息（多个集群的多个节点信息都在该列表中）</p>
<p><strong>producer加工TopicRouteData，对应的多节点信息后返回mqs。</strong></p>
<h3 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h3><p>客户端完成负载均衡</p>
<ul>
<li><p>获取集群其他节点</p>
</li>
<li><p>当前节点消费哪些queue</p>
</li>
<li><p><strong>负载粒度直到Message Queue</strong></p>
</li>
<li><p><strong>consumer的数量最好和Message Queue的数量对等或者是倍数，不然可能会有消费倾斜</strong></p>
</li>
<li><p>每个consumer通过</p>
<p>balanced</p>
<p>维护processQueueTable</p>
<ul>
<li><p>processQueueTable为当前consumer的消费queue</p>
</li>
<li><p>processQueueTable中有</p>
</li>
</ul>
</li>
</ul>
<pre><code>- ProcessQueue ：维护消费进度，从broker中拉取回来的消息缓冲
- MessageQueue ： 用来定位查找queue</code></pre><p>DefaultMQPushConsumer默认 使用AllocateMessageQueueAveragely（平均分配）</p>
<h3 id="当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>当消费负载均衡consumer和queue不对等的时候会发生什么？</h3><h4 id="平均分配"><a href="#平均分配" class="headerlink" title="平均分配"></a>平均分配</h4><p><img src="http://lion-heart.online/blog/2020-10-10-234835.png" alt="image20200313171617553"></p>
<h4 id="环形分配"><a href="#环形分配" class="headerlink" title="环形分配"></a>环形分配</h4><p><img src="http://lion-heart.online/blog/2020-10-10-234837.png" alt="image20200313171645109"></p>
<h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>平均分配策略(默认)(AllocateMessageQueueAveragely) 环形分配策略(AllocateMessageQueueAveragelyByCircle) 手动配置分配策略(AllocateMessageQueueByConfig) 机房分配策略(AllocateMessageQueueByMachineRoom) 一致性哈希分配策略(AllocateMessageQueueConsistentHash) 靠近机房策略(AllocateMachineRoomNearby)</p>
<p>consumer启动流程参考源码</p>
<h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><h4 id="SendResult"><a href="#SendResult" class="headerlink" title="SendResult"></a>SendResult</h4><p>producer在发送同步/异步可靠消息后，会接收到SendResult，表示消息发送成功</p>
<p>SendResult其中属性sendStatus表示了broker是否真正完成了消息存储</p>
<p>当sendStatus!=”ok”的时候，应该重新发送消息，避免丢失</p>
<p>当producer.setRetryAnotherBrokerWhenNotStoreOK</p>
<h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>影响消息正常发送和消费的重要原因是网络的不确定性。</p>
<p><strong>可能是因为consumer首次启动引起重复消费</strong></p>
<p>需要设置<code>consumer.setConsumeFromWhere</code></p>
<p>只对一个新的consumeGroup第一次启动时有效,设置从头消费还是从维护开始消费</p>
<p><strong>你们怎么保证投递出去的消息只有一条且仅仅一条，不会出现重复的数据?</strong></p>
<p>绑定业务key</p>
<p><strong>如果消费了重复的消息怎么保证数据的准确性?</strong></p>
<h3 id="引起重复消费的原因"><a href="#引起重复消费的原因" class="headerlink" title="引起重复消费的原因"></a>引起重复消费的原因</h3><h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a><strong>ACK</strong></h4><p>正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费，从queue中剔除</p>
<p>当ack因为网络原因无法发送到broker，broker会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer</p>
<h4 id="group"><a href="#group" class="headerlink" title="group"></a><strong>group</strong></h4><p>在CLUSTERING模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><p>处理消息前，使用消息主键在表中带有约束的字段中insert</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>单机时可以使用map <em>ConcurrentHashMap</em> -&gt; putIfAbsent guava cache</p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>使用主键或set操作</p>
<h2 id="如何让RocketMQ保证消息的顺序消费"><a href="#如何让RocketMQ保证消息的顺序消费" class="headerlink" title="如何让RocketMQ保证消息的顺序消费"></a>如何让RocketMQ保证消息的顺序消费</h2><p><strong>你们线上业务用消息中间件的时候，是否需要保证消息的顺序性?</strong></p>
<p><strong>如果不需要保证消息顺序，为什么不需要?假如我有一个场景要保证消息的顺序，你们应该如何保证?</strong></p>
<ul>
<li>同一topic</li>
<li>同一个QUEUE</li>
<li>发消息的时候一个线程去发送消息</li>
<li>消费的时候 一个线程 消费一个queue里的消息或者使用MessageListenerOrderly</li>
<li>多个queue 只能保证单个queue里的顺序</li>
</ul>
<h3 id="应用场景是啥？"><a href="#应用场景是啥？" class="headerlink" title="应用场景是啥？"></a>应用场景是啥？</h3><p>应用系统和现实的生产业务绑定，避免在分布式系统中多端消费业务消息造成顺序混乱</p>
<p>比如需要严格按照顺序处理的数据或业务</p>
<p><strong>数据包装</strong>/清洗</p>
<p>数据：</p>
<pre><code>import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;</code></pre><ol>
<li>去掉import</li>
<li>统计某个字符出现次数</li>
</ol>
<p><strong>业务流程处理</strong></p>
<p>返修过程</p>
<ol>
<li>收件录入信息</li>
<li>信息核对</li>
<li>送入检修系统处理</li>
</ol>
<p>电商订单</p>
<ol>
<li>创建订单</li>
<li>检查库存预扣库存</li>
<li>支付</li>
<li>真扣库存</li>
</ol>
<p>binlog同步</p>
<h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><ol>
<li>生产端如何保证投递出去的消息不丢失：消息在半路丢失，或者在MQ内存中宕机导致丢失，此时你如何基于MQ的功能保证消息不要丢失？</li>
<li>MQ自身如何保证消息不丢失？</li>
<li>消费端如何保证消费到的消息不丢失：如果你处理到一半消费端宕机，导致消息丢失，此时怎么办？</li>
</ol>
<h3 id="解耦的思路"><a href="#解耦的思路" class="headerlink" title="解耦的思路"></a>解耦的思路</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>发送消息时做消息备份（记日志或同步到数据库），判断sendResult是否正常返回</p>
<h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p><strong>节点保证</strong></p>
<ul>
<li>master接受到消息后同步刷盘，保证了数据持久化到了本机磁盘中</li>
<li>同步写入slave</li>
<li>写入完成后返回SendResult</li>
</ul>
<h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><ul>
<li>记日志</li>
<li>同步执行业务逻辑，最后返回ack</li>
<li>异常控制 </li>
</ul>
<p><strong>磁盘保证</strong></p>
<p>使用Raid磁盘阵列保证数据磁盘安全</p>
<p><strong>网络数据篡改</strong></p>
<p>内置TLS可以开启，默认使用crc32校验数据</p>
<h3 id="消息刷盘机制底层实现"><a href="#消息刷盘机制底层实现" class="headerlink" title="消息刷盘机制底层实现"></a>消息刷盘机制底层实现</h3><p>每间隔10ms，执行一次数据持久化操作</p>
<p>两种， 同步刷、异步刷</p>
<pre><code>   public void run() {
            CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);

            while (!this.isStopped()) {
                try {
                    this.waitForRunning(10);
                    this.doCommit();
                } catch (Exception e) {
                    CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);
                }
            }</code></pre><h2 id="rocketMq的消息堆积如何处理"><a href="#rocketMq的消息堆积如何处理" class="headerlink" title="rocketMq的消息堆积如何处理"></a>rocketMq的消息堆积如何处理</h2><p><strong>下游消费系统如果宕机了，导致几百万条消息在消息中间件里积压，此时怎么处理?</strong></p>
<p><strong>你们线上是否遇到过消息积压的生产故障?如果没遇到过，你考虑一下如何应对?</strong></p>
<p>具体表现为 ui中转圈圈</p>
<p>对于大规模消息发送接收可以使用pull模式，手动处理消息拉取速度,消费的时候统计消费时间以供参考</p>
<p>保证消息消费速度固定，即可通过上线更多consumer临时解决消息堆积问题</p>
<h3 id="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"><a href="#如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？" class="headerlink" title="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"></a>如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</h3><ul>
<li>准备一个临时的topic</li>
<li>queue的数量是堆积的几倍</li>
<li>queue分不到多broker种</li>
<li>上线一台consumer做消息的搬运工，把原来topic中的消息挪到新的topic里，不做业务逻辑处理，只是挪过去</li>
<li>上线N台consumer同时消费临时topic中的数据</li>
<li>改bug</li>
<li>恢复原来的consumer，继续消费之前的topic</li>
</ul>
<h3 id="堆积时间过长消息超时了？"><a href="#堆积时间过长消息超时了？" class="headerlink" title="堆积时间过长消息超时了？"></a>堆积时间过长消息超时了？</h3><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时</p>
<h3 id="堆积的消息会不会进死信队列？"><a href="#堆积的消息会不会进死信队列？" class="headerlink" title="堆积的消息会不会进死信队列？"></a>堆积的消息会不会进死信队列？</h3><p>不会，消息在消费失败后会进入重试队列（%RETRY%+consumergroup），多次（默认16）才会进入死信队列（%DLQ%+consumergroup）</p>
<h2 id="你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的"><a href="#你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的" class="headerlink" title="你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?"></a>你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?</h2><h2 id="零拷贝等技术是如何运用的"><a href="#零拷贝等技术是如何运用的" class="headerlink" title="零拷贝等技术是如何运用的?"></a>零拷贝等技术是如何运用的?</h2><p>使用nio的MappedByteBuffer调起数据输出</p>
<h2 id="你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理"><a href="#你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理" class="headerlink" title="你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?"></a>你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?</h2><p>分布式系统中的事务可以使用TCC（Try、Confirm、Cancel）、2pc来解决分布式系统中的消息原子性</p>
<p>RocketMQ 4.3+提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p>
<h4 id="RocketMQ实现方式"><a href="#RocketMQ实现方式" class="headerlink" title="RocketMQ实现方式"></a>RocketMQ实现方式</h4><p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p>
<p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，等待下一次回调。</p>
<p><strong>超时：</strong>如果超过回查次数，默认回滚消息</p>
<h4 id="TransactionListener的两个方法"><a href="#TransactionListener的两个方法" class="headerlink" title="TransactionListener的两个方法"></a>TransactionListener的两个方法</h4><h5 id="executeLocalTransaction"><a href="#executeLocalTransaction" class="headerlink" title="executeLocalTransaction"></a>executeLocalTransaction</h5><p>半消息发送成功触发此方法来执行本地事务</p>
<h5 id="checkLocalTransaction"><a href="#checkLocalTransaction" class="headerlink" title="checkLocalTransaction"></a>checkLocalTransaction</h5><p>broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p>
<h5 id="本地事务执行状态"><a href="#本地事务执行状态" class="headerlink" title="本地事务执行状态"></a>本地事务执行状态</h5><p><strong>LocalTransactionState.COMMIT_MESSAGE</strong></p>
<p>执行事务成功，确认提交</p>
<p><strong>LocalTransactionState.ROLLBACK_MESSAGE</strong></p>
<p>回滚消息，broker端会删除半消息</p>
<p><strong>LocalTransactionState.UNKNOW</strong></p>
<p>暂时为未知状态，等待broker回查</p>
<h2 id="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现"><a href="#如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现" class="headerlink" title="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?"></a>如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?</h2><h2 id="看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解"><a href="#看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解" class="headerlink" title="看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?"></a>看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?</h2><h2 id="高吞吐量下如何优化生产者和消费者的性能"><a href="#高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="高吞吐量下如何优化生产者和消费者的性能?"></a>高吞吐量下如何优化生产者和消费者的性能?</h2><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul>
<li>同一group下，多机部署，并行消费</li>
<li>单个consumer提高消费线程个数</li>
<li>批量消费<ul>
<li>消息批量拉取</li>
<li>业务逻辑批量处理</li>
</ul>
</li>
</ul>
<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><ul>
<li>网卡调优</li>
<li>jvm调优</li>
<li>多线程与cpu调优</li>
<li>Page Cache</li>
</ul>
<h2 id="再说说RocketMQ-是如何保证数据的高容错性的"><a href="#再说说RocketMQ-是如何保证数据的高容错性的" class="headerlink" title="再说说RocketMQ 是如何保证数据的高容错性的?"></a>再说说RocketMQ 是如何保证数据的高容错性的?</h2><ul>
<li>在不开启容错的情况下，轮询队列进行发送，如果失败了，重试的时候过滤失败的Broker</li>
<li>如果开启了容错策略，会通过RocketMQ的预测机制来预测一个Broker是否可用</li>
<li>如果上次失败的Broker可用那么还是会选择该Broker的队列</li>
<li>如果上述情况失败，则随机选择一个进行发送</li>
<li>在发送消息的时候会记录一下调用的时间与是否报错，根据该时间去预测broker的可用时间</li>
</ul>
<h2 id="Redis-面试题"><a href="#Redis-面试题" class="headerlink" title="Redis 面试题"></a>Redis 面试题</h2><p>高并发量大的话怎么处理热点数据<br>缓存击穿有哪些方案解决<br>什么是redis<br>Reids的特点<br>Redis支持的数据类型<br>Redis是单进程单线程的<br>虚拟内存<br>Redis锁<br>读写分离模型<br>数据分片模型<br>Redis的回收策略<br>使用Redis有哪些好处？<br>redis相比memcached有哪些优势？<br>redis常见性能问题和解决方案<br>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据<br>Memcache与Redis的区别都有哪些？<br>Redis 常见的性能问题都有哪些？如何解决？<br>Redis 最适合的场景</p>
<h2 id="熟悉-MySQL-关系型数据库"><a href="#熟悉-MySQL-关系型数据库" class="headerlink" title="熟悉 MySQL 关系型数据库"></a>熟悉 MySQL 关系型数据库</h2><h3 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h3><ol>
<li>客户端</li>
<li>Server 进程<ul>
<li>连接器：控制用户连接</li>
<li>分析器：词法分析、语法分析</li>
<li>优化器：优化 SQL，规定执行流程<ul>
<li>RBO</li>
<li>CBO</li>
</ul>
</li>
<li>执行器：执行组件</li>
</ul>
</li>
<li>存储引擎：不同的存放位置，不同的文件格式<ul>
<li>MyISAM：磁盘</li>
<li>Innodb：磁盘</li>
<li>Memory：内存</li>
</ul>
</li>
</ol>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="增删改操作时背后对应的原理"><a href="#增删改操作时背后对应的原理" class="headerlink" title="增删改操作时背后对应的原理"></a>增删改操作时背后对应的原理</h3><h3 id="Buffer-Pool-原理"><a href="#Buffer-Pool-原理" class="headerlink" title="Buffer Pool 原理"></a>Buffer Pool 原理</h3><p>Buffer Pool就是数据库的一个内存组件，具有完整的数据结构，里面缓存了磁盘上的真实数据，增删改操作首先就是针对这个内存中的Buffer Pool里的数据执行的，同时配合了后续的redo log、刷磁盘等机制和操作。</p>
<p>![crud](/Users/jinhongcai/Desktop/屏幕快照 2020-10-09 上午9.53.00.png)</p>
<h4 id="数据页：MySQL中抽象出来的数据单位"><a href="#数据页：MySQL中抽象出来的数据单位" class="headerlink" title="数据页：MySQL中抽象出来的数据单位"></a><strong>数据页：MySQL中抽象出来的数据单位</strong></h4><p>实际上MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据</p>
<h4 id="磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？"><a href="#磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？" class="headerlink" title="磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？"></a><strong>磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？</strong></h4><p>缓存页 和 数据页 一一对应，每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的比如包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂八的东西。</p>
<p>![屏幕快照 2020-10-09 上午10.21.16](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.21.16.png)</p>
<h4 id="数据库启动的时候，是如何初始化Buffer-Pool的？"><a href="#数据库启动的时候，是如何初始化Buffer-Pool的？" class="headerlink" title="数据库启动的时候，是如何初始化Buffer Pool的？"></a><strong>数据库启动的时候，是如何初始化Buffer Pool的？</strong></h4><p>数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区域，作为Buffer Pool的内存区域</p>
<p>然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据</p>
<p>执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中</p>
<h4 id="我们怎么知道哪些缓存页是空闲的呢？"><a href="#我们怎么知道哪些缓存页是空闲的呢？" class="headerlink" title="我们怎么知道哪些缓存页是空闲的呢？"></a><strong>我们怎么知道哪些缓存页是空闲的呢？</strong></h4><p>数据库会为Buffer Pool设计一个<strong>free链表</strong></p>
<p>![屏幕快照 2020-10-09 上午10.33.10](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.33.10.png)</p>
<h4 id="如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？"><a href="#如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？" class="headerlink" title="如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？"></a><strong>如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？</strong></h4><p>逻辑：</p>
<ol>
<li>Bufferpool 还会有一个哈希表数据结构，用表空间号+数据页号，作为一个key，然后缓存页的地址作为value</li>
<li>从free链表中找到一个空闲的缓存页</li>
<li>从磁盘上读取数据页写入缓存页</li>
<li>写入描述数据</li>
<li>从free指针清空</li>
</ol>
<p>![屏幕快照 2020-10-09 上午10.56.47](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.56.47.png)</p>
<h4 id="数据一致性问题？"><a href="#数据一致性问题？" class="headerlink" title="数据一致性问题？"></a>数据一致性问题？</h4><p>描述数据维护了flush 链表，flush 链表同 free 链表结构、作用相同，就是意义不同，描述缓存页是否是脏页</p>
<h4 id="缓存页淘汰问题？脏页淘汰机制"><a href="#缓存页淘汰问题？脏页淘汰机制" class="headerlink" title="缓存页淘汰问题？脏页淘汰机制"></a>缓存页淘汰问题？脏页淘汰机制</h4><p>![缓存命中率概念 + LRU 算法](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午11.21.52.png)</p>
<p>通过LRU维护了一个最近最少使用的 缓存页 结构。当需要加载数据页到缓存页，同时缓存页不足的情况下，就会通过LRU淘汰掉缓存命中率低的缓存页，触发刷盘机制。            </p>
<h4 id="什么是预读机制？"><a href="#什么是预读机制？" class="headerlink" title="什么是预读机制？"></a>什么是预读机制？</h4><p>从磁盘上加载一个数据页的时候，可能会把数据页相邻的其他数据页也加载到缓存里去</p>
<h4 id="什么情况会发生预读？"><a href="#什么情况会发生预读？" class="headerlink" title="什么情况会发生预读？"></a>什么情况会发生预读？</h4><ol>
<li>参数：innodb_read_ahead_theshold，默认值56。意思就是如果顺序的访问了一个区里的多个数据页，超过阈值，此时会触发预读机制，把下一个相邻区的所有数据页都加载到缓存里去</li>
<li>参数：innodb_random_read_ahead，默认 OFF。Buffer pool里缓存了一个区里的13个连续的数据页，而且这些数据页都是比较频繁会被访问，此时直接触发预读机制，当前区里其他数据页加载到缓存里</li>
<li>全表扫描，导致当前表空间内所有数据页全部加载到缓存页中</li>
</ol>
<h4 id="预读机制好处？"><a href="#预读机制好处？" class="headerlink" title="预读机制好处？"></a>预读机制好处？</h4><p>减少磁盘IO，提升性能</p>
<h4 id="什么场景会用到预读机制？预读带来的问题？"><a href="#什么场景会用到预读机制？预读带来的问题？" class="headerlink" title="什么场景会用到预读机制？预读带来的问题？"></a>什么场景会用到预读机制？预读带来的问题？</h4><p>发生预读，加载很多数据页到内存，这些缓存页未来可能都不会被访问到。如果free缓存页充足的情况下，没有问题。如果free不充足的情况，会将LRU上缓存页淘汰，但是很多预读的缓存页，在当前时刻可能是在 LRU 链表的头部区域，而经常被访问的缓存页，就会被优先淘汰，刷盘到磁盘</p>
<p>![预读问题](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.28.27.png)</p>
<h4 id="解决简单LRU链表带来的问题？"><a href="#解决简单LRU链表带来的问题？" class="headerlink" title="解决简单LRU链表带来的问题？"></a>解决简单LRU链表带来的问题？</h4><p>真正的LRU链表，会被拆分两部分，一部分热数据，一部分是冷数据，比例根据 innodb_old_blocks_pct 参数控制，默认37</p>
<p><img src="/Users/jinhongcai/Desktop/mysql/%E5%86%B7%E7%83%AD%E9%93%BE%E8%A1%A8%E6%8B%86%E5%88%86.png" alt="冷热链表拆分"></p>
<p>冷数据区域数据什么时候进入热数据区域，通过参数：innodb_old_blocks_time ，默认1000 ms，数据页被加载到缓存页 1s 后，访问当前缓存页，才会由冷数据区域挪动到热数据区域</p>
<p>![屏幕快照 2020-10-09 下午1.52.32](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.52.32.png)</p>
<h4 id="缓存数据刷盘"><a href="#缓存数据刷盘" class="headerlink" title="缓存数据刷盘"></a>缓存数据刷盘</h4><ol>
<li>定时通过后台线程，把冷数据区域尾部一些缓存页刷入磁盘。缓存页加入free链表、从flush链表移除、从lru链表移除</li>
<li>后台线程会在 mysql 不繁忙的时候，把flush链表中的缓存页刷入磁盘。flush、lru链表移除缓存页，free链表增加缓存页</li>
<li>无空闲缓存页，还需要加载数据页情况。先删掉LRU 冷数据区域尾部缓存页。</li>
</ol>
<h4 id="多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？"><a href="#多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？" class="headerlink" title="多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？"></a>多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？</h4><p>由于是共享变量，必须加锁。性能不会低</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>缓存页加载到 Buffer Pool 中，更新和读取缓存页里的数据。涉及到 free、flush、lru 链表。还包括后台线程是如何定时根据 flush、lru 链表将部分更新的缓存页刷盘，以及缓存页用完了以后是如何根据 lru 链表将一些冷数据缓存页刷盘。如何避免每次 crud 频繁刷盘 + 加载缓存页 这种多次磁盘 IO 浪费性能的操作</p>
<h3 id="为什么不能直接更新磁盘上的数据？"><a href="#为什么不能直接更新磁盘上的数据？" class="headerlink" title="为什么不能直接更新磁盘上的数据？"></a>为什么不能直接更新磁盘上的数据？</h3><p>每一个请求如果直接对磁盘文件进行随机读写，然后更新磁盘里的数据，最终结果就是性能低，并发度低，根本无法承受高并发的请求</p>
<h3 id="为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？"><a href="#为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？" class="headerlink" title="为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？"></a>为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？</h3><p>通过内存更新数据，然后写 redo log 以及提交事物，后台再通过定时刷盘机制，保证了没个更新请求，尽量就是更新内存，然后顺序写日志文件。更新内存的性能极高，然后顺序写磁盘上的日志文件性能也是比较高。</p>
<h3 id="MySql-为什么要引入数据页？"><a href="#MySql-为什么要引入数据页？" class="headerlink" title="MySql 为什么要引入数据页？"></a>MySql 为什么要引入数据页？</h3><p>数据更新如果不直接更新磁盘，更新哪些数据，保存在哪？所有问题都需要一个介质来链接，那就是缓存页，把磁盘上的数据加载到内存，更新缓存数据，同时写 redo log 到磁盘上</p>
<p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%B8%8D%E4%BB%A5%E7%A3%81%E7%9B%98%E4%B8%BA%E5%AA%92%E4%BB%8B.png" alt="数据更新不以磁盘为媒介"></p>
<h3 id="每次加载多少数据到内存？"><a href="#每次加载多少数据到内存？" class="headerlink" title="每次加载多少数据到内存？"></a>每次加载多少数据到内存？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%AF%8F%E6%AC%A1%E6%8C%89%E9%A1%B5%E7%BB%B4%E5%BA%A6%E5%8A%A0%E8%BD%BD.png" alt="数据每次按页维度加载"></p>
<h3 id="一行数据在磁盘上是如何存储的？包含哪些东西？"><a href="#一行数据在磁盘上是如何存储的？包含哪些东西？" class="headerlink" title="一行数据在磁盘上是如何存储的？包含哪些东西？"></a>一行数据在磁盘上是如何存储的？包含哪些东西？</h3><p>头字段描述 + 字段值</p>
<p>例如：”hello a a”，这一行数据具体有多少字段，都是什么，如果没有描述信息，根本无法解析</p>
<p>头字段描述 = 变长字段的长度列表，解决一行数据的读取问题</p>
<p>最终数据存储格式为：0x05 null值列表 数据头 hello a a </p>
<p>null值列表：所有允许为 NULL 的字段默认使用 bit表示，值为 NULL bit = 1 ，反之为 0，NULL 为什么不存 “NULL” 浪费空间</p>
<p>最终存储如下</p>
<pre><code>**变长字段列表 + NULL 值列表 + 字段头描述(40 bit ) + 隐藏字段 + 真实数据部分**</code></pre><p>隐藏字段</p>
<ol>
<li>DB_ROW_ID：数据库默认实现，行标识。</li>
<li>DB_TRX_ID：最近一次更新这条数据的事物id</li>
<li>DB_ROLL_PTR：回滚指针，事物回滚，指向你更新这个事务之前生成的 undo log</li>
</ol>
<p>每次数据变更都会更新隐藏字段</p>
<p>多事务串行更新一行数据，roll_poniter字段会把之前多个数据快照对应的undo log串联起来，形成重要的版本链</p>
<h3 id="ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"><a href="#ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值" class="headerlink" title="ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"></a>ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值</h3><p>触发时机：开启事务</p>
<p>关键结构：</p>
<ol>
<li>m_ids：未提交事务id集合</li>
<li>min_tx_id：未提交事务集合内最小事务id</li>
<li>max_tx_id：未提交事务id集合内最大事务id + 1</li>
<li>creator_tx_id：当前事务id</li>
</ol>
<p>原理</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
  可以读，数据的更新时间是在当前事务开启前就已经提交了
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件
    <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
      当前tx_id 是否存在 m_ids 内。存在就顺着 roll_poniter 日志链往下找，找到小于 min_trx_id 的记录  
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="什么是行益出？"><a href="#什么是行益出？" class="headerlink" title="什么是行益出？"></a>什么是行益出？</h3><p>结合 Buffer Pool + 行数据在磁盘的存储结构，我们很容易就得到如下结论</p>
<p>一个 BufferPool 包含多个 <code>cache line</code> ，一个<code>cache line</code> 默认大小是 16KB，包含若干条行数据。如果行数据特别大或正巧一个磁盘数据页包含了半行数据，这样的数据如何处理。这样的问题也叫<code>行益出</code>，益出到其他数据页，存放益出数据页，也叫<code>益出页</code></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>insert 一条数据的时候，实际上 mysql 是在内存插入了一个复杂的数据结构，这些有复杂结构的行数据会被刷新到磁盘</p>
<h3 id="NULL-为啥用-bit-表示？"><a href="#NULL-为啥用-bit-表示？" class="headerlink" title="NULL 为啥用 bit 表示？"></a>NULL 为啥用 bit 表示？</h3><p>存储空间问题</p>
<h3 id="为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？"><a href="#为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？" class="headerlink" title="为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？"></a>为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？</h3><p>语言特性导致，不同语言如果用特定的序列化方式，跨语言将会反序列化异常。而数据库作为通用存储介质，不允许这种定制化存储方式来存储数据</p>
<h4 id="Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？"><a href="#Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？" class="headerlink" title="Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？"></a>Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？</h4><p>逻辑概念 = 只需要知道有哪些表，表里有哪些字段，表里有多少行，在哪存储并不关心</p>
<p>物理概念 = 表里的数据都是存储在一个表空间里，表空间是由一堆磁盘里的数据文件组成，这些数据文件就一个个数据页</p>
<h3 id="redo-log-作用-crash-safe"><a href="#redo-log-作用-crash-safe" class="headerlink" title="redo log 作用 crash safe"></a>redo log 作用 crash safe</h3><p>提交事物了，事物修改的缓存页没来得及刷盘，此时MySQL宕机了，会导致 buffer pool 里被事物修改过的数据全部丢失</p>
<p>只要有 redo log 重启MySQL之后完全可以把这些修改了的缓存页还未刷盘的事物操作，他们对应的 redo log 都加载出来，在 buffer pool 的缓存页重新做一遍，保证数据不丢失 【checkpoint lsb】</p>
<p>![curd 对应的 redo log 操作](/Users/jinhongcai/Desktop/mysql/curd 对应的 redo log 操作.png)</p>
<h3 id="事物执行了一半后，回滚了怎么办？什么逻辑？"><a href="#事物执行了一半后，回滚了怎么办？什么逻辑？" class="headerlink" title="事物执行了一半后，回滚了怎么办？什么逻辑？"></a>事物执行了一半后，回滚了怎么办？什么逻辑？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E4%BA%8B%E7%89%A9%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8D%8A%EF%BC%8C%E5%8F%91%E7%94%9F%E5%9B%9E%E6%BB%9A.png" alt="事物执行一半，发生回滚"></p>
<p>从目前的架构和流程来看，buffer pool 已经变更，redo log block 也写入若干条日志信息，无法完成回滚或恢复的操作。</p>
<p>如果想要回滚就需要另一个非常重要的日志组件，undo log 回滚日志</p>
<h3 id="undo-log-回滚日志-作用"><a href="#undo-log-回滚日志-作用" class="headerlink" title="undo log(回滚日志) 作用"></a>undo log(回滚日志) 作用</h3><p>回滚事物或叫恢复 buffer pool 里的缓存页数据</p>
<p>因为只有事物操作才会更新 buffer pool ，并且操作是不可逆的，事务操作包括 insert、update、delete 语句去更新缓存页的数据，但是万一事务回滚了，你必须有每条 SQL 语句对应的 undo log 回滚日志，根据回滚日志去恢复缓存页里被更新的数据</p>
<h3 id="undo-log-回滚日志是什么格式？如何存储？"><a href="#undo-log-回滚日志是什么格式？如何存储？" class="headerlink" title="undo log 回滚日志是什么格式？如何存储？"></a>undo log 回滚日志是什么格式？如何存储？</h3><p>undo log 文件格式<br>每种 DML 对应的文件格式都不同</p>
<p>INSERT<br>日志开始位置：指定位置进行磁盘随机读写<br>主键的各列长度和值：每条记录都有主键，id、联合主键等等，即使没有主动设置过主键字段，MySQL 也会给你弄一个 row_id 作为隐藏主键<br>表id：表维度标示<br>日志编号：没个undo log 都有自己的编号，例如一个事物里有多个 SQL 语句，事物内的 undo log 记录为一组，默认从0开始<br>日志类型：TRX_UNDO_INSERT_REC<br>日志结束位置：指定位置进行磁盘随机读写</p>
<p>插入操作回滚流程 ：<br>    buffer pool 缓存页里插入了一条数据，执行了 insert，生成了 INSERT undo log<br>    回滚时直接把这条 insert 语句的 undo log 拿出来，undo log 里有表id、主键信息就可以直接定位到对应的表空间 + 缓存页，从里面删除掉之前 insert 进去的数据</p>
<pre class=" language-java"><code class="language-java">crud 实现原理
buffer pool 机制：找到表空间 <span class="token operator">-</span><span class="token operator">></span> 找到数据页 <span class="token operator">-</span><span class="token operator">></span> 加载到缓存页 <span class="token operator">-</span><span class="token operator">></span>更新缓存页 <span class="token operator">-</span><span class="token operator">></span>写 undo log <span class="token operator">-</span><span class="token operator">></span>写 redo log
    数据结构
    DescriptionDataBlock
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//  数据块 对应redo、undo log 头文件中标记的 数据块编号     </span>
        block_id <span class="token operator">=</span> block02<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//  free 链表的前、后节点</span>
        free_pre <span class="token operator">=</span> block01<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//  未使用情况</span>
        free_next <span class="token operator">=</span> block03<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//  使用情况</span>
        free_next <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//  flush 链表的前、后节点</span>
        flush_pre <span class="token operator">=</span> null<span class="token punctuation">;</span>
        flush_next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//  基础节点，数据页映射到缓存页，变更基础信息</span>
    FreeLinkedListBaseNode
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//  指向开始和结束节点指针</span>
        start <span class="token operator">=</span> block01<span class="token punctuation">;</span>
        end <span class="token operator">=</span> block03<span class="token punctuation">;</span>
        count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//  基础节点，缓存页更新过，当前节点就为脏节点</span>
    FlushLinkedListBaseNode
    <span class="token punctuation">{</span>
        start <span class="token operator">=</span> block02<span class="token punctuation">;</span>
        end <span class="token operator">=</span> block02<span class="token punctuation">;</span>
        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//  冷热数据区划分等情况</span>
    LRUBaseNode
    <span class="token punctuation">{</span>
        start
    <span class="token punctuation">}</span>

undo log 机制：事物回滚流程
redo log 机制：由于事物提交后，并没有把事物更新的缓存页进行刷盘，很容易丢数据，同时也保证了 MySQL 高性能。所以在事物提交后，把对缓存页的修改以日志的形式写入 redo log，以保证修改的数据不丢失保证

核心疑问点：把缓存页刷盘，跟你做的 redo log 都写入日志文件，都是磁盘操作，有什么差别？
 A：二个方面来回答
    <span class="token number">1</span>。刷盘方式
        缓存页采用的是磁盘随机读写
        类似 datafile<span class="token punctuation">.</span>locatexxx
            datafile<span class="token punctuation">.</span>writexxxx

        redo log 文件采用的是磁盘顺序写    
        引入 mmap 原理
    <span class="token number">2</span>。磁盘IO，数据量的大小很关键
        缓存页大小 16KB【有可能你只修改了缓存页里的几个<span class="token keyword">byte</span>，也要把整个缓存页都刷盘吗，浪费资源】
        redo log 大小 521byte



磁盘加载数据页 <span class="token operator">-</span><span class="token operator">></span> buffer pool <span class="token operator">-</span><span class="token operator">></span> 变更缓存页 <span class="token operator">-</span><span class="token operator">></span> 记录 undo log、redo log

redo log 文件格式
磁盘上存在若干个可以指定大小的 redo log 磁盘文件
MySQL 进程内有一块 redo log buffer 缓存区域默认 16M，里面存放大量 redo log block对象<span class="token punctuation">(</span>一种复杂的数据结构<span class="token punctuation">)</span>

redo log block
<span class="token punctuation">{</span>   
    header 12byte
    <span class="token punctuation">{</span>
        块编号
        写入数据长度
        日志分组偏移量
        checkpoint no
    <span class="token punctuation">}</span>    
    body <span class="token number">496</span> <span class="token keyword">byte</span>
    <span class="token punctuation">{</span>
        日志类型 <span class="token operator">+</span> 表空间ID <span class="token operator">+</span> 缓存页号 <span class="token operator">+</span> 偏移量 <span class="token operator">+</span> 修改里几个字节值 <span class="token operator">+</span> 具体值
    <span class="token punctuation">}</span>
    trailer <span class="token number">4</span> <span class="token keyword">byte</span>
<span class="token punctuation">}</span>

</code></pre>
<h3 id="事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行"><a href="#事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行" class="headerlink" title="事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行"></a>事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行</h3><h3 id="多事务并发执行带来的问题"><a href="#多事务并发执行带来的问题" class="headerlink" title="多事务并发执行带来的问题"></a>多事务并发执行带来的问题</h3><p>脏读：读取到了其他事物更新过但未提交的数据<br>脏写：更新了其他事物更新过但未提交的数据<br>不可重复读：事物内对于同一共享变量，应该是可重复读的。不可重复读就是读取其他事物对同一共享变量修改过后并提交了事物的值<br>幻读：事物内查询到之前没有看到过的数据         </p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h5><table>
<thead>
<tr>
<th align="center">隔离级别/问题</th>
<th align="center">脏读/脏写</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">read uncommited</td>
<td align="center">V</td>
<td align="center">V</td>
<td align="center">V</td>
</tr>
<tr>
<td align="center">read commited</td>
<td align="center">X</td>
<td align="center">V</td>
<td align="center">V</td>
</tr>
<tr>
<td align="center">repeatable read</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">V</td>
</tr>
<tr>
<td align="center">serializer read</td>
<td align="center">X</td>
<td align="center">X</td>
<td align="center">X</td>
</tr>
</tbody></table>
<h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>原理：undoLog 多版本链条机制 + ReadView 视图机制</p>
<h4 id="MySQL-的-RR-如何实现避免幻读问题"><a href="#MySQL-的-RR-如何实现避免幻读问题" class="headerlink" title="MySQL 的 RR 如何实现避免幻读问题"></a>MySQL 的 RR 如何实现避免<code>幻读</code>问题</h4><p>RC：每次发起查询，都重新生成一个ReadView视图，每次查询都会更新 活跃事务id 列表，未在列表内且在最大事务id范围内的事务则是已提交事务</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id <span class="token operator">||</span> tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      可以读，数据的更新时间是在当前事务开启前就已经提交了
    可以读，说明当前数据在生成 ReadView 之前就已经提交了
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>RR：事务开启后，只会有一个 ReadView 视图，不会更新 活跃事务id 列表</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
  可以读，数据的更新时间是在当前事务开启前就已经提交了
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件
    <span class="token punctuation">}</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      可以读，说明当前数据在生成 ReadView 之前就已经提交了
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="MVCC-和-隔离级别关系"><a href="#MVCC-和-隔离级别关系" class="headerlink" title="MVCC 和 隔离级别关系"></a>MVCC 和 隔离级别关系</h3><p>早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。</p>
<p>对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化。有的数据库内建乐观锁，但是有的没有（比如MySQL就没有），所以需要开发人员自己在数据表里加version列，自己写业务代码实现。</p>
<blockquote>
<p>顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度</p>
<p>如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p>
</blockquote>
<p>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是<strong>对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。</p>
<p>这样，实现两个隔离级别就非常容易：</p>
<ul>
<li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li>
<li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）</li>
</ul>
<p>也可以主动添加共享锁</p>
<ul>
<li>select…… lock in share mode</li>
</ul>
<p>MVCC并不是万灵药。大量的业务问题的关键点在于，<strong>你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效</strong>。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景</p>
<p>在这种场景下</p>
<ul>
<li>在MySQL InnoDB，使用者会使用<code>select ... for update</code>手工加锁。或者干脆用Serializable隔离级别</li>
</ul>
<h3 id="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"><a href="#锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题" class="headerlink" title="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"></a>锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题</h3><table>
<thead>
<tr>
<th align="center">锁类型</th>
<th align="center">独占锁</th>
<th align="center">共享锁</th>
</tr>
</thead>
<tbody><tr>
<td align="center">独占锁</td>
<td align="center">互斥</td>
<td align="center">互斥</td>
</tr>
<tr>
<td align="center">共享锁</td>
<td align="center">互斥</td>
<td align="center">不互斥</td>
</tr>
</tbody></table>
<p>基于MVCC的并发读，是不需要加锁，根据隔离级别选择读取对应的版本，但是也可以主动加读锁 - 共享锁</p>
<h3 id="undo-log-写入时机"><a href="#undo-log-写入时机" class="headerlink" title="undo log 写入时机"></a>undo log 写入时机</h3><p>![undo log 回滚日志的写入时机](/Users/jinhongcai/Desktop/mysql/undo log 回滚日志的写入时机.png)</p>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h2 id="锁的底层机制"><a href="#锁的底层机制" class="headerlink" title="锁的底层机制"></a>锁的底层机制</h2><h2 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h2><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>Buffer Pool（数据页 = 内存级别更新速度） 磁盘随机写</p>
<p>redo log 磁盘顺序写</p>
<p>undo log 磁盘顺序写</p>
<h2 id="查询优化的底层原理"><a href="#查询优化的底层原理" class="headerlink" title="查询优化的底层原理"></a>查询优化的底层原理</h2><h2 id="数据库的建模"><a href="#数据库的建模" class="headerlink" title="数据库的建模"></a>数据库的建模</h2><h2 id="在数据库建模的时候，应该如何注意字段类型"><a href="#在数据库建模的时候，应该如何注意字段类型" class="headerlink" title="在数据库建模的时候，应该如何注意字段类型"></a>在数据库建模的时候，应该如何注意字段类型</h2><h2 id="索引类型的一些问题"><a href="#索引类型的一些问题" class="headerlink" title="索引类型的一些问题"></a>索引类型的一些问题</h2><h2 id="如何保证数据库避免死锁、高性能的运行"><a href="#如何保证数据库避免死锁、高性能的运行" class="headerlink" title="如何保证数据库避免死锁、高性能的运行"></a>如何保证数据库避免死锁、高性能的运行</h2><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ol>
<li><p>必要性，sql 慢，分析具体是哪个步骤慢</p>
<ul>
<li>方法 show profile show processlist 晋级版本 - performance schema</li>
</ul>
</li>
<li><p>针对具体步骤进行优化，一般都是 执行阶段，执行阶段一般就是索引优化</p>
<ul>
<li>有没有索引</li>
<li>走没走索引</li>
</ul>
</li>
</ol>
<h3 id="类型优化"><a href="#类型优化" class="headerlink" title="类型优化"></a>类型优化</h3><p>越小越好</p>
<p>越简单越好</p>
<p>避免使用 NULL</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h5 id="数据库连接池有哪些？"><a href="#数据库连接池有哪些？" class="headerlink" title="数据库连接池有哪些？"></a>数据库连接池有哪些？</h5><p>DBCP</p>
<p>C3P0</p>
<p>druid</p>
<h5 id="索引是什么？如何实现？优缺点？用途？分类？技术点？"><a href="#索引是什么？如何实现？优缺点？用途？分类？技术点？" class="headerlink" title="索引是什么？如何实现？优缺点？用途？分类？技术点？"></a>索引是什么？如何实现？优缺点？用途？分类？技术点？</h5><pre class=" language-html"><code class="language-html">索引：一种特殊的数据结构
实现
1.文件操作 -> IO 操作、磁盘文件操作
2.复杂的数据结构
参考结构
1.hash表
2.二叉树
3.AVL树
4.read-black
5.B Tree
6.B+ Tree

优点
1.大大减少服务器扫描的数据量
2.随机 IO -> 顺序 IO
缺点
1.增删改操作需要维护索引结构
2.需要额外的空间来存储索引数据</code></pre>
<pre class=" language-html"><code class="language-html">用途
1.where 子句
2.排序和分组可以利用索引天然的顺序特性，加快查询效率
3.可以使用 min max 函数</code></pre>
<table>
<thead>
<tr>
<th align="center">索引分类</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主键</td>
<td align="center">主键列，值不为空</td>
</tr>
<tr>
<td align="center">唯一</td>
<td align="center">唯一列，值可以为空</td>
</tr>
<tr>
<td align="center">普通</td>
<td align="center">普通列</td>
</tr>
<tr>
<td align="center">联合</td>
<td align="center">多个普通列</td>
</tr>
<tr>
<td align="center">全文</td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">技术点</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">回表</td>
<td align="center">非主键索引树，获取到主键后，再次进行主键索引树查询</td>
</tr>
<tr>
<td align="center">覆盖索引</td>
<td align="center">不进行回表的查询行为</td>
</tr>
<tr>
<td align="center">最左匹配</td>
<td align="center">联合索引，where 子句 条件顺序要满足 联合索引顺序，才可以走索引树</td>
</tr>
<tr>
<td align="center">索引下推</td>
<td align="center">联合索引下，在存储引擎内完成数据的检索</td>
</tr>
<tr>
<td align="center">索引合并</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>mysql的三大引擎是啥？ 文件存储结构、索引类型、索引结构、事务、锁级别、使用场景<br>    mysql常用的引擎有InnoDB，MyISAM，Memory，默认是InnoDB<br>    InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引<br>    ps:优点：具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。<br>    缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大</p>
<pre><code>MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引
ps: 优点：占用空间小，处理速度快（相对InnoDB来说）
缺点：不支持事务的完整性和并发性

MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型
ps: 优点：速度要求快的，临时数据
缺点：丢失数据


myisam读的效果好，写的效率差，这和它数据存储格式，索引的指针和锁的策略有关的，它的数据是顺序存储的，他的索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快

innodb支持行锁，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，仍然会锁定表,mysql的读写之间是可以并发的
普通的select是不需要锁的，当查询的记录遇到锁时，用的是一致性的非锁定快照读，也就是根据数据库隔离级别策略，会去读被锁定行的快照，其它更新或加锁读语句用的是当前读，读取原始行因为普通读与写不冲突，所以innodb不会出现读写饿死的情况，又因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低</code></pre><p>innodb对一行数据的读会加锁吗<br>    早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。<br>    对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化，所以需要开发人员自己在数据表里加version列，自己写业务代码实现。<br>    顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度<br>        如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p>
<pre><code>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。

这样，实现两个隔离级别就非常容易：

Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本
Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）
也可以主动添加共享锁select…… lock in share mode
MVCC并不是万灵药。大量的业务问题的关键点在于，你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景
在这种场景下，在MySQL InnoDB，使用者会使用select ... for update手工加锁。或者干脆用Serializable隔离级别</code></pre><p>mysql是如何实现事务的<br>    undo log 回滚日志<br>    redo log 重做日志</p>
<p>MySQL事务特性和隔离级别<br>    ACID<br>    RR<br>    RU<br>    RC<br>    S</p>
<p>mysql的默认隔离级别<br>    RR</p>
<p>mysql的binlog<br>    主从复制也需要依靠binlog</p>
<pre><code>binlog 存在于Mysql Server层中，主要用于数据恢复；当数据被误删时，可以通过上一次的全量备份数据加上某段时间的binlog将数据恢复到指定的某个时间点的数据。
redo log 存在于InnoDB 引擎中，InnoDB引擎是以插件形式引入Mysql的，redo log的引入主要是为了实现Mysql的crash-safe能力。

statement：statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.
row：row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter able),因此这种模式的文件保存的信息太多,日志量太大.
mixed：mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</code></pre><p>主从复制<br>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式</p>
<p>索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；<br>聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。<br>聚簇索引：有主键时，根据主键创建聚簇索引<br>        没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>        如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引</p>
<p>非聚簇索引：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引</p>
<p>B+树和B树区别？<br>B树的非叶子节点存储实际记录的指针，而B+树的叶子节点存储实际记录的指针<br>B+树的叶子节点通过指针连起来了, 适合扫描区间和顺序查找。</p>
<p>查看 SQL 是不是使用了索引？<br>    执行计划</p>
<p>mysql的级锁加在哪个位置<br>表级：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许<br>行级：仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。<br>页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>索引的类型<br>    主键<br>    唯一<br>    普通<br>    联合<br>    全文</p>
<p>redo log的概念是什么？为什么会存在？<br>    在思考这个问题之前，我们可以先看看MySQL INNODB执行一条update语句的流程<br>    1.将数据所在的数据页加载到BufferPool对应的缓存页(事务开始)<br>    2.将数据的旧值写入到undolog中<br>    3.更新数据在BufferPool中的值<br>    4.写redolog日志<br>    5.写binlog归档日志<br>    6.事务提交，在redolog中写commit标记<br>    7.数据会在之后的某个时刻刷入硬盘中的数据页<br>    redolog其实就是上面第四步的操作，他记录的是数据修改之后的值，他的意义在于，当我们事务提交之后但bufferpool中修改后的数据还没有刷入磁盘的时候机器宕机了，那么我们就可以根据redolog中的日志来恢复内存中的数据</p>
<p>那为什么不直接在提交事务的将修改的数据刷入硬盘？<br>    原因有以下几点：<br>    1.数据在内存中修改的数据很快，但磁盘随机写很慢<br>    2.数据在磁盘和内存中是以页为单位的，默认是16kb，假如你就改了一天数据的某个属性就需要将这一整个数据页刷入硬盘，效率很低。而redolog就快很多，首先他不是随机在磁盘写    ，而是通过追加的方式写入redolog文件，速度快很多，然后他也不是直接往硬盘中的redolog文件写，而是先写入redologbuffer（默认大小16mb）中的redologblock（默认大小512字节）这个内存结构中，首先往redologbuffer中写的很快，然后会在极短时间内以redolog block为单位刷入到磁盘，这样的话性能就会很高</p>
<pre><code>redolog刷盘点 - page cache，由操作系统保证数据可靠性
    1.写满8M
    2.事务commit</code></pre><p>什么是WAL机制？好处是什么？<br>    (1).将redo log写入到buffer中的block中<br>    (2).调用写磁盘操作,这一步将redo log buffer中的 block 日志写到操作系统中的page cache里面。<br>    (3).调用os的fsync操作,将page cache中的redolog日志落盘,落盘之后数据便在磁盘上了</p>
<pre><code>上面就是WAL机制在redo log刷盘过程中的具体实现,其实我的理解就是将日志先写到内存中,然后某个时间在刷入磁盘,日志异步落盘。其实把数据从内存写入到磁盘看似就一个操作
(1).从磁盘随机写变成顺序写,性能提升巨大
(2).组提交,上面redolog的执行步骤第三步,调用fsync可以同时将多次第二步write操作写入到pagecache的数据一批落盘,这样的话就大量的减少了iops,减少磁盘压力</code></pre><p>redo log为什么能保证crash safe机制？<br>    MySQL通过两阶段提交的方式来保证CrashSafe。CrashSafe需要Server层、Binlog和InnoDB的协同工作才能完成。由于DDL和MyISAM不支持事务性，因此没办法保证CrashSafe</p>
<p>redo log和bin log 不同点有哪些？<br>    Redo Log是属于InnoDB引擎功能;Binlog是属于MySQL Server自带功能，所有引擎都可以使用，并且是以二进制文件记录。<br>    Redo Log属于物理日志，记录该数据页更新状态内容;Binlog是逻辑日志，记录更新操作语句的原始逻辑。<br>    Redo Log日志是循环写，日志空间大小是固定;Binlog是追加写入，写完一个写下一个，不会覆盖使用。<br>    Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力</p>
<p>什么是两阶段提交？为什么需要两阶段提交？两阶段提交如何保证数据库中两份日志间的逻辑一致性？<br>执行器在执行update语句时候的流程是什么样子的？<br>如果不是两阶段提交，先写binlog和先写redolog两种场景，各会遇到什么问题？<br>如何使用缓冲实现惰性B树？</p>
<p>Q：mysql对于千万级的大表如何优化？<br>很多人第一反应是各种切分；<br>我给的顺序是:<br>第一优化你的sql和索引；<br>第二加缓存，memcached,redis；<br>第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；<br>第四如果以上都做了还是慢，不要想着去做切分，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；<br>第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；<br>第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的shardingkey,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p>
<p>有人也许要说第一步优化sql和索引这还用说吗？的确，大家都知道，但是很多情况下，这一步做的并不到位，甚至有的只做了根据sql去建索引，根本没对sql优化（中枪了没？），除了最简单的增删改查外，想实现一个查询，可以写出很多种查询语句，不同的语句，根据你选择的引擎、表中数据的分布情况、索引情况、数据库优化策略、查询中的锁策略等因素，最终查询的效率相差很大；优化要从整体去考虑，有时你优化一条语句后，其它查询反而效率被降低了，所以要取一个平衡点；即使精通mysql的话，除了纯技术面优化，还要根据业务面去优化sql语句，这样才能达到最优效果</p>
<p>mysql怎么实现redo log和binlog的一致性<br>    伪2pc分布式事务</p>
<h2 id="熟悉-GC常用算法，熟悉常见垃圾收集器，具有-JVM-调优经验"><a href="#熟悉-GC常用算法，熟悉常见垃圾收集器，具有-JVM-调优经验" class="headerlink" title="熟悉 GC常用算法，熟悉常见垃圾收集器，具有 JVM 调优经验"></a>熟悉 GC常用算法，熟悉常见垃圾收集器，具有 JVM 调优经验</h2><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>Java 类加载过程？<br>描述一下 JVM 加载 Class 文件的原理机制?<br>Java 内存分配。<br>如何判断一个对象是否存活？（或者 GC 对象的判定方法）<br>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？<br>System.gc() 和 Runtime.gc() 会做什么事情？<br>finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？<br>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？<br>什么是分布式垃圾回收（DGC）？它是如何工作的？<br>串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？<br>在 Java 中，对象什么时候可以被垃圾回收？<br>简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。<br>JVM 的永久代中会发生垃圾回收么？<br>Java 中垃圾收集的方法有哪些？<br>什么是类加载器，类加载器有哪些？<br>类加载器双亲委派模型机制？<br>3.JVM怎么监控<br>4.OOM没有heap文件怎么办?<br>    查看JVM配置是否配置oom导出dump文件，配置是否正确，一般合理的配置内存使用率来生成内存快照文件，不用非要oom后才生成快照文件<br>    配置方式<br>        一、<br>            jmap -dump:format=b,file=/usr/local/base/02.hprof 12942<br>        二、<br>            -XX:+HeapDumpOnOutOfMemoryError<br>            -XX:HeapDumpPath=/usr/local/base<br>    分析方式<br>        一、MAT<br>        二、在线分析</p>
<pre><code>如果未配置可以通过查看log去分析，同时赶紧配置自动导出dump配置，以应对以后的oom，能通过log去看出问题的原因一般很简单，例如：死循环、查询服务为分页获取了全量的数据，这些可以通过log很快定位。</code></pre><p>synchronized在jvm层面上是如何实现的？<br>Jvm的方法区存储了什么，有什么作用？<br>java堆的内存分配？<br>eden区和survivior区的比例，为什么survivor区分为俩块？<br>full GC问题如何定位？<br>java内存模型，垃圾回收机制，不可达算法？<br>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范，简化到什么地步？就是主内存，各个线程的工作内存，和CPU，而我们怎么在这一套内存模型中工作<br>read（从主存读取），load（将主存读取到的值写入工作内存），use（从工作内存读取数据来计算），assign（将计算好的值重新赋值到工作内存中），store（将工作内存数据写入主存），write（将store过去的变量值赋值给主存中的变量）<br>jvm的一些命令？<br>jps jstat -gc (查看gc情况)<br>jmap pid（查看进程内存状态）<br>jmap -heap pid（查看进程的堆状态）<br>jmap -histo PID这里会生成一个类的统计报表，此表非常简单，如显示什么类有多少个实例，共占了多少字节等<br>jmap -dump:format=b,file=heapdump.phrof pid （生成堆的快照文件）<br>jhat是一个Java堆复制浏览器。这个工具分析Java堆复制文件（例如，由上面的”jmap -dump”所产生的）<br>jstack 查看线程上下文<br>jinfo pid 描述：输出当前 jvm 进程的全部参数和系统属性</p>
<p>如何把java内存的数据全部dump出来？<br>答：1、获取内存详情：jmap -dump:format=b,file=e.bin pid<br>这种方式可以用 jvisualvm.exe 进行内存分析，或者采用 Eclipse Memory Analysis Tools (MAT)这个工具</p>
<ol start="2">
<li>获取内存dump： ?jmap -histo:live pid<br>这种方式会先出发fullgc，所有如果不希望触发fullgc 可以使用jmap -histo pid</li>
</ol>
<p>3.第三种方式：jdk启动加参数：<br>-XX:+HeapDumpBeforeFullGC?<br>-XX:HeapDumpPath=httxlogsdump<br>这种方式会产生dump日志，再通过jvisualvm.exe 或者Eclipse Memory Analysis Tools 工具进行分析</p>
<p>如何手动触发全量回收垃圾，如何立即触发垃圾回收<br>静态内部类加载到了哪个区？方法区<br>class文件编译后加载到了哪<br>java虚拟机的区域分配，各区分别存什么<br>jvm的内存布局，垃圾回收机制<br>类加载机制里的，双亲委派模型</p>
<p>什么是Java虚拟机，为什么要使用？</p>
<p>说说Java虚拟机的生命周期及体系结构。</p>
<p>说一说Java内存区域。<br>Java虚拟机中，数据类型可以分为哪几类？</p>
<p>怎么理解栈、堆？堆中存什么？栈中存什么？</p>
<p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p>
<p>在Java中，什么是是栈的起始点，同是也是程序的起始点？</p>
<p>为什么不把基本类型放堆中呢？</p>
<p>Java中，栈的大小通过什么参数来设置？</p>
<p>讲一讲垃圾回收算法。</p>
<p>如何解决内存碎片的问题？</p>
<p>如何解决同时存在的对象创建和对象回收问题？</p>
<p>讲一讲内存分代及生命周期。</p>
<p>什么情况下触发垃圾回收？</p>
<p>如何选择合适的垃圾收集算法？</p>
<p>JVM中最大堆大小有没有限制？</p>
<p>堆大小通过什么参数设置？</p>
<p>JVM有哪三种垃圾回收器？</p>
<p>吞吐量优先选择什么垃圾回收器？响应时间优先呢？</p>
<p>如何进行JVM调优？有哪些方法？</p>
<p>如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？JVM内存模型，GC机制和原理；GC分哪两种；什么时候会触发Full GC？</p>
<p>JVM里的有几种classloader，为什么会有多种？</p>
<p>什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；(这个我真的不会…)</p>
<p>什么情况下我们需要破坏双亲委派模型；</p>
<p>常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？</p>
<p>JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的；<br>happens before 原理<br>进程没有挂，但是没响应了了怎么查原因?<br>    手动生成：java core和dump文件分析cup和内存<br>    cpu:是否正在大量的计算占用了全部资源<br>    模拟请求：查看响应码和数据<br>    日志：查看请求日志，看是否有交互，定位是客户端问题还是服务端问题<br>    。。。。。<br>堆栈溢出一般什么情况下发⽣生,怎么应对<br>    堆溢出<br>        堆空间：空间不足<br>        栈空间：新建立线程的时候没有足够的内存去创建对应的虚拟机栈<br>        元数据空间：原来的class没有被卸载掉<br>                  如果应用程序本身比较大，涉及的类库比较多，但是我们分配给持久带的内存（通过-XX:PermSize和-XX:MaxPermSize来设置）比较小的时候也可能出现此种问题。<br>                  一些第三方框架，比如spring,hibernate都通过字节码生成技术（比如CGLib）来实现一些增强的功能，这种情况可能需要更大的方法区来存储动态生成的Class文件</p>
<pre><code>栈溢出
    栈的深度超过了虚拟机容许的最大深度所致：死循环、递归所致
    栈空间太小 XSS指定</code></pre><p>gc的策略，线上你遇到的问题，如何查看outofmemery,如果没有dump文件，该怎么排查；你们老年代用的那种收集器</p>
<h1 id="大促、备战需要做什么"><a href="#大促、备战需要做什么" class="headerlink" title="大促、备战需要做什么"></a>大促、备战需要做什么</h1><h2 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h2><ul>
<li><p>项目有没有进行 mysql 调优，如何做的？为什么这么做？</p>
<ul>
<li><pre class=" language-html"><code class="language-html">- 查询语句无论是使用哪种判断条件 **等于、小于、大于**， `WHERE` 左侧的条件查询字段不要使用函数或者表达式
- 使用 `EXPLAIN` 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分析，进行优化。
- 当你的 SELECT 根据业务合理使用 limit
- 为每一张表设置一个 ID 属性
- 避免在 `WHERE` 字句中对字段进行 `NULL` 判断
- 避免在 `WHERE` 中使用 `!=` 或 `&lt;>` 操作符
- 使用 `BETWEEN AND` 替代 `IN`
- 为搜索字段创建索引
- 选择正确的存储引擎，InnoDB 、MyISAM 、MEMORY 等
- 最左匹配原则
- 对于枚举类型的字段(即有固定罗列值的字段)，建议使用`ENUM`而不是`VARCHAR`，如性别、星期、类型、类别等
- 拆分大的 DELETE 或 INSERT 语句
- 选择合适的字段类型，选择标准是 **尽可能小、尽可能定长、尽可能使用整数**。
- 字段设计尽可能使用 `NOT NULL`</code></pre>
</li>
</ul>
</li>
<li><p>mysql 事务隔离级别知道吗？</p>
<ul>
<li>RU</li>
<li>RC</li>
<li>RR</li>
<li>serializable</li>
</ul>
</li>
<li><p>mvcc了解吗？mvcc 解决了什么问题？</p>
<ul>
<li>事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁</li>
<li>通过 readview + undolog 基于 RC + RR</li>
<li>readView 视图机制描述一下</li>
<li>undo log 版本描述一下</li>
<li>RC 事务隔离级别存在的问题描述一下</li>
<li>RR 事务隔离级别存在的问题描述一下</li>
</ul>
</li>
<li><p>redis 项目中使用了吗？怎么用的？</p>
<ul>
<li>五大value类型描述，各个类型的使用场景</li>
</ul>
</li>
<li><p>redis 的数据结构你知道的说一下</p>
</li>
<li><p>redis 常见问题以及解决方案（雪崩、穿透、击穿）</p>
</li>
<li><p>跳表、布隆过滤器数据结构说一下。有什么使用场景、好处。</p>
</li>
<li><p>redis 集群，项目中如何使用的</p>
</li>
<li><p>redis 内存淘汰策略</p>
</li>
<li><p>juc 包下用过哪些类，有没有看过源码</p>
</li>
<li><p>线程池执行过程</p>
</li>
<li><p>线程池淘汰策略</p>
</li>
<li><p>AQS 原理</p>
</li>
<li><p>手写 LRU 算法</p>
</li>
<li><p>Object 类了解吗？有哪些方法，具体说下每个方法的作用。</p>
</li>
<li><p>说下你了解的设计模式，项目中如何使用的。</p>
</li>
<li><p>设计模式的 8 大原则知道吗？开闭原则你如何理解的。</p>
</li>
<li><p>hashMap 了解吗？底层数据结构是什么，有没有看过源码，扩容机制了解吗？</p>
</li>
<li><p>mysql 了解吗？索引底层数据结构，为什么是 B+ 树。</p>
<ul>
<li>mysql 架构描述一下，最主要是三层结构，各层内的组件和功能</li>
<li>B+ 树的结构特点</li>
</ul>
</li>
<li><p>mysql 事务的原子性实现原理</p>
<ul>
<li>redo log + undo log</li>
</ul>
</li>
<li><p>说下 juc 下的 lock</p>
</li>
<li><p>线程池的参数以及各自的作用</p>
</li>
<li><p>介绍一个自己熟悉的项目，主要是业务逻辑。</p>
</li>
<li><p>项目中的难点，哪些地方做的不好有什么改进的方法。</p>
</li>
<li><p>设计一个可以支撑峰值20万QPS，5千写库操作的系统。</p>
</li>
<li><p>系统设计（上一个问题）的缺陷在哪里，如何解决</p>
</li>
<li><p>介绍一下自己做的最好的一个项目，有哪些亮点。具体说一下细节。</p>
</li>
<li><p>数据库与缓存一致性解决方案，不同方案适用场景以及存在的问题。</p>
</li>
<li><p>设计一个支撑 10 万 QPS 的系统查看当前滴滴司机查看历史订单的系统。</p>
</li>
<li><p>手写一个时间复杂度为O（n），空间复杂度为O（1）的将一个单链表转为为一个新的按照奇偶顺序的新的单链表。</p>
</li>
<li><p>hashMap 底层数据结构，扩容过程。树化的条件，平时项目怎么使用的。</p>
</li>
<li><p>synchronized 和 lock 的区别。各自实现原理</p>
</li>
<li><p>说说你对并发中的原子性、可见性、有序性的理解</p>
</li>
<li><p>线程有几个状态？线程池各个参数说一下</p>
</li>
<li><p>jvm 垃圾回收算法有哪些</p>
</li>
<li><p>jvm 垃圾回收器你知道哪些？jdk8 默认垃圾回收器是什么？</p>
</li>
<li><p>项目中有没有 jvm 调优的经验</p>
</li>
<li><p>如果让你设计一个 jvm 内存管理系统，你会怎么做。</p>
</li>
<li><p>说下你认为做的最好的一个项目的业务逻辑。</p>
</li>
<li><p>项目中遇到最大的问题，你是如何解决的。</p>
</li>
<li><p>java8 新特性了解吗？项目中怎么使用的</p>
</li>
<li><p>有没有进行过代码重构，怎么做的以及原因</p>
</li>
<li><p>项目中如何进行 mysql 调优的，说下过程</p>
</li>
<li><p>为什么使用索引会加快查询速度</p>
</li>
<li><p>分布式锁了解吗？什么场景下会用，怎么使用。</p>
</li>
<li><p>redis 集群有几种，热 key 问题如何解决。</p>
</li>
<li><p>redis 持久化方式有几种，原理是什么？</p>
</li>
<li><p>手写一个 demo 可以控制多个线程在同一时间同时执行相同任务。</p>
</li>
<li><p>spring 中 bean 的生命周期 spring 事务实现原理，事务不生效的场景有哪些</p>
</li>
<li><p>分布式事务了解吗？如何实现，各自优缺点</p>
</li>
<li><p>java 自带的 jvm 监控工具使用过吗？可以说一下具体使用案例吗？</p>
</li>
<li><p>线上 oom 如何排查</p>
</li>
<li><p>如何在不影响线上系统运行的情况下进行数据库水平扩容，给出一个可行的方案</p>
</li>
<li><p>一条SQL的执行流程</p>
<ul>
<li>From on join where group by having select order by</li>
<li><a href="https://github.com/bjmashibing/InternetArchitect" target="_blank" rel="noopener">https://github.com/bjmashibing/InternetArchitect</a></li>
<li><a href="https://github.com/algorithmzuo/algorithmbasic2020" target="_blank" rel="noopener">https://github.com/algorithmzuo/algorithmbasic2020</a></li>
<li>列不可分</li>
<li>不能存在传递依赖</li>
<li>表内数据依赖主键</li>
</ul>
</li>
<li><p>统计一个文本  总工有多少行出现hello单词</p>
<ul>
<li>cat xxx | grep  ‘hello’ | wc -l</li>
</ul>
</li>
<li><p>如何定位到占用cpu高的线程</p>
<ul>
<li>top 命令</li>
</ul>
</li>
<li><p>top命令里面load值含义</p>
<ul>
<li><p><strong>服务器CPU和LOAD高是什么原因呢？</strong></p>
</li>
<li><p><strong>经常遇到的一个问题，收到CPU高或者LOAD高或者都有的监控告警信息，是有问题了吗？</strong></p>
</li>
<li><p><strong>应该怎么处理呢？</strong></p>
</li>
<li><p><strong>怎么找到原因呢？</strong></p>
</li>
<li><p>一、 了解下什么是系统负载load </p>
</li>
<li><p>1、我们通过top命令w命令uptime命令都能看到我们讲的load 平均值</p>
<p>2、实际是从/proc/loadavg读取到的</p>
<p><img src="http://lion-heart.online/blog/2020-10-13-160540.png" alt="Top命令"></p>
<p>先大致说下这三个数字的含义：顺序解释为，系统在过去1分钟、5分钟、15分钟内运行队列的情况 </p>
</li>
</ul>
</li>
</ul>
<pre><code>二、 根据单核CPU和多核CPU情况区分判断 

1、 单核CPU – 举例为单车道过桥 - 数字在0.00-1.00正常；如果在0.00-1.00之间，属于畅通；刚好1.00，刚好达到这条路的承载量；超过1.00，属于拥堵需要等待前面的车辆先通过

2、 多核CPU – 举例为多车道过桥 - 数字/CPU核数 在0.00-1.00之间正常；多核CPU的话，满负荷状态的数字为 “1.00 * CPU核数”，即双核CPU为2.00，四核CPU为4.00，64核为64。

3、 获得CPU逻辑核心数目的方法 grep &#39;model name&#39; /proc/cpuinfo |wc –l 



三、 对系统负载的一些误解:

1. 负载高就是性能有问题？ 
   - 负载高可能是应用在进行大量CPU密集型计算调动资源，这样属于正常情况。
2. 负载高就是CPU能力问题或者数量不够 ？
   - 负载高只代表运行的队列累积过多。具体的队列累计原因可能是CPU排队，也可能是IO密集型计算时IO排队造成
3. 系统长期负载高，应该增加CPU ？
   - 不一定，系统负载高是表象，要找到根本原因，是因为CPU资源过少造成的排队，还是因为应用本身逻辑造成资源浪费 



四、 cpu load 过高原因以及排查 

**造成cpu load过高的原因：从编程语言层次上full gc次数的增大或死循环都有可能造成cpu load 增高** 

具体的排查一句话描述就是： 首先要找到哪几个线程在占用cpu，之后再通过线程的id值在堆栈文件中查找具体的线程，看看出来什么问题。 寻找最占CPU的进程：

1、通过命令 ps aux
2、通过top -c命令显示进程运行信息列表 (按键P按CPU占有资源排序) 寻找最耗CPU的线程 

3、top -Hp 进程ID 显示一个进程ID的线程运行信息列表 (按键P按CPU占有资源排序) 如果该进程是java进程，需要具体查看是哪段代码造成的CPU负载过高，根据上述获得到的线程ID可以使用JDK下的jstack来查看堆栈。 由于在堆栈中线程id是用16进制表示的，因此可以将上述线程转化成16进制的表示。 

4、jstack java进程id | grep 16进制的线程id -C5 –color 



五、 查看系统负载vmstat具体解释

1. r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。
2. b 列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。
3. cpu 表示cpu的使用状态
4. us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序。
5. sy 列显示了内核进程所花费的cpu时间的百分比。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足。
6. wa 列显示了IO等待所占用的CPU时间的百分比。这里wa的参考值为30%，如果wa超过30%，说明IO等待严重，这可能是磁盘大量随机访问造成的，也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作)。
7. id 列显示了cpu处在空闲状态的时间百分比
8. system 显示采集间隔内发生的中断数
9. in 列表示在某一时间间隔中观测到的每秒设备中断数。
10. cs列表示每秒产生的上下文切换次数，如当 cs 比磁盘 I/O 和网络信息包速率高得多，都应进行进一步调查。
11. memory
12. swpd 切换到内存交换区的内存数量(k表示)。如果swpd的值不为0，或者比较大，比如超过了100m，只要si、so的值长期为0，系统性能还是正常
13. free 当前的空闲页面列表中内存数量(k表示)
14. buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。
15. cache: 作为page cache的内存数量，一般作为文件系统的cache，如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。
16. swap
17. si 由内存进入内存交换区数量。
18. so由内存交换区进入内存数量。
19. IO
20. bi 从块设备读入数据的总量（读磁盘）（每秒kb）。
21. bo 块设备写入数据的总量（写磁盘）（每秒kb）
22. 这里我们设置的bi+bo参考值为1000，如果超过1000，而且wa值较大应该考虑均衡磁盘负载，可以结合iostat输出来分析。 



六、 查看磁盘负载iostat具体解释 每隔2秒统计一次磁盘IO信息，直到按Ctrl+C终止程序，-d 选项表示统计磁盘信息， -k 表示以每秒KB的形式显示，-t 要求打印出时间信息，2 表示每隔 2 秒输出一次。第一次输出的磁盘IO负载状况提供了关于自从系统启动以来的统计信息。随后的每一次输出则是每个间隔之间的平均IO负载状况。

1. rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
2. wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
3. r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s
4. w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s
5. rsec/s: 每秒读扇区数。即 delta(rsect)/s
6. wsec/s: 每秒写扇区数。即 delta(wsect)/s
7. rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
8. wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)
9. avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
10. avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
11. await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
12. svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
13. %util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)
14. 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
15. idle小于70% IO压力就较大了,一般读取速度有较多的wait.
16. 同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)



七、 对于公司内部服务器load负载高，CPU占用高的原因排查，利用监控辅助综合判断 先通过mdc监控进行查看系统负载、CPU利用率，内存使用率

系统负载如果出现超过申请的弹性云核数的情况，属于负载高，就是说4核8G内存的弹性云服务器，系统负载持续超过4就是在持续超负载运行了

CPU使用率超过80%属于CPU使用率 造成原因分3种情况，那么接下来开始查看是什么原因造成

1. 可能性最大的，自身应用造成负载和CPU飙高，只要重启一下这台服务器上的应用，在监控上看到CPU使用率和负载在重启期间下降了，应用启动后没有升高到原先高度，判断为因为程序中有阻塞造成CPU飙高，CPU飙高造成系统负载高。 建议再重启应用前，如果条件允许，先使用WLOMC自助运维平台的CPU飙高分析功能查看造成CPU高的线程信息，找到对应阻塞原因

2. 还可能是因为流量大，超过了此配置单台弹性云处理能力，通过mdc监控查看网络流量是不是较CPU飙高前的流量大很多，如果是流量增大造成的CPU高，典型现象是重启应用时，系统负载和CPU使用率下降，然后启动后瞬间到达很高（比重启前还高），因为流量的增大造成CPU排队使负载增高，然后大概几分钟降到重启前的数值。

   ```
   另一典型现象是在命令行执行ss -s查看，发现TCP连接数高，但是链接中的ESTABLISHED并不多，CLOSED和TIMEWAIT很多，就说明流量大，处理比较吃力，很多链接来不及释放。
   ```

3. 还有一种可能，是属于弹性云服务器的BUG，停止服务器上的所有应用，没有CPU使用高的应用，依然负载很高，说明不是本机使用造成的负载高

通过cat /etc/config_info查看弹性云服务器的宿主物理机IP，联系CAP运维提供弹性云IP帮忙排查，通常情况会建议缩容此台弹性云，另申请一台不同ZONE的弹性云使用。</code></pre><ul>
<li><p>threadlocal</p>
</li>
<li><p>hashMap hashSet</p>
</li>
<li></li>
<li><p>索引失效原因</p>
</li>
<li><p>什么是慢sql</p>
</li>
<li><p>在线问答网站日活2亿   设计数据库</p>
</li>
<li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/blob/master/03%20数据库/SQL优化原理/sql优化原理.md" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/blob/master/03%20数据库/SQL优化原理/sql优化原理.md</a></p>
</li>
<li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/InnoDB%20MVCC的实现原理" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/InnoDB%20MVCC的实现原理</a></p>
</li>
<li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/根据树型数据结构分析Mysql索引" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/根据树型数据结构分析Mysql索引</a></p>
</li>
<li><p>Eden区 和from to 的默认比例</p>
</li>
<li></li>
<li><p>分布式事务</p>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://orgjinhc.github.io" rel="external nofollow noreferrer">靳宏财</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://orgjinhc.github.io/2021/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/">http://orgjinhc.github.io/2021/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="http://orgjinhc.github.io" target="_blank">靳宏财</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E9%9D%A2%E8%AF%95/">
                                    <span class="chip bg-color">面试</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/reward/wechatPay.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2021-01-19T10-27-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/01/24/personal-project/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/featureimages/20.jpg" class="responsive-img" alt="personal-project">
                        
                        <span class="card-title">personal-project</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            系统架构核心流程登陆模块权限模块用户表角色表权限功能表用户角色关联表角色权限功能关联表第一步：公网IP：8.131.62.192
第二步：连接工具ssh root@8.131.62.192
第三步：各种工具第四步：注意事项端口
防火墙
更新
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-01-24
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            靳宏财
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/01/17/zookeeper/">
                    <div class="card-image">
                        
                        
                        <img src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/medias/featureimages/20.jpg" class="responsive-img" alt="zookeeper">
                        
                        <span class="card-title">zookeeper</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            ZAB 协议原子消息广播协议
Zookeeper 开源的分布式协调服务，让分布式系统中每个节点的信息能够同步和共享,也是一种数据一致性解决方案。
同步：通过网络进行信息同步，类似邮件、IM工具等
共享：通过共享存储完成共享，类似Git、SV
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-01-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            靳宏财
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: Lion Heart<br />'
            + '文章作者: 靳宏财<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="http://orgjinhc.github.io" target="_blank">靳宏财</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">127.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/orgjinhc" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="orgjinhc@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1152062154@qq.com" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1152062154" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '');
</script>


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/orgjinhc/orgjinhc.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
