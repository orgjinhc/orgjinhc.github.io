<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>亿级流量方案</title>
      <link href="/2021/04/17/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E6%96%B9%E6%A1%88/"/>
      <url>/2021/04/17/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="亿级流量方案"><a href="#亿级流量方案" class="headerlink" title="亿级流量方案"></a>亿级流量方案</h1><h2 id="一、模块化服务下的微服务支撑方案"><a href="#一、模块化服务下的微服务支撑方案" class="headerlink" title="一、模块化服务下的微服务支撑方案"></a>一、模块化服务下的微服务支撑方案</h2><p>PTS  -&gt;  SLB  -&gt;  K8S -&gt; ingress</p><p>吞吐量 和 响应时延 内八/外八</p><p>同步架构</p><p>异步架构</p><ul><li>亿级流量，高并发场景，最注重的环节是那个？<ul><li>调度器（流量调度、服务调度）</li><li>服务规模</li></ul></li></ul><h3 id="3-业务遇见突发流量的解决方案"><a href="#3-业务遇见突发流量的解决方案" class="headerlink" title="3.业务遇见突发流量的解决方案"></a>3.业务遇见突发流量的解决方案</h3><p>CPU、内存、服务流量QPS激增</p><h4 id="3-1-自动扩容：无法应对大流量突发情况"><a href="#3-1-自动扩容：无法应对大流量突发情况" class="headerlink" title="3.1 自动扩容：无法应对大流量突发情况"></a>3.1 自动扩容：无法应对大流量突发情况</h4><ul><li>服务支撑能力快过流量</li><li>弹性伸缩策略</li></ul><h4 id="3-2-定时扩容：对自动扩容的补充，应对流量丢失的情况"><a href="#3-2-定时扩容：对自动扩容的补充，应对流量丢失的情况" class="headerlink" title="3.2 定时扩容：对自动扩容的补充，应对流量丢失的情况"></a>3.2 定时扩容：对自动扩容的补充，应对流量丢失的情况</h4><h4 id="3-3-手动扩容"><a href="#3-3-手动扩容" class="headerlink" title="3.3 手动扩容"></a>3.3 手动扩容</h4><p>Nginx 流量配置</p><h3 id="5-流量模型"><a href="#5-流量模型" class="headerlink" title="5.流量模型"></a>5.流量模型</h3><h4 id="5-1-定时模式"><a href="#5-1-定时模式" class="headerlink" title="5.1 定时模式"></a>5.1 定时模式</h4><h4 id="5-2-动态模式"><a href="#5-2-动态模式" class="headerlink" title="5.2 动态模式"></a>5.2 动态模式</h4><h4 id="5-3-定时-动态"><a href="#5-3-定时-动态" class="headerlink" title="5.3 定时 + 动态"></a>5.3 定时 + 动态</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>云服务和云存储搭建流程</title>
      <link href="/2021/04/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%92%8C%E4%BA%91%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/04/15/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%92%8C%E4%BA%91%E5%AD%98%E5%82%A8%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="云服务和云存储搭建流程"><a href="#云服务和云存储搭建流程" class="headerlink" title="云服务和云存储搭建流程"></a>云服务和云存储搭建流程</h1><h1 id="创建实流程"><a href="#创建实流程" class="headerlink" title="创建实流程"></a>创建实流程</h1><h2 id="1-服务器：物理机"><a href="#1-服务器：物理机" class="headerlink" title="1.服务器：物理机"></a>1.服务器：物理机</h2><h2 id="2-镜像：操作系统"><a href="#2-镜像：操作系统" class="headerlink" title="2.镜像：操作系统"></a>2.镜像：操作系统</h2><h2 id="3-网络和安全组"><a href="#3-网络和安全组" class="headerlink" title="3.网络和安全组"></a>3.网络和安全组</h2><p>网络：带宽</p><p>安全组：0 ～ 65535 个端口。本机IP。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="a-阿里云ECS服务器搭建流程"><a href="#a-阿里云ECS服务器搭建流程" class="headerlink" title="a.阿里云ECS服务器搭建流程"></a>a.阿里云ECS服务器搭建流程</h3><p>[阿里云ECS服务器搭建流程](<a href="https://shimo.im/docs/pGjvtWrjrKKXvPdC/" target="_blank" rel="noopener">https://shimo.im/docs/pGjvtWrjrKKXvPdC/</a> 《阿里云ecs服务器搭建》，可复制链接后用石墨文档 App 或小程序打开)</p><h3 id="b-PolarDB使用流程"><a href="#b-PolarDB使用流程" class="headerlink" title="b.PolarDB使用流程"></a>b.PolarDB使用流程</h3><p>[阿里巴巴自研PolarDB使用流程](<a href="https://shimo.im/docs/D3j9wKHkJjQWyrxH/" target="_blank" rel="noopener">https://shimo.im/docs/D3j9wKHkJjQWyrxH/</a> 《阿里巴巴自研PolarDB使用流程》，可复制链接后用石墨文档 App 或小程序打开)</p><h3 id="c-UTF-8-编码表，基于-Unicode-万国码"><a href="#c-UTF-8-编码表，基于-Unicode-万国码" class="headerlink" title="c.UTF - 8 :  编码表，基于 Unicode(万国码)"></a>c.UTF - 8 :  编码表，基于 Unicode(万国码)</h3><h3 id="d-开发模式演变"><a href="#d-开发模式演变" class="headerlink" title="d.开发模式演变"></a>d.开发模式演变</h3><h4 id="1-瀑布式"><a href="#1-瀑布式" class="headerlink" title="1.瀑布式"></a>1.瀑布式</h4><h4 id="2-敏捷迭代"><a href="#2-敏捷迭代" class="headerlink" title="2.敏捷迭代"></a>2.敏捷迭代</h4><h4 id="3-DevOps"><a href="#3-DevOps" class="headerlink" title="3.DevOps"></a>3.DevOps</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>中台</title>
      <link href="/2021/03/07/%E4%B8%AD%E5%8F%B0/"/>
      <url>/2021/03/07/%E4%B8%AD%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="中台：从一个故事开始"><a href="#中台：从一个故事开始" class="headerlink" title="中台：从一个故事开始"></a>中台：从一个故事开始</h2><h3 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h3><p><strong>*创新业务部*</strong>是京东物流下致力于创新的一个二级部门。与其它业务部门不同的是，创新业务部关注的领域比较垂直，主要负责将物流通用服务沉淀和服用，服务的群体也主要是有仓运配送等需求的商家和集团内有需求的部门。</p><p>大环境：2018 京东零售调整组织架构，在新的组织架构下，京东商城将围绕以客户为中心，划分为前中后台。中台为前台业务运营和创新提供专业能力的共享平台职能</p><p>内部环境：京东物流也跟随组织调整，进行部门内的中台战略，鼓励和督促各条业务线加快中台战略和转型与落地。创新业务部划出5个人力资源进行部门内的中台落地，创新业务中台由一系列<code>业务能力标准</code>、<code>业务组件</code>、<code>业务分析方法论</code>，进行<code>配置管理</code>和<code>流程监控</code>构成的体系，提供给业务方能够快速，低成本创新和赋能的能力。业务中台不是简单的产品或者平台，是全新的组织模型</p><p>没有中台概念的时候，往小的方面说，不同的业务体现在一段代码片段上通过不同的分支作区分，往大的方面说，不同的业务抽象出一个个系统来满足自己各个方面的业务。存在在业务边界划分不明确，出现烟囱开发，互相开始扯皮。</p><p>中台的概念出现后：从小的方面来说，就是把一个业务拆分成多个模块，然后把模块设计成通用的，其他业务可以直接集成使用。从大的方面来说，就是将这些系统，也就是业务进行连通，再一次进行抽象，将其相通的部分抽象出来，搭建不同职能的中台来提供服务。</p><p>中台定义：基本上小白阶段的摸索者，都倾向把中台理解成一个业务组件池，供前台有快速创新需要时，快速拼装，完成试错；但这种理解显然太理想化且狭义了</p><p>一眨眼，三个月的时间过去了。</p><p>再看此时的5人，疲惫不堪，被各方的压力压得喘不过气来，具体表现在：</p><ul><li>自打成立了中台团队，所有的内部、开放业务都会不断地提需求过来，中台的界限本身就比较模糊，但因为要整合复杂多样的接入流程，同时又有很多需求需要流程变更，所以很难拒绝各个业务方的需求，中台好像就成了所有业务团队共享的一个内部外包团队。需求拥堵和排期的问题也开始出现，需求多得天天加班都做不过来，业务侧还不断投诉中台的响应慢，影响了一线业务。</li><li>中台团队所处的位置也比较尴尬。干系方众多，前边有各个业务前台团队，后边还要集成企业已有的各种核心系统，还要面对领导的不断督促。而且最主要的是，各方感觉对于中台都有不同的理解和诉求，甚至有些不同干系方的诉求都会相互矛盾和冲突。中台团队被夹在各方中间，被各个干系方不断拉扯，非常难受。</li><li>还有，中台也已经建设了一段时间了，但是令人焦虑的是，感觉并没有什么太多的建设成果出来。做的东西很乱，主要是响应各个前台业务的需求，但是前台业务也不怎么爱用，提需求的时候一个比一个积极，真正做完了需要前台接入的时候，又是用各种理由推脱，不太愿意接入。感觉中台做了和没做也没有太大的区别，并没有达到预期的效果，甚至也没想清楚预期会有什么效果。</li></ul><p>类似的问题还有多，公司内部各个团队都是如此，在摸索中尝试中台建设</p><h3 id="中台到底为什么会这么火？"><a href="#中台到底为什么会这么火？" class="headerlink" title="中台到底为什么会这么火？"></a>中台到底为什么会这么火？</h3><p>无论是从涉及领域的宽度还是从战略到落地的纵深高度来讲，都是非常非常大的，向上可以触及到行业趋势、企业使命愿景战略，向下又可以落地到分布式架构、遗留系统重构、架构演进与守护、质量保证等等各个方面</p><ul><li><p>中台到底是什么？</p></li><li><p>中台与平台 / 微服务 /SaaS 的区别是什么？</p></li><li><p>中台与前台和后台的边界怎么界定？有了中台那后台是什么？</p></li><li><p>什么样的企业需要建中台，什么样的企业不需要建中台？对企业到底有哪些好处？</p></li><li><p>业务中台与数据中台的关系和区别又是什么？</p></li><li><p>中台建设有什么样的门槛，需要哪些准入条件？</p></li><li><p>中台该怎么建？分几个阶段？需要什么样的能力？</p></li><li><p>中台建设的结果好坏如何评估？谁来评估？</p></li></ul><ol><li><p>互联网企业的样板效应。这个毋容置疑，在当下，互联网公司，尤其是各个大厂的样板和标杆效应还是非常强的。更何况对于中台这件事情上，互联网企业们的态度又是这么的高度一致，在以往也是很少见的，而建设效果也实实在在被大家看在眼里，让人羡慕不已。</p></li><li><p>那互联网企业为什么会这么一致地推动中台呢？背后还有一个更深层次的原因就是今年火爆的产业互联网，在消费互联网阶段的中后期，消费侧的战场日益白热化。互联网企业为了追求持续增长，纷纷将目光转向了供给侧，这就是今年 ToB 也异常火爆的原因。而云和中台战略正是互联网企业进入传统行业的一个非常好的切入点，所以我们看到越来越多的互联网企业参与进传统企业上云和企业数字化转型过程中，把自己的技术和实践带到传统行业，在整个过程中，中台确实是一个很好的抓手和利器。</p></li><li><p>正所谓一个巴掌拍不响，这个时间点确实也正好匹配到了一些行业从系统化向平台化转型的节点。通过这些年的信息化建设和积累，企业内信息化系统该建的也都建了，什么 ERP、CRM 等，该有的也都有了。信息化建设启动早一些的企业，内部的各个系统也开始出现前面提到的烟囱林立、数据孤岛等痛点。而信息化建设相对晚一些的企业，也正好想通过这波中台浪潮来个弯道超车，一步到位。此时再赶上一阵中台旋风袭来，家家企业都觉得自己有做中台的需求和痛点，开始了自己的中台规划与建设。</p></li><li><p>最后，我认为还有一点也非常重要，也是底层的原因，就是这两年整体的经济大势并不太好，不确定性和不可预测性正在不断地冲击着各个企业甚至行业，而企业的管理者们对于企业未来发展的恐惧与焦虑倍增。这时候，互联网企业通过中台战略，把能力进行沉淀与复用，用确定性来应对不确定性，拥有快速试错、快速创新的能力和思路，这让传统企业看到了一个突围的方向。经济形势好的时候，大家要么都在忙着快速拓展业务，兵贵神速，怎么快怎么来；要么就是守在自己的成熟业务上，到点收成，也没有很强的动力改变。但经济形势严峻了，压力与恐惧越来越严重了，为了能保持企业未来的生存和可持续发展，或者为下次形势转好继续冲刺做好准备。所以，效仿互联网行业，中台战略也成了越来越多传统企业和行业的选择</p></li></ol><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="时间维度"><a href="#时间维度" class="headerlink" title="时间维度"></a>时间维度</h4><p>2019年IT圈什么最火，那中台一定会占据一席之地，就好像一时间只要跟中台相关的企业或是新闻都会备受瞩目，什么事情如果不跟中台概念沾点儿边，就好似会落后于时代，中台团队，人手一本 中台架构设计与实践，我每天的订阅号只关注中台消息，收藏的文章100+，发现在每篇文章里每个作者对于中台都有着自己的角度和观点，直到现在业界仍然无法完全统一。我一直遵循着一个观点，想要搞清楚一个概念或是一门技术，就先要回到历史里，回到它诞生的时间，漫步一遍它发展的历程，去探究一下它产生的背景和原因。</p><p><img src="http://lion-heart.online/blog/2021-03-07-063621.png" alt="image-20210307143621544"></p><p>2018大事件</p><ul><li>2018 年 9 月 30 日，腾讯宣布了 7 年来最大规模的组织变革，新成立了云与智慧产业事业群（CSIG）。同时，腾讯新成立了技术委员会，宣布未来将打造技术中台。</li><li>2018 年 11 月 26 日，阿里宣布进行组织升级，阿里云事业群升级为阿里云智能事业群，将中台智能化与阿里云全面结合。</li><li>2018 年 12 月 21 日，京东集团人力资源部发布关于京东商城组织架构调整的公告，公告内容称：“在新的组织架构下，京东商城将围绕以客户为中心，划分为前中后台。中台为前台业务运营和创新提供专业能力的共享平台职能。”</li></ul><h4 id="空间维度"><a href="#空间维度" class="headerlink" title="空间维度"></a>空间维度</h4><p>中台划分</p><p><img src="http://lion-heart.online/blog/2021-03-07-070339.png" alt="image-20210307150335268"></p><h5 id="业务中台"><a href="#业务中台" class="headerlink" title="业务中台"></a>业务中台</h5><p><strong>我们常提到的业务中台，可以理解成狭义的业务中台，通过将不同业务线解决相同问题域的解决方案进行抽象与封装，通过配置化、插件化、服务化等机制兼顾各条业务线的特性需求，实现对于不同业务线的业务支撑。</strong></p><p><img src="http://lion-heart.online/blog/2021-03-07-082910.png" alt="image-20210307162905487"></p><h5 id="数据中台"><a href="#数据中台" class="headerlink" title="数据中台"></a>数据中台</h5><p>数据中台为什么这么火热？我总结下来主要是这么几个原因。</p><ol><li>见效快。目前大部分传统企业的问题还在于数据不通，“数据孤岛”现象比较严重，数据中台的建设对于痛点的解决直接，驱动力强。</li><li>组织调整负担小。一般来说，有一定规模的企业都已经有了大数据团队或是 BI 团队，这个团队自然就承载着相关的职能，不需要再做大的组织调整。</li><li>有一定技术基础储备。大部分企业都进行了多年的数据仓库建设，或是随着前几年大数据的浪潮，已经构建了多年的大数据技术平台。</li><li>大势所趋。大家都在讲 DT（Data Technology）时代，对于数据的价值，企业的认识也越来越深刻，大家已经意识到数据不再只是一种运营辅助分析的工具，而逐渐成为企业的核心资产和竞争力。</li></ol><p>“<strong>业务中台就是在产生数据，数据中台是做数据的二次加工，并将结果再服务于业务，为业务进行数据和智能的赋能</strong>”</p><p>业务中台与数据中台相辅相成，互相支撑，互为输入输出。业务中台承载了企业的通用业务能力，为多业务线赋能；数据中台通过对于业务数据的二次加工，并反馈回业务中台，为业务进行数据和智能方面的赋能。两者的紧密配合一起为企业构建起了商业战场强大的后方炮火群，这也就构成了最著名的业务数据双中台模式。</p><h3 id="企业为什么要建中台？"><a href="#企业为什么要建中台？" class="headerlink" title="企业为什么要建中台？"></a>企业为什么要建中台？</h3><ul><li>中台化是平台化的下一站，是平台不断对于自身治理演进、打破技术边界、逐渐拥抱业务、容纳业务、具备更强的业务属性的过程。中台关注为前台业务赋能，真正为前台而生</li><li>企业在平台化的过程中，为了能不断地给前台业务提供更好的服务，来支撑企业对于用户的持续响应，增加企业的用户响应力，企业需要构建自己的中台。</li></ul><p>想要回答这个问题，咱得先解决另一个问题，那就是企业为什么需要平台化？</p><h4 id="企业为什么需要平台化呢？"><a href="#企业为什么需要平台化呢？" class="headerlink" title="企业为什么需要平台化呢？"></a>企业为什么需要平台化呢？</h4><p><strong>因为在当今这样一个互联网时代，用户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍。</strong></p><p>这背后的逻辑很简单，不断地快速响应、探索、挖掘、引领用户的需求，才是企业得以生存和持续发展的关键因素。</p><p>那些真正尊重用户，甚至不惜调整自己、颠覆自己来响应用户的企业，将在这场以用户为中心的商业战争中得以生存和发展。反之，那些在过去的成就上故步自封，存在侥幸心理希望用户会像之前一样继续追随自己的企业，则会被用户淘汰。</p><p>很残酷，但这就是这个时代最基本的的<strong>企业生存法则</strong>。</p><p>平台化之所以重要，就是因为在这场以用户为中心的现代商业战争中，它赋予或加强了企业最核心的能力：<strong>用户响应力</strong>。平台化思想（Platform Thinking）恰好鼓励企业不断抽象沉淀自己核心的底层能力，通过平台化包装，得以更好地赋能前台业务，用底层的确定性来帮助企业应对前台业务以及最终用户需求的不确定性。</p><ul><li>前台：由各类前台系统组成的前端业务平台。每个前台系统都是一个用户触点，大多是企业最终用户直接使用的系统，是企业与最终用户的交点。例如用户直接使用的网站、手机 App、微信公众号、小程序等都属于前台范畴。</li><li>后台/平台：由后台系统组成的后端支撑平台。每个后台系统一般管理了企业的一类核心资源（数据 + 计算），例如财务系统、产品系统、客户管理系统、仓库物流管理系统等，这类系统构成了企业的后台</li></ul><p><strong>总结：我们看到很多企业的后台，在创建之初的目标，并不是主要服务于前台系统的<code>业务创新</code>，而更多的是为了实现后端资源的<code>信息化管理</code>，解决企业管理的效率问题，可以这么说，大多数企业已有的后台，要么前台根本就用不了，要么不好用，要么变更速度就根本跟不上前台业务发展的节奏。总结下来就两个字“慢”和“贵”，对业务的响应慢，动不动改个小功能就要花费很多钱和时间</strong></p><h4 id="矛盾点"><a href="#矛盾点" class="headerlink" title="矛盾点"></a>矛盾点</h4><p><img src="http://lion-heart.online/blog/2021-03-07-085719.png" alt="image-20210307165714712"></p><p><img src="http://lion-heart.online/blog/2021-03-07-085806.png" alt="image-20210307165806678"></p><p><strong>总结：此时的前台和后台就像是两个不同转速的齿轮，前台由于要快速响应前端用户的需求，讲究的是快速迭代创新，所以要求转速越快越好；而后台由于面对的是相对稳定的企业核心后端资源，而且往往系统陈旧复杂，甚至还受到法律法规、审计等相关合规约束，一般是追求稳定至上，越稳定越好， 转速也自然是越慢越安全</strong></p><h4 id="中台诞生：解决矛盾"><a href="#中台诞生：解决矛盾" class="headerlink" title="中台诞生：解决矛盾"></a>中台诞生：解决矛盾</h4><p>它提供了比前台更强的稳定性，以及比后台更高的灵活性，在稳定与灵活之间寻找到了⼀种美妙的平衡</p><p>有了这层“中台”，我们既可以将早已臃肿不堪的前台系统中稳定通用的业务能力“沉降”到中台层，为前台减肥，恢复前台的响应力；又可以将后台系统中需要频繁变化或是需要被前台直接使用的业务能力“提取”到中台层，赋予这些业务能力更强的灵活度和更低的变更成本；或者干脆直接对于后台进行中台化改造，通过配置化、自助化、白屏化等形式为后台加速，从而为前台提供更强大、更迅捷、更易用的“能力炮火”支援。</p><p>中台就像是在前台与后台之间添加的⼀组“变速齿轮”，将前台与后台的速率进行匹配，是前台与后台的桥梁和润滑剂。它为前台而生，易于前台使用，将后台资源顺滑地通过前台导流向用户，支撑企业更好地响应用户。</p><h3 id="定义中台"><a href="#定义中台" class="headerlink" title="定义中台"></a>定义中台</h3><p><strong>企业级能力复用平台</strong></p><h5 id="1-企业级：定义中台范围"><a href="#1-企业级：定义中台范围" class="headerlink" title="1. 企业级：定义中台范围"></a>1. 企业级：定义中台范围</h5><p>企业级定义了中台的范围。不是说一个企业只能有一个中台，也不代表一个中台就是只能包含一家企业，企业级更多代表的是中台处理的问题在企业级别，即至少包含多条业务线或服务多个前台产品（团队），如果一个中台只为了支持一条业务线或产品线，那就不是中台，即使它用了服务化或是大数据等技术。</p><p>企业级这一点非常非常重要。它让我想清楚了，中台建设的事情并不是一个技术问题，而是一个要上升到企业架构的问题。做中台建设的时候，一定是跳出单条业务线、站在企业整体视角来审视业务全景。</p><p>从中台的兴起与爆发我们也能看到一个趋势，就是越来越多的企业，无论是想提升自身的运营效率，还是出于业务创新发展的需求，都已经把企业全局视角、跨业务线的能力沉淀，提到了前所未有的战略高度。</p><h5 id="2-能力：中台主要承载对象"><a href="#2-能力：中台主要承载对象" class="headerlink" title="2. 能力：中台主要承载对象"></a>2. 能力：中台主要承载对象</h5><p>提到中台，最常听到的一个词就是“能力”。可能是因为能力这个词足够简单，又有着足够的包容度与宽度。</p><p>能力定义了中台主要承载的对象。</p><p>能力的抽象，解释了为什么会有那么多种类中台的存在，也能解释为什么每家企业的中台都不一样，因为不同的企业之所以能够同时存在，就是因为其核心能力不同，可以满足用户不同层面的需求，也就是我们常说的差异化竞争力。</p><h5 id="3-复用：中台的核心价值"><a href="#3-复用：中台的核心价值" class="headerlink" title="3. 复用：中台的核心价值"></a>3. 复用：中台的核心价值</h5><p>复用定义了中台的核心价值，也承载了上面讲到的从平台化到中台化的演进过程。传统的平台化对于“可复用性”和“易复用性”并没有给予足够的关注，更多关注的是如何消除掉重复的能力建设，既所谓的“去重”。</p><p>但中台的提出和兴起，体现出一种对于前台业务的使用体验更加关注的趋势。让人们通过对于“可复用性”和“易复用性”的关注，将目光更多地从平台内部的建设转换到平台对于前台业务的支撑上。这里有一个从治理到赋能的视角转换，既从“去重”到“复用”的关注上。</p><p>“去重”与“复用”虽然经常一起出现，一起被提及，但是谈论的完全不是一件事情，目的不同，难度也不同。“去重”讲的更多是向后看，是技术驱动的；“复用”讲的更多是向前看，是业务驱动和用户驱动的。而正这个视角的转变，我认为是理解中台概念的关键，所以</p><ul><li>“复用”是中台更加关注的目标；</li><li>“可复用性”和“易复用性”是衡量中台建设好坏的重要指标；</li><li>“业务响应力”和“业务满意度”是考核中台建设进度的重要标准。</li></ul><p>这也能解释为什么很多互联网企业，将对于平台的治理，通过业务抽象以及可配置化和白屏化的改造升级，把这个过程称之为对于平台的中台化改造过程。</p><h5 id="4-平台"><a href="#4-平台" class="headerlink" title="4. 平台"></a><strong>4. 平台</strong></h5><p>平台定义了中台的主要形式。区别于传统应用系统拼凑的方式，中台通过对于更细粒度能力的识别与平台化沉淀，实现企业能力的柔性复用，更好地支撑前台业务，来满足对于业务的快速响应和复用的需求。</p><ul><li>“<strong>企业级</strong>”定义了中台的范围，区分开了单系统的服务化与微服务；</li><li>“<strong>能力</strong>”定义了中台的主要承载对象，能力的抽象解释了各种各样中台的存在；</li><li>“<strong>复用</strong>”定义了中台的核心价值，传统的平台化对于易复用性和前台的用户体验并没有给予足够的关注，中台的提出和兴起，让人们通过可复用性将目光更多的从平台内部设计转换到平台对于前台业务的支撑上；</li><li>“<strong>平台</strong>”定义了中台的主要形式，区别于传统的应用系统拼凑的方式，通过对于更细粒度能力的识别与平台化沉淀，实现企业能力的柔性复用，更好地支撑前台业务。</li></ul><h3 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a>总结思考</h3><p><strong>以用户为中心的持续规模化创新</strong>，是中台建设的核心目标。企业的用户响应能力和规模化创新能力，是互联网时代企业综合竞争力的核心体现。<strong>平台化包括中台化只是帮助企业达到这个目标的手段，并不是目标本身</strong></p><p>中台（⽆论是技术中台、业务中台还是组织中台）的建设，根本上是为了解决企业响应力困境， 弥补创新驱动需要快速变化的前台和稳定可靠驱动需要变化周期相对较慢的后台之间的矛盾，提供⼀个中间层来适配前台与后台的配速问题，打通并顺滑链接前台需求与后台资源，帮助企业从整体上不断提升用户响应力。</p><p>所以，中台到底是什么根本不重要，如何想方设法持续提高企业对于用户的响应力才是最重要的。而平台化或是中台化，只是恰巧走在了这条正确的大道上。</p><p>最后我们给中台下了一个定义，既“<strong>企业级能力复用平台</strong>”。有了这个定义后，我们不仅可以把它当作一把尺子来丈量一个中台是否货真价实，对于如何建中台的思路也能豁然开朗</p><p>因为如果说“中台就是企业级能力复用平台”的话，那“中台化”也就是“<strong>利用平台化的思维和手段梳理、识别、沉淀与复用企业级核心能力的过程</strong>”</p><h2 id="中台建设前必须想清楚的四个问题"><a href="#中台建设前必须想清楚的四个问题" class="headerlink" title="中台建设前必须想清楚的四个问题"></a>中台建设前必须想清楚的四个问题</h2><h3 id="中台建设的愿景是什么？"><a href="#中台建设的愿景是什么？" class="headerlink" title="中台建设的愿景是什么？"></a><strong>中台建设的愿景是什么？</strong></h3><p>“遇事不决看愿景”，这是我在做中台规划和落地过程中，说得最多的一句话。</p><p>太多时候我们把解决方案和问题本身混为一谈。中台只是一个解决方案而已，但是很多时候我看到人们却把中台当成了问题本身，纠结于别人的中台都是什么样子，自己的中台该是个什么样子，而不是关注中台到底有没有解决该解决的问题，甚至希望中台解决什么问题还没有想清楚。</p><p>所以我经常被问到的也是，中台应该什么样？中台应该怎么建？而我一般会先反问一句：你建中台是为了解决什么问题呢？对于企业和业务又有什么价值？很多情况下，对方并不能清晰直接地回答，或是说了一堆像消除烟囱，移除孤岛等“大话”。在我看来，这就是还没有搞清楚中台建设的愿景。</p><p>中台就像一个产品一样，需要一个明确的愿景，要让所有人能够清晰明确地知道，中台建设对于企业对于业务的价值，从而可以一起始终向着同一个方向持续前进。如果愿景缺失，那我们就会很容易在中台建设过程中迷失自己的方向，失去定力。</p><p>愿景帮助我们了解自己中台建设的目标，帮助我们判断哪些事情是符合中台建设愿景的，作为中台团队我们需要去考虑。在这之外，更重要的是帮我们判断哪些事情不是中台要去做的，为中台做减法，这点在中台的建设过程中其实更加重要。</p><p>尤其是在中台建设初期，项目往往还处于试点的阶段，可支配的人员和资源不会特别多，如果没有自己的方向，就会陷入到上面小王所处的境地，把中台变成一个内部共享的外包团队。</p><p><strong>所以在建设中台前，第一个要问自己的就是：我们建设中台，愿景是什么？而且更重要的是这个愿景是需要所有的角色，上到企业管理层，下到每一位中台的相关人员都要明确并达成一致的。</strong></p><p>具体怎么做到呢？我们在实际的实施过程中，会有一些工具和实践，我会在后面讲中台设计的课程中再给你展开分享。</p><h3 id="中台的用户和客户是谁？"><a href="#中台的用户和客户是谁？" class="headerlink" title="中台的用户和客户是谁？"></a><strong>中台的用户和客户是谁？</strong></h3><p>这个问题也同样非常关键，因为中台是企业级的事情，必然会面对组织的问题以及庞杂的干系人问题。</p><p>再说得直白一些，就是中台的建设通常都会伴随企业内的组织重构以及利益和职责的再分配。如果没有搞清楚中台建设的各个干系方关系，必然在中台的建设过程中就会四面碰壁，陷入“干系人旋涡”之中，面临多方面的阻力，陷入一个非常被动的局面。</p><p>所以在中台建设之前，我们最好先搞清楚中台如果作为一款产品，它的用户是谁？客户又是谁？用户和客户是一个群体么？除了用户和客户还有哪些干系方？他们对于中台都有什么期望，这些期望又是否一致呢？</p><p>为了想清楚这个问题，我们可以把企业想象成一个家庭，具体到某一条业务线就像是家庭里的一个孩子，他关注的更多是我今天能不能多玩一会儿，也就是我们常说的短期的战术目标，回到企业里就是我这条业务线今年甚至这个月的 KPI 目标能否实现。</p><p>而企业管理层就像这个家庭的家长，他关注更多的是孩子的未来，高考的时候能不能多拼过几万个别人家的孩子，实现可持续发展，也就是我们常说的长期战略目标，关注的是未来五年，十年甚至是更长的时间企业会是什么样子。</p><p>而中台此时就像是一款 K12 的英语教育产品一样，那你思考一下，如果你是这款产品的产品经理，你会更关注谁呢？是作为产品实际用户的孩子的短期战术目标，让他玩得爽，甚至跟游戏一样？还是产品实际买单的人，也就是作为产品客户的家长的长期战略目标，甚至为了达到最好的效果，不惜牺牲孩子的用户体验？</p><p>这个例子里，根本的问题在于长期战略目标和短期战术目标的矛盾。答案其实也很简单：都要关注。我们需要找到企业管理层与业务线关注点的结合点，也就是长期战略价值和短期战术价值的结合点。</p><p>而且对于中台来讲，情况可能比上面提到的更复杂，他的干系方还不止是用户和客户这两方，因为其所处的特殊位置，干系方往往纷繁复杂。在保持自己方向的前提下，找到各方利益的结合点，是一件非常困难且有必要的事情。否则，在建设过程中就会受到各方的阻力，产生摩擦，导致中台很难推进落地。</p><p>但反过来讲，中台也不应该只是极力去满足各方的诉求，中台团队毕竟不是业务的外包团队。中台需要有自己的思想和规划，要能做到听得进别人的话，但是还要明确自己的目标，走自己的路。而自己的目标，就是来源于上面提到的中台建设愿景，而中台的愿景也往往来源于企业的战略需要。</p><p>所以，我常说，<strong>中台建设虽然需要兼顾各方的利益，但更多主要还是解决企业管理层对于公司长期生存与可持续发展的恐惧与焦虑问题</strong></p><p><img src="http://lion-heart.online/blog/2021-03-07-142541.png" alt="image-20210307222532281"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>日常问题处理</title>
      <link href="/2021/02/28/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"/>
      <url>/2021/02/28/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="日常问题处理"><a href="#日常问题处理" class="headerlink" title="日常问题处理"></a>日常问题处理</h3><h3 id="一、brew-问题处理"><a href="#一、brew-问题处理" class="headerlink" title="一、brew 问题处理"></a>一、brew 问题处理</h3><p><a href="https://www.zhihu.com/question/35928898/answer/1102381049" target="_blank" rel="noopener">https://www.zhihu.com/question/35928898/answer/1102381049</a></p><h3 id="二、hexo-d-问题"><a href="#二、hexo-d-问题" class="headerlink" title="二、hexo d 问题"></a>二、hexo d 问题</h3><ul><li><p>卸载高版本 nodejs</p><ul><li>brew uninstall node <ul><li>如果 node -v 或 npm -v 还是展示版本号，证明没有卸载干净</li><li>通过命令  find ~ -name “node” 或 find /usr/local -name ‘node*’ 查看<ul><li>删除所有node相关的文件夹和文件以及可执行文件</li><li>node -v 或 npm -v 无版本号，即删除干净</li></ul></li></ul></li></ul></li><li><p>安装低版本nodejs</p><ul><li><p>通过 brew 查找相应版本</p><ul><li><p>brew search node</p><p>brew install node@12 即可</p></li><li><p>链接安装版本 brew link node@xxx</p></li><li><p>添加环境变量</p><ul><li>vim ~/.zshrc</li><li>export PATH=”/usr/local/opt/node@12/bin:$PATH”</li></ul></li><li><p>安装   sudo npm install hexo-cli -g 插件</p></li></ul></li></ul></li><li><p>重新 hexo d 成功</p></li></ul><h3 id="三、安装指定版本的-node"><a href="#三、安装指定版本的-node" class="headerlink" title="三、安装指定版本的 node"></a>三、安装指定版本的 node</h3><p><a href="https://zhuanlan.zhihu.com/p/108858395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108858395</a></p><h3 id="四、hexo-g-问题"><a href="#四、hexo-g-问题" class="headerlink" title="四、hexo g 问题"></a>四、hexo g 问题</h3><p><a href="https://blog.csdn.net/htl2018/article/details/106876940" target="_blank" rel="noopener">https://blog.csdn.net/htl2018/article/details/106876940</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2021/02/09/MySQL/"/>
      <url>/2021/02/09/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="一、必备基础"><a href="#一、必备基础" class="headerlink" title="一、必备基础"></a>一、必备基础</h2><h3 id="一、官网、文档"><a href="#一、官网、文档" class="headerlink" title="一、官网、文档"></a>一、官网、文档</h3><p><a href="https://www.mysql.com" target="_blank" rel="noopener">https://www.mysql.com</a></p><h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="版本及历史"><a href="#版本及历史" class="headerlink" title="版本及历史"></a>版本及历史</h4><p><strong>96年发布第一个版本</strong></p><p>2000年开源。MyISAM引擎正式提供服务</p><p><strong>01年发布4.0整合了InnoDB引擎</strong></p><p>05年发布5.0，加入了游标、存储过程和触发器的支持</p><p>08年被sun收购</p><p>09年sun被oracle收购</p><p>10年发布5.5。划分为<strong>社区版和企业版</strong>。默认引擎更换为<strong>InnoDB</strong>、增加表分区</p><p>15年5.7.9GA版</p><p><strong>18年8.0.11GA版</strong></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>参考官网提供流程</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>Mac：</p><p>Linux：</p><p>Windows：</p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h3 id="约束解释"><a href="#约束解释" class="headerlink" title="约束解释"></a>约束解释</h3><h3 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h3><h4 id="架构原理及存储机制"><a href="#架构原理及存储机制" class="headerlink" title="架构原理及存储机制"></a>架构原理及存储机制</h4><h5 id="1-体系结构"><a href="#1-体系结构" class="headerlink" title="1.体系结构"></a>1.体系结构</h5><h5 id="2-SQL-运行机制"><a href="#2-SQL-运行机制" class="headerlink" title="2.SQL 运行机制"></a>2.SQL 运行机制</h5><h5 id="3-存储引擎"><a href="#3-存储引擎" class="headerlink" title="3.存储引擎"></a>3.存储引擎</h5><h4 id="索引存储机制和工作原理"><a href="#索引存储机制和工作原理" class="headerlink" title="索引存储机制和工作原理"></a>索引存储机制和工作原理</h4><p>1.索引存储结构</p><p>2.索引查询原理</p><p>3.索引分析和优化</p><p>4.查询优化</p><h4 id="事务和锁工作原理"><a href="#事务和锁工作原理" class="headerlink" title="事务和锁工作原理"></a>事务和锁工作原理</h4><p>1.事务隔离级别</p><p>2.事务并发处理</p><p>3.锁机制</p><h4 id="集群架构及原理"><a href="#集群架构及原理" class="headerlink" title="集群架构及原理"></a>集群架构及原理</h4><h5 id="1-集群架构设计理念"><a href="#1-集群架构设计理念" class="headerlink" title="1.集群架构设计理念"></a>1.集群架构设计理念</h5><h5 id="2-主从架构"><a href="#2-主从架构" class="headerlink" title="2.主从架构"></a>2.主从架构</h5><h5 id="3-集群架构"><a href="#3-集群架构" class="headerlink" title="3.集群架构"></a>3.集群架构</h5><h5 id="4-分库分表"><a href="#4-分库分表" class="headerlink" title="4.分库分表"></a>4.分库分表</h5><h4 id="海量数据处理方法"><a href="#海量数据处理方法" class="headerlink" title="海量数据处理方法"></a>海量数据处理方法</h4><p>1.SharingShere</p><p>2.MyCat 中间件实战</p><p>3.分库分表实战</p><h2 id="前提概念"><a href="#前提概念" class="headerlink" title="前提概念"></a>前提概念</h2><p>用户请求 -》 应用层 -〉服务层 -》<strong>存储层</strong></p><h2 id="架构演变"><a href="#架构演变" class="headerlink" title="架构演变"></a>架构演变</h2><p>单机单库</p><p>主从架构</p><p>分库分表</p><p>云数据库</p><h2 id="二、服务架构"><a href="#二、服务架构" class="headerlink" title="二、服务架构"></a>二、服务架构</h2><p><img src="http://lion-heart.online/blog/2021-02-10-091700.png" alt="image-20210210171655336"></p><ol><li>客户端 - 网络连接层</li><li>Server 进程 - 服务层<ul><li>连接器：管理连接<ul><li>连接池：线程重用</li></ul></li><li>SQL 接口：接收客户端发来的SQL命令，并返回用户需要查询的结果。DDL、DML等语句</li><li>解析、分析器：词法分析、语法分析<ul><li>将请求的SQL解析生成一个 “解析树”。然后根据规则进行语法检查</li></ul></li><li>优化器：优化 SQL，转化为执行计划，然后与存储引擎进行交互。sql有多种执行方式，但是返回的结果都是相同的。多种执行方式获取效率最高的方式<ul><li>RBO</li><li>CBO</li></ul></li><li>执行器：执行组件</li></ul></li><li>存储引擎：不同的存放位置，不同的文件格式(针对表结构) - 存储引擎层<ul><li>MyISAM：基于磁盘存储，不支持事物和外键，访问速度快</li><li>InnoDB：基于磁盘存储，支持事物，具有提交、回滚、崩溃回复能力。事务安全</li><li>Memory：基于内存存储，利用内存创建表，访问速度非常快，使用hash索引</li></ul></li><li>系统文件层：系统文件、日志文件、配置文件、pid文件、socket文件<ul><li>日志文件<ul><li>二进制日志</li><li>慢查询日志</li><li>通用查询日志</li><li>错误日志：默认开启</li></ul></li><li>数据文件<ul><li>db.opt：记录库的默认字符集和校验规则</li><li>frm：存储与表相关的元数据，包括表结构定义信息</li><li>MYD：MyISAM引擎，表数据</li><li>MYI：MyISAM引擎，索引相关信息</li><li>ibd：存储InnoDB的数据文件（包含索引）</li><li>ibdata1：Undo日志</li><li>ib_logfile1：Redo日志</li></ul></li></ul></li></ol><h3 id="2-1-InnoDB-和-MyISAM-对比"><a href="#2-1-InnoDB-和-MyISAM-对比" class="headerlink" title="2.1 InnoDB 和 MyISAM 对比"></a>2.1 InnoDB 和 MyISAM 对比</h3><ul><li>事务和外键<ul><li>InnoDB 支持事物和外键，具有安全性和完整性，适合大量 insert 和 update 操作</li><li>MyISAM 不支持事物和外键，提供高速存储和检索，适合大量的 select 操作</li></ul></li><li>锁机制<ul><li>InnoDB 支持行级锁，锁定指定记录</li><li>MyISAM 支持表级锁，锁定的表</li></ul></li><li>索引结构<ul><li>InnoDB 使用聚集索引，索引和记录一起存储</li><li>MyISAM 使用非聚集索引，索引和记录分开存储</li></ul></li><li>并发处理能力<ul><li>InnoDB 使用行锁，写操作一定加锁，读操作与隔离级别有关，可以采用 MVCC 来支持高并发</li><li>MyISAM 使用表锁，导致写操作并发率低，读之间不阻塞</li></ul></li><li>存储文件<ul><li>InnoDB 表对应两个文件，一个.frm表结构文件，一个.ibd数据文件</li><li>MyISAM 表对应三个文件，一个.frm表结构文件，一个MYD数据文件，一个MYI索引文件</li></ul></li></ul><h5 id="总结：是否需要事物？是否存在并发修改？是否需要快速查询？"><a href="#总结：是否需要事物？是否存在并发修改？是否需要快速查询？" class="headerlink" title="总结：是否需要事物？是否存在并发修改？是否需要快速查询？"></a>总结：是否需要事物？是否存在并发修改？是否需要快速查询？</h5><h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><h3 id="3-1-增删改操作时背后对应的原理"><a href="#3-1-增删改操作时背后对应的原理" class="headerlink" title="3.1 增删改操作时背后对应的原理"></a>3.1 增删改操作时背后对应的原理</h3><p><img src="http://lion-heart.online/blog/2021-02-10-095048.png" alt="image-20210210175045638"></p><ul><li>1⃣️ 建立连接：客户端和服务<strong>端通信方式</strong>是 “半双工”，对于每一个MySQL连接，时刻都有一个<strong>线程来存储连接信息</strong><ul><li>核心1：通讯机制<ul><li>单工：只能发送数据或只能接收数据。例如：单行道</li><li>全双工：能同时收发数据。例如：接听电话</li><li>半双工：某一时刻，要么发送数据，要么接收数据，不能同时执行。例如：电梯</li></ul></li><li>核心2：线程状态<ul><li>show processlist：查看用户正在运行的线程信息</li><li><img src="http://lion-heart.online/blog/2021-02-10-100911.png" alt="show processlist 命令"></li><li>id：线程id</li><li>User：启动线程的用户</li><li>Host：发送请求的客户端信息</li><li>db：当前命令在那个库执行</li><li>command：该线程正在执行的操作命令</li><li>TIme：该线程处于当前状态的时间，单位秒</li></ul></li></ul></li><li>2⃣️ 缓存：缓存的<strong>SQL语句</strong>和<strong>查询结果</strong><ul><li>即使开启查询缓存，以下情况也不能缓存<ul><li>查询语句使用 SQL_NO_CACHE</li><li>查询结果大于 query_cache_limit 设置</li><li>查询中有一些不确定的参数，例如：now()</li></ul></li></ul></li><li>3⃣️ 解析器：解析SQL，检查语法、表、字段是否合法，根据名字和别名生成新的解析树</li><li>4⃣️ 优化器：根据解析树生成最优的执行计划。</li></ul><h3 id="3-2-InnoDB-存储结构：主要分为-内存结构和磁盘结构两部分"><a href="#3-2-InnoDB-存储结构：主要分为-内存结构和磁盘结构两部分" class="headerlink" title="3.2 InnoDB 存储结构：主要分为 内存结构和磁盘结构两部分"></a>3.2 InnoDB 存储结构：主要分为 内存结构和磁盘结构两部分</h3><p><img src="http://lion-heart.online/blog/2021-02-11-100157.png" alt="InnoDB引擎架构图"></p><h4 id="3-2-1-内存结构组成"><a href="#3-2-1-内存结构组成" class="headerlink" title="3.2.1 内存结构组成"></a>3.2.1 内存结构组成</h4><ul><li>Buffer Pool：缓冲池</li><li>Change Buffer</li><li>Log Buffer</li><li>Adaptive Hash Index </li></ul><h5 id="3-2-1-1-Buffer-Pool-原理"><a href="#3-2-1-1-Buffer-Pool-原理" class="headerlink" title="3.2.1.1 Buffer Pool 原理"></a>3.2.1.1 Buffer Pool 原理</h5><ul><li><p>概述</p><ul><li>Buffer Pool就是数据库的一个<strong>内存组件</strong>，具有<strong>完整的数据结构</strong>，里面缓存了磁盘上的<strong>真实数据</strong>，增删改操作首先就是针对这个内存中的Buffer Pool里的数据执行的，同时配合了后续的redo log、刷磁盘等机制和操作</li></ul></li><li><p>组成</p><ul><li><p>Page：MySQL中抽象出来的数据单位</p><p>实际上MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据</p></li></ul></li><li><p>Page 管理机制：默认大小 16K</p><ul><li>状态管理<ul><li>free page：空闲 page，未被使用</li><li>clean page：已使用 page，数据未被修改过</li><li>dirty page：已使用 page，数据被修改过，内存和磁盘里的数据产生不一致情况</li></ul></li><li>结构管理<ul><li>free list：表示空闲缓冲区，管理 free page</li><li>flush list：需要刷新到磁盘的缓冲区，管理 dirty page，内部page安修改时间排序。</li><li>lru list：表示正在使用的缓冲区，管理 clean page 和 dirty page，缓冲区 midpoint 为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后面的链表称为old列表区，存放使用较少的数据，占37%。</li></ul></li><li>内存淘汰算法<ul><li>普通 LRU：末尾淘汰法，新数据从头部加入，尾部删除</li><li>改进 LRU：链表分为 new 和 old 两部分，新数据从 midpoint 加入，数据很快被访问，那么page会向new空间移动，反之会向old空间移动。淘汰原则不变，尾部淘汰</li></ul></li></ul></li><li><p>参数配置</p><ul><li>实例  -  块  - page</li><li>show variables like ‘%innodb_buffer%’;</li><li>show variables like ‘%innodb_page_size%’;</li></ul></li></ul><h5 id="3-2-1-2-Change-Buffer-原理"><a href="#3-2-1-2-Change-Buffer-原理" class="headerlink" title="3.2.1.2 Change Buffer 原理"></a>3.2.1.2 Change Buffer 原理</h5><ul><li>概述<ul><li>写缓冲区，进行DML操作时，如果BP没有其相应的Page数据，并不会立刻将磁盘页加载到BP，而是在CB记录缓冲变更，等未来数据被读取时，再将数据合并回到BP中。</li><li>占用BP空间，默认25%，最大允许调整到50%</li></ul></li><li>核心处理流程<ul><li>更新操作<ul><li>记录存在BP，直接在BP修改，一次内存操作</li><li>记录不存在BP，直接在CB进行一次内存操作，不用去磁盘查询数据，避免一次IO</li></ul></li></ul></li><li>注意事项<ul><li>CB 仅适用非唯一普通索引页</li><li>如果在索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。会直接将记录查询到BP，然后在BP中修改</li></ul></li></ul><h5 id="3-2-1-3-LogBuffer-原理"><a href="#3-2-1-3-LogBuffer-原理" class="headerlink" title="3.2.1.3 LogBuffer 原理"></a>3.2.1.3 LogBuffer 原理</h5><ul><li>概述<ul><li>日志缓冲区，记录InnoDB引擎日志，DML操作时产生Redo、Undo日志，LB 空间满了，会自动写入磁盘或定期刷新到磁盘log文件。</li></ul></li><li>核心处理流程</li><li>注意事项<ul><li>写文件：memory 写到 OS cache</li><li>刷盘：OS cache 写到 disk file</li></ul></li><li>参数设置<ul><li>Innodb_flush_log_at_trx_commit<ul><li>0：每隔1s，写日志文件，刷盘 - 异步</li><li>1：事务提交，同步写日志文件，同步刷盘 - 同步</li><li>2：事务提交，同步写日志文件，每隔1s刷盘 - 异步</li></ul></li></ul></li></ul><h4 id="3-2-2-磁盘结构组成"><a href="#3-2-2-磁盘结构组成" class="headerlink" title="3.2.2 磁盘结构组成"></a>3.2.2 磁盘结构组成</h4><ul><li>System Tablespace：共享表空间，存放的是表和索引信息<ul><li>Data Dictionary</li><li>Doublerwrite Buffer：BP里的脏页先写到这里，目的是提高写入速度，同时保证数据安全性防止异常情况数据丢失</li><li>Change Buffer</li><li>Undo Logs：备份没有刷盘的日志，用于例外情况下，撤销、回滚数据</li></ul></li><li><strong>独立 Tablespace：参数控制，默认采用</strong></li><li>General Tablespace</li><li>Temp Tablespace </li><li>Undo Tablespace：undo 日志文件构成<ul><li>undo log1：撤消日志是在事务开始之前保存的被修改数据的备份，用于例外情况时回滚事务。撤消日志属于逻辑日志，根据每行记录进行记录。撤消日志存在于系统表空间、撤消表空间和临时表空间中。</li><li>undo log2</li><li>undo logn</li></ul></li><li>Redo Log：重做日志是一种基于磁盘的数据结构，用于在崩溃恢复期间更正不完整事务写入的数据。MySQL以循环方式写入重做日志文件，记录InnoDB中所有对Buffer Pool修改的日志。当出现实例故障（像断电），导致数据未能更新到数据文件，则数据库重启时须redo，重新把数据更新到数据文件。读写事务在执行的过程中，都会不断的产生redo log。默认情况下，重做日志在磁盘上由两个名为ib_logfifile0和ib_logfifile1的文件物理表示。</li></ul><h5 id="3-2-2-1-SystemTablespace"><a href="#3-2-2-1-SystemTablespace" class="headerlink" title="3.2.2.1 SystemTablespace"></a>3.2.2.1 SystemTablespace</h5><h3 id="3-3-InnoDB-线程模型"><a href="#3-3-InnoDB-线程模型" class="headerlink" title="3.3 InnoDB 线程模型"></a>3.3 InnoDB 线程模型</h3><p><img src="http://lion-heart.online/blog/2021-02-13-070707.png" alt="image-20210213150704664"></p><h4 id="3-3-1-Master-Thread：调度其他三类线程"><a href="#3-3-1-Master-Thread：调度其他三类线程" class="headerlink" title="3.3.1 Master Thread：调度其他三类线程"></a>3.3.1 Master Thread：调度其他三类线程</h4><p>Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高。作用是将缓冲池中的数</p><p>据异步刷新到磁盘 ，保证数据的一致性。包含：</p><ul><li>脏页的刷新（page cleaner thread）</li><li>undo页回收（purge thread）</li><li>redo日志刷新（log thread）</li><li>合并写缓冲</li></ul><p>内部有两个主处理，分别</p><ul><li><p>每隔1秒</p><ul><li><p>刷新日志缓冲区，刷到磁盘</p></li><li><p>合并写缓冲区数据，根据IO读写压力来决定是否操作</p></li><li><p>刷新脏页数据到磁盘，根据脏页比例达到75%才操作（innodb_max_dirty_pages_pct：控制脏页占比触发刷盘，</p><p>innodb_io_capacity：控制每次刷新页的数量） </p></li></ul></li><li><p>10秒处理</p><ul><li>刷新脏页数据到磁盘</li><li>合并写缓冲区数据</li><li>刷新日志缓冲区</li><li>删除无用的undo页</li></ul></li></ul><h4 id="3-3-2-IO-Thread"><a href="#3-3-2-IO-Thread" class="headerlink" title="3.3.2 IO Thread"></a>3.3.2 IO Thread</h4><p>在InnoDB中使用了大量的AIO（Async IO）来做读写处理，这样可以极大提高数据库的性能。在</p><p>InnoDB1.0版本之前共有4个IO Thread，分别是write，read，insert buffer和log thread，后来</p><p>版本将read thread和write thread分别增大到了4个，一共有10个了。</p><ul><li>read thread ：负责读取操作，将数据从磁盘加载到缓存page页</li><li>write thread：负责写操作，将BP的脏页刷新到磁盘</li><li>log thread：负责将LB内容刷新到磁盘</li><li>insert buffer thread：负责将CB内容刷新到磁盘</li></ul><h4 id="3-3-3-Purge-Thread"><a href="#3-3-3-Purge-Thread" class="headerlink" title="3.3.3 Purge Thread"></a>3.3.3 Purge Thread</h4><p>事务提交之后，其使用的undo日志将不再需要，因此需要Purge Thread回收已经分配的undo</p><p>页。</p><p>show variables like ‘%innodb_purge_threads%’;</p><h4 id="3-3-4-Page-Cleaner-Thread"><a href="#3-3-4-Page-Cleaner-Thread" class="headerlink" title="3.3.4 Page Cleaner Thread"></a>3.3.4 Page Cleaner Thread</h4><p>作用是将脏数据刷新到磁盘，脏数据刷盘后相应的redo log也就可以覆盖，即可以同步数据，又能</p><p>达到redo log循环使用的目的。会调用write thread线程处理。</p><p>show variables like ‘%innodb_page_cleaners%’;</p><h3 id="3-4-InnoDB-数据文件"><a href="#3-4-InnoDB-数据文件" class="headerlink" title="3.4 InnoDB 数据文件"></a>3.4 InnoDB 数据文件</h3><h4 id="一、存储结构"><a href="#一、存储结构" class="headerlink" title="一、存储结构"></a>一、存储结构</h4><p><img src="http://lion-heart.online/blog/2021-02-13-074855.png" alt="image-20210213154851683"></p><p>InnoDB数据文件存储结构：一个ibd数据文件–&gt;Segment（段）–&gt;Extent（区）–&gt;Page（页）–&gt;Row（行）</p><ul><li><p>Tablesapce</p><ul><li>表空间，用于存储多个ibd数据文件，用于存储表的记录和索引。一个文件包含多个段。</li></ul></li><li><p>Segment</p><ul><li>段，用于管理多个Extents，一个表至少会有两个segment，一个管理数据，一个管理索引。每多创建一个索引，会多两个segment。<ul><li>分为数据段（Leaf node segment）</li><li>索引段（Non-leaf nodesegment）</li><li>回滚段（Rollback segment）</li></ul></li></ul></li><li><p>Extent</p><ul><li>区，一个区固定包含64个连续的页，大小为1M。当表空间不足，需要分配新的页资源，不会一页一页分，直接分配一个区。</li></ul></li><li><p>Page</p><ul><li>页，用于存储多个Row行记录，大小为16K。包含很多种页类型，比如数据页，undo页，系统页，事务数据页，大的BLOB对象页。</li></ul></li><li><p>Row</p><ul><li>行，包含了记录的字段值，事务ID（Trx id）、滚动指针（Roll pointer）、字段指针（Field pointers）等信息</li></ul></li></ul><h4 id="二、文件格式"><a href="#二、文件格式" class="headerlink" title="二、文件格式"></a>二、文件格式</h4><p>在早期的InnoDB版本中，文件格式只有一种，随着InnoDB引擎的发展，出现了新文件格式，用于</p><p>支持新的功能。目前InnoDB只支持两种文件格式</p><ul><li><p>Antelope: 先前未命名的，最原始的InnoDB文件格式，它支持两种行格式：COMPACT和REDUNDANT，MySQL 5.6及其以前版本默认格式为Antelope。</p></li><li><p>Barracuda: 新的文件格式。它支持InnoDB的所有行格式，包括新的行格式：COMPRESSED和 DYNAMIC。</p></li></ul><p>通过innodb_fifile_format 配置参数可以设置InnoDB文件格式，之前默认值为Antelope，5.7版本</p><p>开始改为Barracuda。</p><h4 id="三、Undo-Log：撤销、回滚日志"><a href="#三、Undo-Log：撤销、回滚日志" class="headerlink" title="三、Undo Log：撤销、回滚日志"></a>三、Undo Log：撤销、回滚日志</h4><h5 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h5><ul><li><p>逻辑日志：记录的是数据变化的过程</p></li><li><p>数据库事务开始前，会将DML操作前的记录状态的记录存放到Undo Log日志里，当事物回滚或数据库崩溃时，可以利用Undo Log日志，撤销未提交事物对数据库产生的影响</p></li><li><p>Undo Log产生：DML事务操作开始前产生</p></li><li><p>Undo Log销毁：事务提交时，并不会立刻删除Undo Log，innodb会将该事务对应的Undo Log放入到删除列表中，后面会通过后台线程 purge thread 进行回收</p></li><li><p>Undo Log存储：采用 Segment 方式管理和记录，</p></li></ul><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><ul><li>实现事物的原子性</li><li>实现多版本并发控制 MVCC<ul><li><img src="http://lion-heart.online/blog/2021-02-13-085501.png" alt="image-20210213165457349"></li></ul></li></ul><h4 id="四、Redo-Log-和-Binlog"><a href="#四、Redo-Log-和-Binlog" class="headerlink" title="四、Redo Log 和 Binlog"></a>四、Redo Log 和 Binlog</h4><p>Redo Log和Binlog是MySQL日志系统中非常重要的两种机制，也有很多相似之处</p><h5 id="4-1-Redo-Log：重做、恢复日志"><a href="#4-1-Redo-Log：重做、恢复日志" class="headerlink" title="4.1 Redo Log：重做、恢复日志"></a>4.1 Redo Log：重做、恢复日志</h5><p>4.1.2 介绍</p><ul><li>物理日志：记录数据页更新状态内容</li><li>数据库事务操作中修改的任何数据，将最新的数据备份存储的位置，被称为重做日志</li><li>Redo Log 产生：DML事务执行过程中产生，事务提交时会将Redo Log写入LB，并不是随着事务提交立即写入磁盘文件。</li><li>Redo Log 销毁：等事务操作的脏页写入磁盘文件后，Redo Log 占用的空间就可以重用</li></ul><p>4.1.2 工作原理</p><ul><li>实现事务的持久性</li><li>防止在发生故障的时间点，尚有脏页未写入表的 IBD 文件中，在重启 MySQL 服务的时候，根据 Redo Log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性</li><li><img src="http://lion-heart.online/blog/2021-02-13-100950.png" alt="随机IO和顺序IO效率问题"></li></ul><p>4.1.3 写入机制</p><ul><li><p><img src="http://lion-heart.online/blog/2021-02-13-102556.png" alt="image-20210213182552104"></p></li><li><p><img src="http://lion-heart.online/blog/2021-02-13-102524.png" alt="MTR 事务单元，2pc过程"></p></li></ul><h5 id="4-2-Binlog"><a href="#4-2-Binlog" class="headerlink" title="4.2 Binlog"></a>4.2 Binlog</h5><p><img src="http://lion-heart.online/blog/2021-02-13-113212.png" alt="image-20210213193207693"></p><h4 id="五、Redo-Log-和-Undo-Log-区别"><a href="#五、Redo-Log-和-Undo-Log-区别" class="headerlink" title="五、Redo Log 和 Undo Log 区别"></a>五、Redo Log 和 Undo Log 区别</h4><ul><li><p>Redo Log属于物理日志，记录该数据页更新状态内容，Undo Log是逻辑日志，记录的是数据变化的过程</p></li><li><p>Redo Log 和 Undo Log 产生和销毁的节点完全不同</p></li><li><p>Redo Log 用于实现事务的持久性，Undo Log 用于实现事务的原子性</p></li></ul><h4 id="六、RedoLog和Binlog区别"><a href="#六、RedoLog和Binlog区别" class="headerlink" title="六、RedoLog和Binlog区别"></a>六、RedoLog和Binlog区别</h4><ul><li><p>Redo Log是属于InnoDB引擎功能，Binlog是属于MySQL Server自带功能，适配各种引擎，并且是以二进制文件记录。</p></li><li><p>Redo Log属于物理日志，记录该数据页更新状态内容，Binlog是逻辑日志，记录更新过程。</p></li><li><p>Redo Log日志是循环写，日志空间大小是固定，Binlog是追加写入，写完一个写下一个，不会覆盖使用。</p></li><li><p>Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力。</p></li></ul><h3 id="3-5-索引"><a href="#3-5-索引" class="headerlink" title="3.5 索引"></a>3.5 索引</h3><p>索引可以提升查询速度，会影响where查询，以及order by排序。MySQL索引类型如下：</p><ul><li><p>从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT全文索引、R Tree索引</p></li><li><p>从应用层次划分：普通索引、唯一索引、主键索引、复合索引</p></li><li><p>从索引键值类型划分：主键索引、辅助索引（二级索引）</p></li><li><p>从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引）、非聚集索引（非聚簇索引</p></li></ul><h4 id="3-5-1-索引分类"><a href="#3-5-1-索引分类" class="headerlink" title="3.5.1 索引分类"></a>3.5.1 索引分类</h4><h5 id="1-普通索引"><a href="#1-普通索引" class="headerlink" title="1.普通索引"></a>1.普通索引</h5><p>非主键字段都可以创建。</p><h5 id="2-唯一索引"><a href="#2-唯一索引" class="headerlink" title="2.唯一索引"></a>2.唯一索引</h5><p>普通索引基础上，添加索引字段值必须唯一限制，允许有空值</p><h5 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h5><p>一种特殊的唯一索引，不允许有空值，每个表只能有一个主键索引</p><h5 id="4-复合索引"><a href="#4-复合索引" class="headerlink" title="4.复合索引"></a>4.复合索引</h5><p>多字段建立索引为复合/联合索引</p><h5 id="5-全文索引"><a href="#5-全文索引" class="headerlink" title="5.全文索引"></a>5.全文索引</h5><h4 id="3-5-2-索引原理"><a href="#3-5-2-索引原理" class="headerlink" title="3.5.2 索引原理"></a>3.5.2 索引原理</h4><p>索引是什么？官网定义为：是存储引擎用于快速查找记录的一种数据结构。需要额外开辟空间和数据维护工作。</p><ul><li>索引是物理数据页存储，在数据文件中(InnoDB - ibd文件)，利用数据页存储</li><li>索引可以加快检索速度，但是同时也会降低DML操作速度，索引维护需要代价</li></ul><h5 id="1-二分查找：用于有序、等值检索"><a href="#1-二分查找：用于有序、等值检索" class="headerlink" title="1.二分查找：用于有序、等值检索"></a>1.二分查找：用于有序、等值检索</h5><h5 id="2-Hash结构：用于等值检索"><a href="#2-Hash结构：用于等值检索" class="headerlink" title="2.Hash结构：用于等值检索"></a>2.Hash结构：用于等值检索</h5><h5 id="3-树结构"><a href="#3-树结构" class="headerlink" title="3.树结构"></a>3.树结构</h5><p>3.1 B Tree</p><p>No Leaf Node = 索引 + 数据</p><p>Leaf Node = 索引 + 数据</p><p>3.2 B+Tree</p><p>No Leaf Node = 索引，<strong>便于存储更多的索引值</strong></p><p>Leaf Node = 索引 + 数据</p><p>Leaf Node 链表结构，<strong>提高区间访问性能</strong></p><h4 id="3-5-3-聚集索引和辅助索引"><a href="#3-5-3-聚集索引和辅助索引" class="headerlink" title="3.5.3 聚集索引和辅助索引"></a>3.5.3 聚集索引和辅助索引</h4><ul><li><p>聚集索引：主键索引，主键索引就是数据本身，占用空间大。InnoDB的表必须要有主键索引</p></li><li><p>辅助索引：二级索引，根据索引列构建B+Tree结构。Leaf Node 存储索引列和主键信息，占用空间比主键索引小很多。用于提升查询效率，InnoDB表可以有多个辅助索引</p></li><li><p><img src="http://lion-heart.online/blog/2021-02-14-050754.png" alt="image-20210214130751374"></p></li></ul><h4 id="3-5-4-其他相关概念"><a href="#3-5-4-其他相关概念" class="headerlink" title="3.5.4 其他相关概念"></a>3.5.4 其他相关概念</h4><h5 id="一、回表查询"><a href="#一、回表查询" class="headerlink" title="一、回表查询"></a>一、回表查询</h5><ul><li>需要通过索引查询主键值，然后再通过主键索引查询数据</li></ul><h5 id="二、覆盖索引"><a href="#二、覆盖索引" class="headerlink" title="二、覆盖索引"></a>二、覆盖索引</h5><ul><li>只需要在一个索引树上就能获取SQL所需的所有列数据，无需回表，速度更快，这就叫索引覆盖</li></ul><h5 id="三、最左前缀原则：针对复合索引"><a href="#三、最左前缀原则：针对复合索引" class="headerlink" title="三、最左前缀原则：针对复合索引"></a>三、最左前缀原则：针对复合索引</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-14-053201.png" alt="image-20210214133159139"></li></ul><h5 id="四、Like-查询"><a href="#四、Like-查询" class="headerlink" title="四、Like 查询"></a>四、Like 查询</h5><ul><li>索引下推 </li><li><img src="http://lion-heart.online/blog/2021-02-14-055753.png" alt="image-20210214135746018"></li></ul><h5 id="五、NULL-查询"><a href="#五、NULL-查询" class="headerlink" title="五、NULL 查询"></a>五、NULL 查询</h5><ul><li>可以用到索引，但是官方不建议NULL值加索引，需要额外的存储空间</li></ul><h5 id="六、索引和排序"><a href="#六、索引和排序" class="headerlink" title="六、索引和排序"></a>六、索引和排序</h5><ul><li>filesort<ul><li>两路查询</li><li>单路查询</li></ul></li><li>index</li></ul><h5 id="六、执行计划"><a href="#六、执行计划" class="headerlink" title="六、执行计划"></a>六、执行计划</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-14-055854.png" alt="image-20210214135848388"></li></ul><h3 id="3-6-事务和锁"><a href="#3-6-事务和锁" class="headerlink" title="3.6 事务和锁"></a>3.6 事务和锁</h3><h4 id="3-6-1-ACID"><a href="#3-6-1-ACID" class="headerlink" title="3.6.1 ACID"></a>3.6.1 ACID</h4><ul><li>原子性：一个事务操作，要么全部成功，要么全部失败<ul><li>DML 修改 BP 后 </li><li>commit 如何保证 dirty page 刷盘 -》 Redo Log</li><li>un commit dirty page 刷盘 如何保证数据变更撤销 -〉Undo Log</li></ul></li><li>一致性：数据完整性<ul><li>约束一致性：外键、唯一索引</li><li>数据一致性<ul><li><img src="http://lion-heart.online/blog/2021-02-14-123815.png" alt="image-20210214203812778"></li></ul></li></ul></li><li>隔离性：事务的执行不受其他事务影响<ul><li>读提交</li><li>读未提交</li><li>可重复读</li><li>可串行化：开启事务后，读写操作串行化</li></ul></li><li>持久性：事务提交后，对数据库中的数据改变是永久性的<ul><li><img src="http://lion-heart.online/blog/2021-02-14-123105.png" alt="image-20210214203102695"></li></ul></li></ul><p><img src="http://lion-heart.online/blog/2021-02-14-123912.png" alt="image-20210214203911494"></p><h4 id="3-6-2-事务控制演进"><a href="#3-6-2-事务控制演进" class="headerlink" title="3.6.2 事务控制演进"></a>3.6.2 事务控制演进</h4><h5 id="3-6-2-1-并发事务带来的问题"><a href="#3-6-2-1-并发事务带来的问题" class="headerlink" title="3.6.2.1 并发事务带来的问题"></a>3.6.2.1 并发事务带来的问题</h5><p><img src="http://lion-heart.online/blog/2021-02-15-011816.png" alt="image-20210215091811405"></p><h5 id="3-6-2-2-解决并发事务问题的方法"><a href="#3-6-2-2-解决并发事务问题的方法" class="headerlink" title="3.6.2.2 解决并发事务问题的方法"></a>3.6.2.2 解决并发事务问题的方法</h5><ul><li>全局排队</li><li>表空间排队</li><li>行记录排队</li><li>读写排队</li><li>MVCC（读写不排队，限定RC（Read View 视图每次都会创建）、RR（Read view视图只创建一次）隔离级别）</li><li>乐观锁、悲观锁</li></ul><h5 id="3-6-2-3-MVCC"><a href="#3-6-2-3-MVCC" class="headerlink" title="3.6.2.3 MVCC"></a>3.6.2.3 MVCC</h5><ul><li>概念：数据库为了实现高并发的数据访问，对数据进行多版本处理。通过事务的可见性来保证事务能看到自己应该看到的版本。<ul><li>事务操作前，Undo Log会记录数据变化过程，也就是在生成备份数据，当前备份可以为其他事务提供版本数据，也可以作为回滚数据</li></ul></li><li>分类<ul><li>快照读：读取的是记录的快照版本，不用加锁。select 语法</li><li>当前读：读取的是记录的最新版本，都会加锁，保证其他事务不会并发修改这条记录。select ….. for update 或 locin in share model 或 DML 会先执行当前读</li></ul></li><li>原理<ul><li><img src="http://lion-heart.online/blog/2021-02-15-014737.png" alt="行记录隐藏字段"></li><li><img src="http://lion-heart.online/blog/2021-02-15-014941.png" alt="image-20210215094937916"></li></ul></li></ul><h5 id="3-6-2-4-隔离级别"><a href="#3-6-2-4-隔离级别" class="headerlink" title="3.6.2.4 隔离级别"></a>3.6.2.4 隔离级别</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-15-020744.png" alt="image-20210215100741272"></li></ul><h5 id="总结：事务隔离级别和锁还有MVCC的关系"><a href="#总结：事务隔离级别和锁还有MVCC的关系" class="headerlink" title="总结：事务隔离级别和锁还有MVCC的关系"></a>总结：<strong>事务隔离级别和锁还有MVCC的关系</strong></h5><p>1）事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使用的封装，隐藏了底层细节。</p><p>2）锁是数据库实现并发控制的基础，事务隔离性是采用锁来实现，对相应操作加不同的锁，就可以防止其他事务同时对数据进行读写操作。</p><p>3）MVCC是进一步提高了数据库并发处理能力（读写冲突）的一种手段，通过Undo Log + 事务特性由数据库底层自动屏蔽细节，解决特定问题</p><p>4）对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必要在开发中手动的设置锁。</p><p>一般使用时，建议采用默认隔离级别，然后存在的一些并发问题，可以通过悲观锁、乐观锁等实现处理。</p><p>早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。</p><p>对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化。有的数据库内建乐观锁，但是有的没有（比如MySQL就没有），所以需要开发人员自己在数据表里加version列，自己写业务代码实现。</p><blockquote><p>顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度</p><p>如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p></blockquote><p>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是<strong>对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。</p><p>这样，实现两个隔离级别就非常容易：</p><ul><li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li><li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）</li></ul><p>也可以主动添加共享锁</p><ul><li>select…… lock in share mode</li></ul><p>MVCC并不是万灵药。大量的业务问题的关键点在于，<strong>你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效</strong>。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景</p><p>在这种场景下</p><ul><li>在MySQL InnoDB，使用者会使用<code>select ... for update</code>手工加锁。或者干脆用Serializable隔离级别</li></ul><h4 id="3-6-3-锁机制"><a href="#3-6-3-锁机制" class="headerlink" title="3.6.3 锁机制"></a>3.6.3 锁机制</h4><h5 id="1-锁分类"><a href="#1-锁分类" class="headerlink" title="1.锁分类"></a>1.锁分类</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-15-110210.png" alt="image-20210215190200271"></li></ul><h5 id="2-锁原理：锁的是索引数据页"><a href="#2-锁原理：锁的是索引数据页" class="headerlink" title="2.锁原理：锁的是索引数据页"></a>2.锁原理：锁的是索引数据页</h5><p><img src="http://lion-heart.online/blog/2021-02-15-112117.png" alt="image-20210215192116918"></p><ul><li>update test set name = ‘xx’ where id = 1;<ul><li>test 表 id 为主键索引<ul><li>innodb 会使用 Next-key Lock 锁进行处理，发现 id 为主键索引，锁降级为 Record Lock，锁住主键索引</li></ul></li><li>test 表 id 为唯一索引<ul><li>innodb 先在唯一索引 id 上加X锁，然后再在主键索引记录上加X锁，两颗树都加锁</li></ul></li><li>test 表 id 为普通索引<ul><li>innodb 会使用 Next-key Lock 锁进行处理，先锁住X锁辅助索引树上满足条件记录行，然后还要锁住间隙或范围，再通过主键锁住X锁主键索引记录</li></ul></li><li>test 表 id 不是索引<ul><li>锁住表里所有行和间隙 X锁</li></ul></li></ul></li></ul><p>总结：事务使用了排他锁（写锁），当前事务可以读取和修改，其他事务不能修改，也不能获取记录锁（select… for update）。如果查询没有使用到索引，将会锁住整个表记录。</p><h5 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-15-121024.png" alt="image-20210215201023682"></li></ul><h3 id="3-7-死锁"><a href="#3-7-死锁" class="headerlink" title="3.7 死锁"></a>3.7 死锁</h3><h4 id="1-表锁死锁"><a href="#1-表锁死锁" class="headerlink" title="1.表锁死锁"></a>1.表锁死锁</h4><h4 id="2-行锁死锁"><a href="#2-行锁死锁" class="headerlink" title="2.行锁死锁"></a>2.行锁死锁</h4><h4 id="3-共享锁转排它锁"><a href="#3-共享锁转排它锁" class="headerlink" title="3.共享锁转排它锁"></a>3.共享锁转排它锁</h4><h4 id="4-死锁排查"><a href="#4-死锁排查" class="headerlink" title="4.死锁排查"></a>4.死锁排查</h4><h2 id="四、集群架构"><a href="#四、集群架构" class="headerlink" title="四、集群架构"></a>四、集群架构</h2><h3 id="1-集群架构设计"><a href="#1-集群架构设计" class="headerlink" title="1.集群架构设计"></a>1.集群架构设计</h3><h4 id="1-1-设计理念"><a href="#1-1-设计理念" class="headerlink" title="1.1 设计理念"></a>1.1 设计理念</h4><ul><li>可用性</li><li>扩展性</li><li>一致性</li></ul><h4 id="1-2-可用性设计：核心思路-冗余"><a href="#1-2-可用性设计：核心思路-冗余" class="headerlink" title="1.2 可用性设计：核心思路 - 冗余"></a>1.2 可用性设计：核心思路 - 冗余</h4><ul><li>服务高可用</li><li>数据高可用：数据一致性问题</li></ul><h4 id="1-3-扩展性设计"><a href="#1-3-扩展性设计" class="headerlink" title="1.3 扩展性设计"></a>1.3 扩展性设计</h4><ul><li>提高读写性能<ul><li>读性能</li><li>写性能</li></ul></li><li></li></ul><h3 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2.主从复制"></a>2.主从复制</h3><h4 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h4><ul><li><img src="http://lion-heart.online/blog/2021-02-16-010850.png" alt="image-20210216090849570"></li></ul><p>主从复制整体分为以下三个步骤：</p><ul><li><p>主库将数据库的变更操作记录到Binlog日志文件中</p></li><li><p>从库读取主库中的Binlog日志文件信息写入到从库的Relay Log中继日志中</p></li><li><p>从库读取中继日志信息在从库中进行Replay,更新从库数据信息</p></li></ul><p>在上述三个过程中，涉及了Master的BinlogDump Thread和Slave的I/O Thread、SQL Thread，它们的作用如下：</p><ul><li><p>Master服务器对数据库更改操作记录在Binlog中，BinlogDump Thread接到写入请求后，读取Binlog信息推送给Slave的I/O Thread。</p></li><li><p>Slave的I/O Thread将读取到的Binlog信息写入到本地Relay Log中。</p></li><li><p>Slave的SQL Thread检测到Relay Log的变更请求，解析relay log中内容在从库上执行。</p></li></ul><h4 id="2-2-缺点"><a href="#2-2-缺点" class="headerlink" title="2.2 缺点"></a>2.2 缺点</h4><ul><li>数据丢失 - 主库宕机，从未接收到binlog或未写入relaylog<ul><li>半同步复制</li><li>增强半同步</li></ul></li><li>复制延迟 - 写压力大或机器性能存在问题情况下，SQL Thread 和 I/O Thread 受影响导致延迟<ul><li>并行复制</li><li><img src="http://lion-heart.online/blog/2021-02-16-022709.png" alt="image-20210216102708771"></li></ul></li></ul><h4 id="2-3-实战"><a href="#2-3-实战" class="headerlink" title="2.3 实战"></a>2.3 实战</h4><h5 id="一、主库配置"><a href="#一、主库配置" class="headerlink" title="一、主库配置"></a>一、主库配置</h5><ul><li>主库开启binlog</li><li>设置serverId</li><li>binlog通信方式</li><li>数据源设置</li><li>从数据库授权</li></ul><h5 id="二、从库配置"><a href="#二、从库配置" class="headerlink" title="二、从库配置"></a>二、从库配置</h5><ul><li>设置 server - id</li><li>日志命名</li><li>读写限制</li><li>主库信息、文件、位置配置</li></ul><h5 id="三、复制方式"><a href="#三、复制方式" class="headerlink" title="三、复制方式"></a>三、复制方式</h5><ul><li>基于binlog二进制文件及其位置</li><li>基于binlogdump文件</li></ul><h5 id="四、半同步复制-–-保证从接收binlog日志，解决数据丢失问题"><a href="#四、半同步复制-–-保证从接收binlog日志，解决数据丢失问题" class="headerlink" title="四、半同步复制 – 保证从接收binlog日志，解决数据丢失问题"></a>四、半同步复制 – 保证从接收binlog日志，解决数据丢失问题</h5><ul><li><img src="http://lion-heart.online/blog/2021-02-16-025905.png" alt="半同步复制时序图"></li><li>semi plugin install</li><li>参数修改</li></ul><h5 id="五、并行复制-加快复制过程，解决数据延迟问题"><a href="#五、并行复制-加快复制过程，解决数据延迟问题" class="headerlink" title="五、并行复制 - 加快复制过程，解决数据延迟问题"></a>五、并行复制 - 加快复制过程，解决数据延迟问题</h5><h4 id="2-4-读写分离"><a href="#2-4-读写分离" class="headerlink" title="2.4 读写分离"></a>2.4 读写分离</h4><ul><li><p>概念</p><ul><li><p>大多数互联网业务中，往往读多写少，这时候数据库的读会首先成为数据库的瓶颈。如果我们已经优化了SQL，但是读依旧还是瓶颈时，这时就可以选择“读写分离”架构了。</p><p>读写分离首先需要将数据库分为主从库，一个主库用于写数据，多个从库完成读数据的操作，主从库之间通过主从复制机制进行数据的同步。</p><p>在应用中可以在从库追加多个索引来优化查询，主库这些索引可以不加，用于提升写效率</p></li></ul></li><li><p>原理</p><ul><li><img src="http://lion-heart.online/blog/2021-02-16-031705.png" alt="读写分离架构"></li></ul></li><li><p>问题</p><ul><li>主从同步延迟<ul><li>写后立刻读</li><li>二次查询</li><li>业务特殊处理</li></ul></li><li>读写分配机制<ul><li>应用端分配<ul><li>编码 + 配置</li></ul></li><li>服务端分配<ul><li>MySQL Proxy</li><li>MyCat</li><li>ShardingJDBC</li></ul></li></ul></li></ul></li></ul><h3 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3.分库分表"></a>3.分库分表</h3><p>互联网系统需要处理大量用户的请求。比如微信日活用户破10亿，海量的用户每天产生海量的数量；美团外卖，每天都是几千万的订单，那这些系统的用户表、订单表、交易流水表等是如何处理呢？</p><p>上面体现为数据量大。MySQL在存储方面，官方的数据可以存储10E级别。但是KW级别表，索引树高度在3~5层，性能还可以，超过KW级别对存储和查询性能都有影响，那如何处理呢？</p><p>首先需要分析数据数据是否是可以结转，如果数据量只增不减，历史数据又必须要留存，非常容易成为性能的瓶颈，而要解决这样的数据库瓶颈问题，<strong>读写分离</strong>和<strong>缓存</strong>往往都不合适</p><p>解决方案</p><ul><li><p>NoSQL、NewSQL</p></li><li><p>分库分表，主要有垂直拆分和水平拆分两种拆分模式，都属于物理空间的拆分</p><ul><li><p>分库分表方案：只分库、只分表、分库又分表</p></li><li><p>垂直拆分：由于表数量多导致的单个库大。将表拆分到多个库中。</p><ul><li><p><img src="http://lion-heart.online/blog/2021-02-16-133114.png" alt="垂直分库"></p></li><li><p><img src="http://lion-heart.online/blog/2021-02-16-133207.png" alt="垂直分表"></p><ul><li><p><strong>垂直拆分优点</strong>：</p><ul><li><p>拆分后业务清晰，拆分规则明确；</p></li><li><p>易于数据的维护和扩展；</p></li><li><p>可以使得行数据变小，一个数据块 (Block) 就能存放更多的数据，在查询时就会减少 I/O 次数；</p></li><li><p>可以达到最大化利用 Cache 的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将</p></li><li><p>经常改变的放一起；</p></li><li><p>便于实现冷热分离的数据表设计模式。</p></li></ul></li><li><p><strong>垂直拆分缺点</strong></p><ul><li>主键出现冗余，需要管理冗余列；</li><li>会引起表连接 JOIN 操作，可以通过在业务服务器上进行 join 来减少数据库压力，提高了系统的复杂度；</li><li>依然存在单表数据量过大的问题；</li><li>事务处理复杂。</li></ul></li></ul></li></ul></li><li><p>水平拆分：由于表记录多导致的单个库大。将表记录拆分到多个表中。</p><ul><li><p><img src="http://lion-heart.online/blog/2021-02-16-134000.png" alt="水平拆分"></p><ul><li><p><strong>水平拆分优点</strong>：</p><ul><li><p>拆分规则设计好，join 操作基本可以数据库做；</p></li><li><p>不存在单库大数据，高并发的性能瓶颈；</p></li><li><p>切分的表的结构相同，应用层改造较少，只需要增加路由规则即可；</p></li><li><p>提高了系统的稳定性和负载能力。</p></li></ul></li><li><p><strong>水平拆分缺点</strong>：</p><ul><li><p>拆分规则难以抽象</p></li><li><p>跨库Join性能较差</p></li><li><p>分片事务的一致性难以解决</p></li><li><p>数据扩容的难度和维护量极大</p></li></ul></li></ul></li></ul></li></ul></li></ul><h4 id="一、水平拆分：解决表中记录过多问题，水平拆分重点考虑拆分规则：例如范围、时间或Hash算法等。"><a href="#一、水平拆分：解决表中记录过多问题，水平拆分重点考虑拆分规则：例如范围、时间或Hash算法等。" class="headerlink" title="一、水平拆分：解决表中记录过多问题，水平拆分重点考虑拆分规则：例如范围、时间或Hash算法等。"></a>一、水平拆分：解决表中记录过多问题，水平拆分重点考虑拆分规则：例如范围、时间或Hash算法等。</h4><h4 id="二、垂直拆分：解决表过多或者是表字段过多问题。"><a href="#二、垂直拆分：解决表过多或者是表字段过多问题。" class="headerlink" title="二、垂直拆分：解决表过多或者是表字段过多问题。"></a>二、垂直拆分：解决表过多或者是表字段过多问题。</h4><h4 id="三、主键生成策略（分布式id生成器）"><a href="#三、主键生成策略（分布式id生成器）" class="headerlink" title="三、主键生成策略（分布式id生成器）"></a>三、主键生成策略（分布式id生成器）</h4><ul><li>UUID<ul><li>优点<ul><li>无网络消耗</li><li>性能高</li></ul></li><li>缺点<ul><li>无序</li><li>占用空间大</li><li>不利于索引构建</li></ul></li></ul></li><li>COMB</li><li>SnowFlake</li><li>数据库ID表</li><li>Redis</li></ul><h4 id="四、分片策略"><a href="#四、分片策略" class="headerlink" title="四、分片策略"></a>四、分片策略</h4><ul><li><p>概念</p><ul><li>分片，也叫 sharding ，是一个逻辑概念，就是将数据按照指定规则从一个存储设备分散到多个存储设备</li></ul></li><li><p>分片策略</p><ul><li><p>分片键</p><ul><li>具体表字段</li></ul></li><li><p>分片策略</p><ul><li><p>基于范围分片，例如：主键、创建时间等</p><p>优点：新数据可以落在新存储节点，如果集群扩容，数据无需迁移</p><p>缺点：数据热点分布不均</p></li><li><p>基于哈希取模、离散分片</p><p>优点：实现简单，数据分配均匀</p><p>缺点：集群扩容，数据需要迁移</p></li><li><p>一致性哈希分片</p><p>优点：集群扩容，受影响的数据比较有限，当前节点位置的下一个节点</p><p>缺点：哈希算法复杂</p></li></ul></li></ul></li></ul><h4 id="五、扩容方案"><a href="#五、扩容方案" class="headerlink" title="五、扩容方案"></a>五、扩容方案</h4><h5 id="问题：分片策略变更、数据同步、数据迁移、数据一致性"><a href="#问题：分片策略变更、数据同步、数据迁移、数据一致性" class="headerlink" title="问题：分片策略变更、数据同步、数据迁移、数据一致性"></a>问题：分片策略变更、数据同步、数据迁移、数据一致性</h5><ul><li><p>停机扩容：增减任意节点</p><ul><li><p>对外公告</p></li><li><p>停止服务</p></li><li><p>数据迁移、程序变更分片策略、配置变更</p></li><li><p>重启服务</p><p>优点：简单</p><p>缺点：服务可用性、扩展性低下，一但扩容投入生产，无法回滚</p></li></ul></li><li><p>平滑扩容：扩容为原来的 double 倍</p><ul><li><p>新增 2倍 服务器</p></li><li><p>配置双主配置</p></li><li><p>数据同步完成后，配置双主双写</p></li><li><p>删除双写，重启</p></li><li><p>清除冗余数据</p><p>优点：服务高可用，可以将单数据库量减少一半，性能提高一倍</p><p>缺点：程序复杂、配置双主同步、双主双写，越来越复杂</p></li></ul></li></ul><h3 id="五、分库分表实战及中间件"><a href="#五、分库分表实战及中间件" class="headerlink" title="五、分库分表实战及中间件"></a>五、分库分表实战及中间件</h3><h4 id="1-问题列表"><a href="#1-问题列表" class="headerlink" title="1.问题列表"></a>1.问题列表</h4><ul><li>用户请求量变大<ul><li>单服务器TPS、内存、IO都是有上限，需要将请求打散分布到多个服务器</li></ul></li><li>单库数据库量太大<ul><li>单数据库处理能力有限</li><li>单数据库磁盘空间有限</li><li>单数据库IO有瓶颈</li></ul></li><li>单表数据库量太大<ul><li>查询</li><li>插入</li><li>更新</li><li>加字段</li><li>加索引</li><li>以上操作都会产生高负载，影响服务</li></ul></li></ul><h4 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h4><ul><li>垂直拆分<ul><li>分库：业务维度进行微服务架构，数据维度也会按照业务切分，保证数据隔离，大大提供数据库吞吐能力</li><li>分表：多字段的表进行拆分，进行冷热数据分离</li></ul></li><li>水平拆分<ul><li>分库：将一张大表拆分多个表，但是数据库级别操作还是IO瓶颈</li><li>分表：将单表数据切分到多个服务器，好处就是缓解单机性能瓶颈和压力，突破IO、连接数、内存和CPU瓶颈</li><li>注意规则<ul><li>不垮库</li><li>不垮表</li><li>保证同一类数据都在同一个服务器</li><li>分片策略选择</li></ul></li></ul></li></ul><h4 id="3-用户表拆分"><a href="#3-用户表拆分" class="headerlink" title="3.用户表拆分"></a>3.用户表拆分</h4><ul><li>ID hash </li><li>ID mapping phoneNumber</li><li>利用空间换时间</li></ul><h4 id="4-设备表拆分"><a href="#4-设备表拆分" class="headerlink" title="4.设备表拆分"></a>4.设备表拆分</h4><ul><li>设备ID sharding</li><li>农场ID sharding</li><li>主键选择<ul><li>UUID</li><li>SnowFlake</li></ul></li><li>数据一致性<ul><li>强一致性：XA 协议</li><li>最终一致性：TCC、saga、Seata</li></ul></li><li>数据库扩容<ul><li>平滑扩容</li></ul></li><li>业务层改造<ul><li>基于应用层方式：Sharding - jdbc</li><li>基于代理层方式：MyCat、Sharding - Proxy</li></ul></li><li>面临问题<ul><li>事务问题</li><li>跨库，跨表 join 问题<ul><li>全局表（字典表）：基础数据、配置数据，所有库都copy一份</li><li>字段冗余：可以使用字段冗余</li><li>业务层组装：数据访问层查询，然后在业务逻辑层组装</li></ul></li><li>额外的数据管理负担和数据运算压力<ul><li>数据库扩容</li><li>维护</li></ul></li></ul></li></ul><h4 id="5-ShardingSphere：分布式数据库中间件组成的生态圈"><a href="#5-ShardingSphere：分布式数据库中间件组成的生态圈" class="headerlink" title="5.ShardingSphere：分布式数据库中间件组成的生态圈"></a>5.ShardingSphere：分布式数据库中间件组成的生态圈</h4><h5 id="5-1-组成"><a href="#5-1-组成" class="headerlink" title="5.1 组成"></a>5.1 组成</h5><ul><li>JDBC</li><li>Proxy</li><li>Sidecar</li></ul><h5 id="5-2-Sharding-JDBC"><a href="#5-2-Sharding-JDBC" class="headerlink" title="5.2 Sharding-JDBC"></a>5.2 Sharding-JDBC</h5><ul><li><p>介绍</p><ul><li>轻量级Java框架，jar形式提供服务</li><li>适用于任何基于Java的ORM</li><li>基于任何第三方的数据库连接池</li><li>支持任意实现JDBC规范的数据库 </li><li><img src="http://lion-heart.online/blog/2021-02-17-041639.png" alt="image-20210217121639471"></li></ul></li><li><p>主要功能</p><ul><li>数据分片<ul><li>分库、分表</li><li>读写分离</li><li>配置文件设置分片策略</li><li>集成分布式主键</li></ul></li><li>分布式事务<ul><li>XA协议</li><li>Sage 模型</li><li>Seata</li></ul></li><li>数据库治理<ul><li>数据库配置动态化</li><li>数据库监控，可视化链路追踪</li><li>数据库编排</li><li>数据脱敏</li></ul></li></ul></li><li><p>原理</p><ul><li><img src="http://lion-heart.online/blog/2021-02-17-043622.png" alt="Sharding-JDBC 类图"></li><li>Factory API<ul><li>ShardingDataSourceFactory 支持分库分表、读写分离</li><li>MasterSlaveDataSourceFactory 支持读写分离</li></ul></li><li>Configuration <ul><li>ShardingRuleConfiguration是分库分表配置的核心和入口<ul><li>TableRuleConfiguration是表的分片配置信息，有五种配置形式</li></ul></li><li>MasterSlaveConfiguration是读写分离配置的核心和入口</li></ul></li></ul></li><li><p>Sharding-JDBC 初始化流程</p><ul><li>根据配置信息生成 Configuration 对象</li><li>通过 Factory 将 Configuration 对象转化成 Rule 对象</li><li>通过 Factory 将 Rule 对象与 DataSource 对象封装</li><li>ShardingJDBC 使用 DataSource 进行分库分表、读写分离操作</li></ul></li><li><p>Sharding-JDBC 数据分片</p><ul><li><p>表概念</p><p>真实表：数据库中真实存在的物理表</p><p>逻辑表：分片后，同一类表结构的总称</p><p>数据节点：水平分库，分片后，数据源 + 真实表 组成</p><p>绑定表：具有相同分片键的关系表</p><p>farm_iot_device = 逻辑表</p><p>farm_iot_device0 = 真实表</p><p>farm_iot_device:farm_iot_device0,farm_iot_device1</p><p>farm_device_monitor_data:farm_device_monitor_data0,farm_device_monitor_data1</p><p>select * from farm_device_monitor_data f1 on farm_iot_device f2 on f1.device_id = f2.device_id where f1.device_id in (11,12,13)</p><p>device_id 分片</p><p>如果不配置绑定关系，采用笛卡尔积关联，生成4个SQL</p><p>如果配置绑定关系，生成2个SQL</p><p>广播表：不需要分片的表会在不同的数据节点上进行存储</p></li><li><p>分片算法</p><ul><li><p>精确的分片算法</p><ul><li>= 和 in 用法，适用于单一分片键</li></ul></li><li><p>范围分片算法</p></li></ul></li></ul></li></ul><pre><code>- 复合分片算法  - 多分片键场景- Hint分片算法  - 适用于Hint场景</code></pre><ul><li><p>分片策略：分片算法 + 分片键，真正可用于分片操作的是分片策略</p><ul><li>标准分片策略</li><li>复合分片策略</li><li>行表达式分片策略</li><li>Hint分片策略</li><li>无分片策略</li></ul></li><li><p>分片流程</p><ul><li><p>SQL解析</p><p>词法解析</p></li></ul></li></ul><pre><code>- 查询优化  优化分片条件- SQL路由- SQL改写- SQL执行- 结果归并- ![数据分片流程](http://lion-heart.online/blog/2021-02-17-055928.png)</code></pre><h5 id="5-3-ShardingJDBC-分布式主键"><a href="#5-3-ShardingJDBC-分布式主键" class="headerlink" title="5.3 ShardingJDBC 分布式主键"></a>5.3 ShardingJDBC 分布式主键</h5><ul><li>内置主键生成器<ul><li>UUID</li><li>SnowFlake：默认实现</li></ul></li><li>自定义主键生成器<ul><li>自定义类实现 xxxx 接口</li><li>按SPI规范配置自定义主键类</li><li>自定义类配置</li></ul></li></ul><h3 id="Buffer-Pool-原理"><a href="#Buffer-Pool-原理" class="headerlink" title="Buffer Pool 原理"></a>Buffer Pool 原理</h3><p>Buffer Pool就是数据库的一个内存组件，具有完整的数据结构，里面缓存了磁盘上的真实数据，增删改操作首先就是针对这个内存中的Buffer Pool里的数据执行的，同时配合了后续的redo log、刷磁盘等机制和操作。</p><p>![crud](/Users/jinhongcai/Desktop/屏幕快照 2020-10-09 上午9.53.00.png)</p><h4 id="数据页：MySQL中抽象出来的数据单位"><a href="#数据页：MySQL中抽象出来的数据单位" class="headerlink" title="数据页：MySQL中抽象出来的数据单位"></a><strong>数据页：MySQL中抽象出来的数据单位</strong></h4><p>实际上MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据</p><h4 id="磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？"><a href="#磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？" class="headerlink" title="磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？"></a><strong>磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？</strong></h4><p>缓存页 和 数据页 一一对应，每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的比如包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂八的东西。</p><p>![屏幕快照 2020-10-09 上午10.21.16](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.21.16.png)</p><h4 id="数据库启动的时候，是如何初始化Buffer-Pool的？"><a href="#数据库启动的时候，是如何初始化Buffer-Pool的？" class="headerlink" title="数据库启动的时候，是如何初始化Buffer Pool的？"></a><strong>数据库启动的时候，是如何初始化Buffer Pool的？</strong></h4><p>数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区域，作为Buffer Pool的内存区域</p><p>然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据</p><p>执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中</p><h4 id="我们怎么知道哪些缓存页是空闲的呢？"><a href="#我们怎么知道哪些缓存页是空闲的呢？" class="headerlink" title="我们怎么知道哪些缓存页是空闲的呢？"></a><strong>我们怎么知道哪些缓存页是空闲的呢？</strong></h4><p>数据库会为Buffer Pool设计一个<strong>free链表</strong></p><p>![屏幕快照 2020-10-09 上午10.33.10](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.33.10.png)</p><h4 id="如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？"><a href="#如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？" class="headerlink" title="如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？"></a><strong>如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？</strong></h4><p>逻辑：</p><ol><li>Bufferpool 还会有一个哈希表数据结构，用表空间号+数据页号，作为一个key，然后缓存页的地址作为value</li><li>从free链表中找到一个空闲的缓存页</li><li>从磁盘上读取数据页写入缓存页</li><li>写入描述数据</li><li>从free指针清空</li></ol><p>![屏幕快照 2020-10-09 上午10.56.47](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.56.47.png)</p><h4 id="数据一致性问题？"><a href="#数据一致性问题？" class="headerlink" title="数据一致性问题？"></a>数据一致性问题？</h4><p>描述数据维护了flush 链表，flush 链表同 free 链表结构、作用相同，就是意义不同，描述缓存页是否是脏页</p><h4 id="缓存页淘汰问题？脏页淘汰机制"><a href="#缓存页淘汰问题？脏页淘汰机制" class="headerlink" title="缓存页淘汰问题？脏页淘汰机制"></a>缓存页淘汰问题？脏页淘汰机制</h4><p>![缓存命中率概念 + LRU 算法](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午11.21.52.png)</p><p>通过LRU维护了一个最近最少使用的 缓存页 结构。当需要加载数据页到缓存页，同时缓存页不足的情况下，就会通过LRU淘汰掉缓存命中率低的缓存页，触发刷盘机制。            </p><h4 id="什么是预读机制？"><a href="#什么是预读机制？" class="headerlink" title="什么是预读机制？"></a>什么是预读机制？</h4><p>从磁盘上加载一个数据页的时候，可能会把数据页相邻的其他数据页也加载到缓存里去</p><h4 id="什么情况会发生预读？"><a href="#什么情况会发生预读？" class="headerlink" title="什么情况会发生预读？"></a>什么情况会发生预读？</h4><ol><li>参数：innodb_read_ahead_theshold，默认值56。意思就是如果顺序的访问了一个区里的多个数据页，超过阈值，此时会触发预读机制，把下一个相邻区的所有数据页都加载到缓存里去</li><li>参数：innodb_random_read_ahead，默认 OFF。Buffer pool里缓存了一个区里的13个连续的数据页，而且这些数据页都是比较频繁会被访问，此时直接触发预读机制，当前区里其他数据页加载到缓存里</li><li>全表扫描，导致当前表空间内所有数据页全部加载到缓存页中</li></ol><h4 id="预读机制好处？"><a href="#预读机制好处？" class="headerlink" title="预读机制好处？"></a>预读机制好处？</h4><p>减少磁盘IO，提升性能</p><h4 id="什么场景会用到预读机制？预读带来的问题？"><a href="#什么场景会用到预读机制？预读带来的问题？" class="headerlink" title="什么场景会用到预读机制？预读带来的问题？"></a>什么场景会用到预读机制？预读带来的问题？</h4><p>发生预读，加载很多数据页到内存，这些缓存页未来可能都不会被访问到。如果free缓存页充足的情况下，没有问题。如果free不充足的情况，会将LRU上缓存页淘汰，但是很多预读的缓存页，在当前时刻可能是在 LRU 链表的头部区域，而经常被访问的缓存页，就会被优先淘汰，刷盘到磁盘</p><p>![预读问题](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.28.27.png)</p><h4 id="解决简单LRU链表带来的问题？"><a href="#解决简单LRU链表带来的问题？" class="headerlink" title="解决简单LRU链表带来的问题？"></a>解决简单LRU链表带来的问题？</h4><p>真正的LRU链表，会被拆分两部分，一部分热数据，一部分是冷数据，比例根据 innodb_old_blocks_pct 参数控制，默认37</p><p><img src="/Users/jinhongcai/Desktop/mysql/%E5%86%B7%E7%83%AD%E9%93%BE%E8%A1%A8%E6%8B%86%E5%88%86.png" alt="冷热链表拆分"></p><p>冷数据区域数据什么时候进入热数据区域，通过参数：innodb_old_blocks_time ，默认1000 ms，数据页被加载到缓存页 1s 后，访问当前缓存页，才会由冷数据区域挪动到热数据区域</p><p>![屏幕快照 2020-10-09 下午1.52.32](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.52.32.png)</p><h4 id="缓存数据刷盘"><a href="#缓存数据刷盘" class="headerlink" title="缓存数据刷盘"></a>缓存数据刷盘</h4><ol><li>定时通过后台线程，把冷数据区域尾部一些缓存页刷入磁盘。缓存页加入free链表、从flush链表移除、从lru链表移除</li><li>后台线程会在 mysql 不繁忙的时候，把flush链表中的缓存页刷入磁盘。flush、lru链表移除缓存页，free链表增加缓存页</li><li>无空闲缓存页，还需要加载数据页情况。先删掉LRU 冷数据区域尾部缓存页。</li></ol><h4 id="多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？"><a href="#多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？" class="headerlink" title="多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？"></a>多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？</h4><p>由于是共享变量，必须加锁。性能不会低</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>缓存页加载到 Buffer Pool 中，更新和读取缓存页里的数据。涉及到 free、flush、lru 链表。还包括后台线程是如何定时根据 flush、lru 链表将部分更新的缓存页刷盘，以及缓存页用完了以后是如何根据 lru 链表将一些冷数据缓存页刷盘。如何避免每次 crud 频繁刷盘 + 加载缓存页 这种多次磁盘 IO 浪费性能的操作</p><h3 id="为什么不能直接更新磁盘上的数据？"><a href="#为什么不能直接更新磁盘上的数据？" class="headerlink" title="为什么不能直接更新磁盘上的数据？"></a>为什么不能直接更新磁盘上的数据？</h3><p>每一个请求如果直接对磁盘文件进行随机读写，然后更新磁盘里的数据，最终结果就是性能低，并发度低，根本无法承受高并发的请求</p><h3 id="为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？"><a href="#为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？" class="headerlink" title="为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？"></a>为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？</h3><p>通过内存更新数据，然后写 redo log 以及提交事物，后台再通过定时刷盘机制，保证了没个更新请求，尽量就是更新内存，然后顺序写日志文件。更新内存的性能极高，然后顺序写磁盘上的日志文件性能也是比较高。</p><h3 id="MySql-为什么要引入数据页？"><a href="#MySql-为什么要引入数据页？" class="headerlink" title="MySql 为什么要引入数据页？"></a>MySql 为什么要引入数据页？</h3><p>数据更新如果不直接更新磁盘，更新哪些数据，保存在哪？所有问题都需要一个介质来链接，那就是缓存页，把磁盘上的数据加载到内存，更新缓存数据，同时写 redo log 到磁盘上</p><p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%B8%8D%E4%BB%A5%E7%A3%81%E7%9B%98%E4%B8%BA%E5%AA%92%E4%BB%8B.png" alt="数据更新不以磁盘为媒介"></p><h3 id="每次加载多少数据到内存？"><a href="#每次加载多少数据到内存？" class="headerlink" title="每次加载多少数据到内存？"></a>每次加载多少数据到内存？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%AF%8F%E6%AC%A1%E6%8C%89%E9%A1%B5%E7%BB%B4%E5%BA%A6%E5%8A%A0%E8%BD%BD.png" alt="数据每次按页维度加载"></p><h3 id="一行数据在磁盘上是如何存储的？包含哪些东西？"><a href="#一行数据在磁盘上是如何存储的？包含哪些东西？" class="headerlink" title="一行数据在磁盘上是如何存储的？包含哪些东西？"></a>一行数据在磁盘上是如何存储的？包含哪些东西？</h3><p>头字段描述 + 字段值</p><p>例如：”hello a a”，这一行数据具体有多少字段，都是什么，如果没有描述信息，根本无法解析</p><p>头字段描述 = 变长字段的长度列表，解决一行数据的读取问题</p><p>最终数据存储格式为：0x05 null值列表 数据头 hello a a </p><p>null值列表：所有允许为 NULL 的字段默认使用 bit表示，值为 NULL bit = 1 ，反之为 0，NULL 为什么不存 “NULL” 浪费空间</p><p>最终存储如下</p><pre><code>**变长字段列表 + NULL 值列表 + 字段头描述(40 bit ) + 隐藏字段 + 真实数据部分**</code></pre><p>隐藏字段</p><ol><li>DB_ROW_ID：数据库默认实现，行标识。</li><li>DB_TRX_ID：最近一次更新这条数据的事物id</li><li>DB_ROLL_PTR：回滚指针，事物回滚，指向你更新这个事务之前生成的 undo log</li></ol><p>每次数据变更都会更新隐藏字段</p><p>多事务串行更新一行数据，roll_poniter字段会把之前多个数据快照对应的undo log串联起来，形成重要的版本链</p><h3 id="ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"><a href="#ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值" class="headerlink" title="ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"></a>ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值</h3><p>触发时机：开启事务</p><p>关键结构：</p><ol><li>m_ids：未提交事务id集合</li><li>min_tx_id：未提交事务集合内最小事务id</li><li>max_tx_id：未提交事务id集合内最大事务id + 1</li><li>creator_tx_id：当前事务id</li></ol><p>原理</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>  可以读，数据的更新时间是在当前事务开启前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>      当前tx_id 是否存在 m_ids 内。存在就顺着 roll_poniter 日志链往下找，找到小于 min_trx_id 的记录    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="什么是行益出？"><a href="#什么是行益出？" class="headerlink" title="什么是行益出？"></a>什么是行益出？</h3><p>结合 Buffer Pool + 行数据在磁盘的存储结构，我们很容易就得到如下结论</p><p>一个 BufferPool 包含多个 <code>cache line</code> ，一个<code>cache line</code> 默认大小是 16KB，包含若干条行数据。如果行数据特别大或正巧一个磁盘数据页包含了半行数据，这样的数据如何处理。这样的问题也叫<code>行益出</code>，益出到其他数据页，存放益出数据页，也叫<code>益出页</code></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>insert 一条数据的时候，实际上 mysql 是在内存插入了一个复杂的数据结构，这些有复杂结构的行数据会被刷新到磁盘</p><h3 id="NULL-为啥用-bit-表示？"><a href="#NULL-为啥用-bit-表示？" class="headerlink" title="NULL 为啥用 bit 表示？"></a>NULL 为啥用 bit 表示？</h3><p>存储空间问题</p><h3 id="为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？"><a href="#为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？" class="headerlink" title="为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？"></a>为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？</h3><p>语言特性导致，不同语言如果用特定的序列化方式，跨语言将会反序列化异常。而数据库作为通用存储介质，不允许这种定制化存储方式来存储数据</p><h4 id="Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？"><a href="#Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？" class="headerlink" title="Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？"></a>Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？</h4><p>逻辑概念 = 只需要知道有哪些表，表里有哪些字段，表里有多少行，在哪存储并不关心</p><p>物理概念 = 表里的数据都是存储在一个表空间里，表空间是由一堆磁盘里的数据文件组成，这些数据文件就一个个数据页</p><h3 id="redo-log-作用-crash-safe"><a href="#redo-log-作用-crash-safe" class="headerlink" title="redo log 作用 crash safe"></a>redo log 作用 crash safe</h3><p>提交事物了，事物修改的缓存页没来得及刷盘，此时MySQL宕机了，会导致 buffer pool 里被事物修改过的数据全部丢失</p><p>只要有 redo log 重启MySQL之后完全可以把这些修改了的缓存页还未刷盘的事物操作，他们对应的 redo log 都加载出来，在 buffer pool 的缓存页重新做一遍，保证数据不丢失 【checkpoint lsb】</p><p>![curd 对应的 redo log 操作](/Users/jinhongcai/Desktop/mysql/curd 对应的 redo log 操作.png)</p><h3 id="事物执行了一半后，回滚了怎么办？什么逻辑？"><a href="#事物执行了一半后，回滚了怎么办？什么逻辑？" class="headerlink" title="事物执行了一半后，回滚了怎么办？什么逻辑？"></a>事物执行了一半后，回滚了怎么办？什么逻辑？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E4%BA%8B%E7%89%A9%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8D%8A%EF%BC%8C%E5%8F%91%E7%94%9F%E5%9B%9E%E6%BB%9A.png" alt="事物执行一半，发生回滚"></p><p>从目前的架构和流程来看，buffer pool 已经变更，redo log block 也写入若干条日志信息，无法完成回滚或恢复的操作。</p><p>如果想要回滚就需要另一个非常重要的日志组件，undo log 回滚日志</p><h3 id="undo-log-回滚日志-作用"><a href="#undo-log-回滚日志-作用" class="headerlink" title="undo log(回滚日志) 作用"></a>undo log(回滚日志) 作用</h3><p>回滚事物或叫恢复 buffer pool 里的缓存页数据</p><p>因为只有事物操作才会更新 buffer pool ，并且操作是不可逆的，事务操作包括 insert、update、delete 语句去更新缓存页的数据，但是万一事务回滚了，你必须有每条 SQL 语句对应的 undo log 回滚日志，根据回滚日志去恢复缓存页里被更新的数据</p><h3 id="undo-log-回滚日志是什么格式？如何存储？"><a href="#undo-log-回滚日志是什么格式？如何存储？" class="headerlink" title="undo log 回滚日志是什么格式？如何存储？"></a>undo log 回滚日志是什么格式？如何存储？</h3><p>undo log 文件格式<br>每种 DML 对应的文件格式都不同</p><p>INSERT<br>日志开始位置：指定位置进行磁盘随机读写<br>主键的各列长度和值：每条记录都有主键，id、联合主键等等，即使没有主动设置过主键字段，MySQL 也会给你弄一个 row_id 作为隐藏主键<br>表id：表维度标示<br>日志编号：没个undo log 都有自己的编号，例如一个事物里有多个 SQL 语句，事物内的 undo log 记录为一组，默认从0开始<br>日志类型：TRX_UNDO_INSERT_REC<br>日志结束位置：指定位置进行磁盘随机读写</p><p>插入操作回滚流程 ：<br>    buffer pool 缓存页里插入了一条数据，执行了 insert，生成了 INSERT undo log<br>    回滚时直接把这条 insert 语句的 undo log 拿出来，undo log 里有表id、主键信息就可以直接定位到对应的表空间 + 缓存页，从里面删除掉之前 insert 进去的数据</p><pre class=" language-java"><code class="language-java">crud 实现原理buffer pool 机制：找到表空间 <span class="token operator">-</span><span class="token operator">></span> 找到数据页 <span class="token operator">-</span><span class="token operator">></span> 加载到缓存页 <span class="token operator">-</span><span class="token operator">></span>更新缓存页 <span class="token operator">-</span><span class="token operator">></span>写 undo log <span class="token operator">-</span><span class="token operator">></span>写 redo log    数据结构    DescriptionDataBlock    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  数据块 对应redo、undo log 头文件中标记的 数据块编号     </span>        block_id <span class="token operator">=</span> block02<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  free 链表的前、后节点</span>        free_pre <span class="token operator">=</span> block01<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  未使用情况</span>        free_next <span class="token operator">=</span> block03<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  使用情况</span>        free_next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  flush 链表的前、后节点</span>        flush_pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        flush_next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  基础节点，数据页映射到缓存页，变更基础信息</span>    FreeLinkedListBaseNode    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  指向开始和结束节点指针</span>        start <span class="token operator">=</span> block01<span class="token punctuation">;</span>        end <span class="token operator">=</span> block03<span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  基础节点，缓存页更新过，当前节点就为脏节点</span>    FlushLinkedListBaseNode    <span class="token punctuation">{</span>        start <span class="token operator">=</span> block02<span class="token punctuation">;</span>        end <span class="token operator">=</span> block02<span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  冷热数据区划分等情况</span>    LRUBaseNode    <span class="token punctuation">{</span>        start    <span class="token punctuation">}</span>undo log 机制：事物回滚流程redo log 机制：由于事物提交后，并没有把事物更新的缓存页进行刷盘，很容易丢数据，同时也保证了 MySQL 高性能。所以在事物提交后，把对缓存页的修改以日志的形式写入 redo log，以保证修改的数据不丢失保证核心疑问点：把缓存页刷盘，跟你做的 redo log 都写入日志文件，都是磁盘操作，有什么差别？ A：二个方面来回答    <span class="token number">1</span>。刷盘方式        缓存页采用的是磁盘随机读写        类似 datafile<span class="token punctuation">.</span>locatexxx            datafile<span class="token punctuation">.</span>writexxxx        redo log 文件采用的是磁盘顺序写            引入 mmap 原理    <span class="token number">2</span>。磁盘IO，数据量的大小很关键        缓存页大小 16KB【有可能你只修改了缓存页里的几个<span class="token keyword">byte</span>，也要把整个缓存页都刷盘吗，浪费资源】        redo log 大小 521byte磁盘加载数据页 <span class="token operator">-</span><span class="token operator">></span> buffer pool <span class="token operator">-</span><span class="token operator">></span> 变更缓存页 <span class="token operator">-</span><span class="token operator">></span> 记录 undo log、redo logredo log 文件格式磁盘上存在若干个可以指定大小的 redo log 磁盘文件MySQL 进程内有一块 redo log buffer 缓存区域默认 16M，里面存放大量 redo log block对象<span class="token punctuation">(</span>一种复杂的数据结构<span class="token punctuation">)</span>redo log block<span class="token punctuation">{</span>       header 12byte    <span class="token punctuation">{</span>        块编号        写入数据长度        日志分组偏移量        checkpoint no    <span class="token punctuation">}</span>        body <span class="token number">496</span> <span class="token keyword">byte</span>    <span class="token punctuation">{</span>        日志类型 <span class="token operator">+</span> 表空间ID <span class="token operator">+</span> 缓存页号 <span class="token operator">+</span> 偏移量 <span class="token operator">+</span> 修改里几个字节值 <span class="token operator">+</span> 具体值    <span class="token punctuation">}</span>    trailer <span class="token number">4</span> <span class="token keyword">byte</span><span class="token punctuation">}</span></code></pre><h3 id="事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行"><a href="#事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行" class="headerlink" title="事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行"></a>事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行</h3><h3 id="多事务并发执行带来的问题"><a href="#多事务并发执行带来的问题" class="headerlink" title="多事务并发执行带来的问题"></a>多事务并发执行带来的问题</h3><p>脏读：读取到了其他事物更新过但未提交的数据<br>脏写：更新了其他事物更新过但未提交的数据<br>不可重复读：事物内对于同一共享变量，应该是可重复读的。不可重复读就是读取其他事物对同一共享变量修改过后并提交了事物的值<br>幻读：事物内查询到之前没有看到过的数据         </p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h5><table><thead><tr><th align="center">隔离级别/问题</th><th align="center">脏读/脏写</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">read uncommited</td><td align="center">V</td><td align="center">V</td><td align="center">V</td></tr><tr><td align="center">read commited</td><td align="center">X</td><td align="center">V</td><td align="center">V</td></tr><tr><td align="center">repeatable read</td><td align="center">X</td><td align="center">X</td><td align="center">V</td></tr><tr><td align="center">serializer read</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>原理：undoLog 多版本链条机制 + ReadView 视图机制</p><h4 id="MySQL-的-RR-如何实现避免幻读问题"><a href="#MySQL-的-RR-如何实现避免幻读问题" class="headerlink" title="MySQL 的 RR 如何实现避免幻读问题"></a>MySQL 的 RR 如何实现避免<code>幻读</code>问题</h4><p>RC：每次发起查询，都重新生成一个ReadView视图，每次查询都会更新 活跃事务id 列表，未在列表内且在最大事务id范围内的事务则是已提交事务</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id <span class="token operator">||</span> tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      可以读，数据的更新时间是在当前事务开启前就已经提交了    可以读，说明当前数据在生成 ReadView 之前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>RR：事务开启后，只会有一个 ReadView 视图，不会更新 活跃事务id 列表</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>  可以读，数据的更新时间是在当前事务开启前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      可以读，说明当前数据在生成 ReadView 之前就已经提交了  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="MVCC-和-隔离级别关系"><a href="#MVCC-和-隔离级别关系" class="headerlink" title="MVCC 和 隔离级别关系"></a>MVCC 和 隔离级别关系</h3><p>早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。</p><p>对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化。有的数据库内建乐观锁，但是有的没有（比如MySQL就没有），所以需要开发人员自己在数据表里加version列，自己写业务代码实现。</p><blockquote><p>顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度</p><p>如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p></blockquote><p>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是<strong>对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。</p><p>这样，实现两个隔离级别就非常容易：</p><ul><li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li><li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）</li></ul><p>也可以主动添加共享锁</p><ul><li>select…… lock in share mode</li></ul><p>MVCC并不是万灵药。大量的业务问题的关键点在于，<strong>你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效</strong>。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景</p><p>在这种场景下</p><ul><li>在MySQL InnoDB，使用者会使用<code>select ... for update</code>手工加锁。或者干脆用Serializable隔离级别</li></ul><h3 id="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"><a href="#锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题" class="headerlink" title="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"></a>锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题</h3><table><thead><tr><th align="center">锁类型</th><th align="center">独占锁</th><th align="center">共享锁</th></tr></thead><tbody><tr><td align="center">独占锁</td><td align="center">互斥</td><td align="center">互斥</td></tr><tr><td align="center">共享锁</td><td align="center">互斥</td><td align="center">不互斥</td></tr></tbody></table><p>基于MVCC的并发读，是不需要加锁，根据隔离级别选择读取对应的版本，但是也可以主动加读锁 - 共享锁</p><h3 id="undo-log-写入时机"><a href="#undo-log-写入时机" class="headerlink" title="undo log 写入时机"></a>undo log 写入时机</h3><p>![undo log 回滚日志的写入时机](/Users/jinhongcai/Desktop/mysql/undo log 回滚日志的写入时机.png)</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h2 id="锁的底层机制"><a href="#锁的底层机制" class="headerlink" title="锁的底层机制"></a>锁的底层机制</h2><h2 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h2><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>Buffer Pool（数据页 = 内存级别更新速度） 磁盘随机写</p><p>redo log 磁盘顺序写</p><p>undo log 磁盘顺序写</p><h2 id="查询优化的底层原理"><a href="#查询优化的底层原理" class="headerlink" title="查询优化的底层原理"></a>查询优化的底层原理</h2><h2 id="数据库的建模"><a href="#数据库的建模" class="headerlink" title="数据库的建模"></a>数据库的建模</h2><h2 id="在数据库建模的时候，应该如何注意字段类型"><a href="#在数据库建模的时候，应该如何注意字段类型" class="headerlink" title="在数据库建模的时候，应该如何注意字段类型"></a>在数据库建模的时候，应该如何注意字段类型</h2><h2 id="索引类型的一些问题"><a href="#索引类型的一些问题" class="headerlink" title="索引类型的一些问题"></a>索引类型的一些问题</h2><h2 id="如何保证数据库避免死锁、高性能的运行"><a href="#如何保证数据库避免死锁、高性能的运行" class="headerlink" title="如何保证数据库避免死锁、高性能的运行"></a>如何保证数据库避免死锁、高性能的运行</h2><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ol><li><p>必要性，sql 慢，分析具体是哪个步骤慢</p><ul><li>方法 show profile show processlist 晋级版本 - performance schema</li></ul></li><li><p>针对具体步骤进行优化，一般都是 执行阶段，执行阶段一般就是索引优化</p><ul><li>有没有索引</li><li>走没走索引</li></ul></li></ol><h3 id="类型优化"><a href="#类型优化" class="headerlink" title="类型优化"></a>类型优化</h3><p>越小越好</p><p>越简单越好</p><p>避免使用 NULL</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h5 id="数据库连接池有哪些？"><a href="#数据库连接池有哪些？" class="headerlink" title="数据库连接池有哪些？"></a>数据库连接池有哪些？</h5><p>DBCP</p><p>C3P0</p><p>druid</p><h5 id="索引是什么？如何实现？优缺点？用途？分类？技术点？"><a href="#索引是什么？如何实现？优缺点？用途？分类？技术点？" class="headerlink" title="索引是什么？如何实现？优缺点？用途？分类？技术点？"></a>索引是什么？如何实现？优缺点？用途？分类？技术点？</h5><pre class=" language-html"><code class="language-html">索引：一种特殊的数据结构实现1.文件操作 -> IO 操作、磁盘文件操作2.复杂的数据结构参考结构1.hash表2.二叉树3.AVL树4.read-black5.B Tree6.B+ Tree优点1.大大减少服务器扫描的数据量2.随机 IO -> 顺序 IO缺点1.增删改操作需要维护索引结构2.需要额外的空间来存储索引数据</code></pre><pre class=" language-html"><code class="language-html">用途1.where 子句2.排序和分组可以利用索引天然的顺序特性，加快查询效率3.可以使用 min max 函数</code></pre><table><thead><tr><th align="center">索引分类</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">主键</td><td align="center">主键列，值不为空</td></tr><tr><td align="center">唯一</td><td align="center">唯一列，值可以为空</td></tr><tr><td align="center">普通</td><td align="center">普通列</td></tr><tr><td align="center">联合</td><td align="center">多个普通列</td></tr><tr><td align="center">全文</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">技术点</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">回表</td><td align="center">非主键索引树，获取到主键后，再次进行主键索引树查询</td></tr><tr><td align="center">覆盖索引</td><td align="center">不进行回表的查询行为</td></tr><tr><td align="center">最左匹配</td><td align="center">联合索引，where 子句 条件顺序要满足 联合索引顺序，才可以走索引树</td></tr><tr><td align="center">索引下推</td><td align="center">联合索引下，在存储引擎内完成数据的检索</td></tr><tr><td align="center">索引合并</td><td align="center"></td></tr></tbody></table><p>mysql的三大引擎是啥？ 文件存储结构、索引类型、索引结构、事务、锁级别、使用场景<br>    mysql常用的引擎有InnoDB，MyISAM，Memory，默认是InnoDB<br>    InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引<br>    ps:优点：具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。<br>    缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大</p><pre><code>MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引ps: 优点：占用空间小，处理速度快（相对InnoDB来说）缺点：不支持事务的完整性和并发性MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型ps: 优点：速度要求快的，临时数据缺点：丢失数据myisam读的效果好，写的效率差，这和它数据存储格式，索引的指针和锁的策略有关的，它的数据是顺序存储的，他的索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快innodb支持行锁，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，仍然会锁定表,mysql的读写之间是可以并发的普通的select是不需要锁的，当查询的记录遇到锁时，用的是一致性的非锁定快照读，也就是根据数据库隔离级别策略，会去读被锁定行的快照，其它更新或加锁读语句用的是当前读，读取原始行因为普通读与写不冲突，所以innodb不会出现读写饿死的情况，又因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低</code></pre><p>innodb对一行数据的读会加锁吗<br>    早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。<br>    对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化，所以需要开发人员自己在数据表里加version列，自己写业务代码实现。<br>    顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度<br>        如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p><pre><code>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。这样，实现两个隔离级别就非常容易：Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）也可以主动添加共享锁select…… lock in share modeMVCC并不是万灵药。大量的业务问题的关键点在于，你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景在这种场景下，在MySQL InnoDB，使用者会使用select ... for update手工加锁。或者干脆用Serializable隔离级别</code></pre><p>mysql是如何实现事务的<br>    undo log 回滚日志<br>    redo log 重做日志</p><p>MySQL事务特性和隔离级别<br>    ACID<br>    RR<br>    RU<br>    RC<br>    S</p><p>mysql的默认隔离级别<br>    RR</p><p>mysql的binlog<br>    主从复制也需要依靠binlog</p><pre><code>binlog 存在于Mysql Server层中，主要用于数据恢复；当数据被误删时，可以通过上一次的全量备份数据加上某段时间的binlog将数据恢复到指定的某个时间点的数据。redo log 存在于InnoDB 引擎中，InnoDB引擎是以插件形式引入Mysql的，redo log的引入主要是为了实现Mysql的crash-safe能力。statement：statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.row：row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter able),因此这种模式的文件保存的信息太多,日志量太大.mixed：mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</code></pre><p>主从复制<br>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式</p><p>索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；<br>聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。<br>聚簇索引：有主键时，根据主键创建聚簇索引<br>        没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>        如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引</p><p>非聚簇索引：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引</p><p>B+树和B树区别？<br>B树的非叶子节点存储实际记录的指针，而B+树的叶子节点存储实际记录的指针<br>B+树的叶子节点通过指针连起来了, 适合扫描区间和顺序查找。</p><p>查看 SQL 是不是使用了索引？<br>    执行计划</p><p>mysql的级锁加在哪个位置<br>表级：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许<br>行级：仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。<br>页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>索引的类型<br>    主键<br>    唯一<br>    普通<br>    联合<br>    全文</p><p>redo log的概念是什么？为什么会存在？<br>    在思考这个问题之前，我们可以先看看MySQL INNODB执行一条update语句的流程<br>    1.将数据所在的数据页加载到BufferPool对应的缓存页(事务开始)<br>    2.将数据的旧值写入到undolog中<br>    3.更新数据在BufferPool中的值<br>    4.写redolog日志<br>    5.写binlog归档日志<br>    6.事务提交，在redolog中写commit标记<br>    7.数据会在之后的某个时刻刷入硬盘中的数据页<br>    redolog其实就是上面第四步的操作，他记录的是数据修改之后的值，他的意义在于，当我们事务提交之后但bufferpool中修改后的数据还没有刷入磁盘的时候机器宕机了，那么我们就可以根据redolog中的日志来恢复内存中的数据</p><p>那为什么不直接在提交事务的将修改的数据刷入硬盘？<br>    原因有以下几点：<br>    1.数据在内存中修改的数据很快，但磁盘随机写很慢<br>    2.数据在磁盘和内存中是以页为单位的，默认是16kb，假如你就改了一天数据的某个属性就需要将这一整个数据页刷入硬盘，效率很低。而redolog就快很多，首先他不是随机在磁盘写    ，而是通过追加的方式写入redolog文件，速度快很多，然后他也不是直接往硬盘中的redolog文件写，而是先写入redologbuffer（默认大小16mb）中的redologblock（默认大小512字节）这个内存结构中，首先往redologbuffer中写的很快，然后会在极短时间内以redolog block为单位刷入到磁盘，这样的话性能就会很高</p><pre><code>redolog刷盘点 - page cache，由操作系统保证数据可靠性    1.写满8M    2.事务commit</code></pre><p>什么是WAL机制？好处是什么？<br>    (1).将redo log写入到buffer中的block中<br>    (2).调用写磁盘操作,这一步将redo log buffer中的 block 日志写到操作系统中的page cache里面。<br>    (3).调用os的fsync操作,将page cache中的redolog日志落盘,落盘之后数据便在磁盘上了</p><pre><code>上面就是WAL机制在redo log刷盘过程中的具体实现,其实我的理解就是将日志先写到内存中,然后某个时间在刷入磁盘,日志异步落盘。其实把数据从内存写入到磁盘看似就一个操作(1).从磁盘随机写变成顺序写,性能提升巨大(2).组提交,上面redolog的执行步骤第三步,调用fsync可以同时将多次第二步write操作写入到pagecache的数据一批落盘,这样的话就大量的减少了iops,减少磁盘压力</code></pre><p>redo log为什么能保证crash safe机制？<br>    MySQL通过两阶段提交的方式来保证CrashSafe。CrashSafe需要Server层、Binlog和InnoDB的协同工作才能完成。由于DDL和MyISAM不支持事务性，因此没办法保证CrashSafe</p><p>redo log和bin log 不同点有哪些？<br>    Redo Log是属于InnoDB引擎功能;Binlog是属于MySQL Server自带功能，所有引擎都可以使用，并且是以二进制文件记录。<br>    Redo Log属于物理日志，记录该数据页更新状态内容;Binlog是逻辑日志，记录更新操作语句的原始逻辑。<br>    Redo Log日志是循环写，日志空间大小是固定;Binlog是追加写入，写完一个写下一个，不会覆盖使用。<br>    Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力</p><p>什么是两阶段提交？为什么需要两阶段提交？两阶段提交如何保证数据库中两份日志间的逻辑一致性？<br>执行器在执行update语句时候的流程是什么样子的？<br>如果不是两阶段提交，先写binlog和先写redolog两种场景，各会遇到什么问题？<br>如何使用缓冲实现惰性B树？</p><p>Q：mysql对于千万级的大表如何优化？<br>很多人第一反应是各种切分；<br>我给的顺序是:<br>第一优化你的sql和索引；<br>第二加缓存，memcached,redis；<br>第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；<br>第四如果以上都做了还是慢，不要想着去做切分，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；<br>第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；<br>第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的shardingkey,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p><p>有人也许要说第一步优化sql和索引这还用说吗？的确，大家都知道，但是很多情况下，这一步做的并不到位，甚至有的只做了根据sql去建索引，根本没对sql优化（中枪了没？），除了最简单的增删改查外，想实现一个查询，可以写出很多种查询语句，不同的语句，根据你选择的引擎、表中数据的分布情况、索引情况、数据库优化策略、查询中的锁策略等因素，最终查询的效率相差很大；优化要从整体去考虑，有时你优化一条语句后，其它查询反而效率被降低了，所以要取一个平衡点；即使精通mysql的话，除了纯技术面优化，还要根据业务面去优化sql语句，这样才能达到最优效果</p><p>mysql怎么实现redo log和binlog的一致性<br>    伪2pc分布式事务</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/2021/01/30/Dubbo/"/>
      <url>/2021/01/30/Dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="概念：高性能-java-RPC框架"><a href="#概念：高性能-java-RPC框架" class="headerlink" title="概念：高性能 java RPC框架"></a>概念：高性能 java RPC框架</h3><h3 id="第一部分：功能特性"><a href="#第一部分：功能特性" class="headerlink" title="第一部分：功能特性"></a>第一部分：功能特性</h3><p>面向接口代理的高性能RPC调用</p><p>服务自动注册与发现</p><p>智能负载均衡</p><p>运行期流量调度</p><p>高扩展性</p><p>可视化的服务治理与运维</p><h3 id="第二部分：高级特性"><a href="#第二部分：高级特性" class="headerlink" title="第二部分：高级特性"></a>第二部分：高级特性</h3><h5 id="SPI（Service-Provider-Interface）"><a href="#SPI（Service-Provider-Interface）" class="headerlink" title="SPI（Service Provider Interface）"></a>SPI（Service Provider Interface）</h5><p>JDK 内置的一种服务提供发现机制。简单来说就是一种动态替换发现的机制。</p><p>优点：实现解耦</p><p>Dubbo SPI Adaptive ：动态选择扩展点</p><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><h5 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h5><h5 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h5><h5 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h5><h5 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h5><h3 id="第三部分：整体设计"><a href="#第三部分：整体设计" class="headerlink" title="第三部分：整体设计"></a>第三部分：整体设计</h3><p><img src="http://lion-heart.online/blog/2021-01-31-065444.png" alt=""></p><p><img src="http://lion-heart.online/blog/2021-02-06-063854.png" alt="整体调用链路"></p><p>business ：业务服务层，属于API级别，其他层均为SPI</p><ul><li>service： 接口和实现类 </li></ul><p>rpc：远程过程调用层</p><ul><li>config配置层：对外提供配置，以serviceConfig和ReferenceConfig为核心，可以直接初始化配置类，也可以解析配置文件生成</li><li>proxy服务代理层：无论是生产、消费 框架都会产生一个代理类，整个过程对上层透明，就是业务层对代理无感</li><li>register注册中心层：封装服务地址，以服务的URL为中心进行注册和发现</li><li>cluster路由层（集群容错层）：提供服务提供者的路由和负载均衡，并且桥接注册中心，以Invoker为核心</li><li>monitor监控层：调用信息，包含调用次数、时间等信息</li><li>protocol协议层：封装RPC调用，无论是服务的暴露还是服务引用都是在protocol中作为主入口负责invoker的整个生命周期</li></ul><p>Remoting：远程数据传输层</p><ul><li>exchange：信息交换层，封装请求和影响的模式，例如：请求由同步转化成异步</li><li>transport：网路传输层，统一网络传输的接口，例如：netty和mina统一为一个网络传输接口</li><li>serialize：序列化层</li></ul><h3 id="第四部分：源码分析"><a href="#第四部分：源码分析" class="headerlink" title="第四部分：源码分析"></a>第四部分：源码分析</h3><h4 id="一、服务自动注册、发现源码分析"><a href="#一、服务自动注册、发现源码分析" class="headerlink" title="一、服务自动注册、发现源码分析"></a>一、服务自动注册、发现源码分析</h4><h5 id="注册中心结构"><a href="#注册中心结构" class="headerlink" title="注册中心结构"></a>注册中心结构</h5><p>注册中心是Dubbo的重要组成部分，主要用于服务的注册与发现，我们可以选择Redis、Nacos、</p><p>Zookeeper作为Dubbo的注册中心，Dubbo推荐用户使用Zookeeper作为注册中心</p><p><img src="http://lion-heart.online/blog/2021-02-06-130450.png" alt="image-20210206210447614"></p><p>可以在这里看到所有的都是在dubbo层级下的</p><p>dubbo跟节点下面是当前所拥有的接口名称，如果有多个接口，则会以多个子节点的形式展开</p><p>每个服务下面又分别有四个配置项</p><p>consumers: 当前服务下面所有的消费者列表(URL)</p><p>providers: 当前服务下面所有的提供者列表(URL)</p><p>confifiguration: 当前服务下面的配置信息信息，provider或者consumer会通过读取这里的配</p><p>置信息来获取配置</p><p>routers: 当消费者在进行获取提供者的时，会通过这里配置好的路由来进行适配匹配规则。</p><p>可以看到，dubbo基本上很多时候都是通过URL的形式来进行交互获取数据的，在URL中也会保存</p><p>  很多的信息。后面也会对URL的规则做详细介绍。</p><p><img src="http://lion-heart.online/blog/2021-02-06-094214.png" alt="注册中心使用原理"></p><h5 id="URL规则解析："><a href="#URL规则解析：" class="headerlink" title="URL规则解析："></a>URL规则解析：</h5><p>URL地址：protocol://host:port/path(接口地址)?key=value&amp;key=value</p><ul><li>protocol：协议，框架本身、provider、consumer、register等都有具体协议</li><li>host：地址，提供协议的具体地址</li><li>port：端口号</li><li><ul><li>host + port = 一个具体的服务进程</li></ul></li><li>path：服务路径，接口地址</li><li>key = value ：具体参数，理解为地址配置</li></ul><p>dubbo://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806</p><p>registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-test-provider&amp;dubbo=2.0.2&amp;owner=jhc&amp;pid=27449&amp;registry=zookeeper&amp;release=2.7.5&amp;timeout=10000&amp;timestamp=1612616206806</p><h5 id="服务本地缓存："><a href="#服务本地缓存：" class="headerlink" title="服务本地缓存："></a>服务本地缓存：</h5><p>服务消费者需要通过注册中心获取提供者，但是如果频繁往从ZK获取信息，肯定会存在单点故障问题，所以dubbo提供了将提供者信息缓存在本地的方法。</p><p>消费者在订阅注册中心的回调处理逻辑当中会保存服务提供者信息到本地缓存文件当中（同步/异步两种方式），以URL纬度进行全量保存。</p><p>消费者进程会在服务引用（使用服务提供者具体服务）过程中会创建registry对象并加载本地缓存文件，会优先订阅注册中心，订阅注册中心失败后会访问本地缓存文件内容获取服务提供信息。</p><h5 id="服务注册流程："><a href="#服务注册流程：" class="headerlink" title="服务注册流程："></a>服务注册流程：</h5><p><img src="http://lion-heart.online/blog/2021-02-07-030801.png" alt="服务注册过程"></p><pre class=" language-java"><code class="language-java">spirng容器启动完毕，最后一步发布相应事件  包含了dubbo的start流程  <span class="token number">1</span><span class="token punctuation">.</span> export Dubbo Services          <span class="token number">0</span><span class="token punctuation">.</span>配置文件解析          dubbo<span class="token operator">-</span>provider<span class="token punctuation">.</span>xml 解析为框架实体            <span class="token number">1</span><span class="token punctuation">.</span>service <span class="token operator">-</span> invoker           ServiceConfig类包含          ref（服务实现类）          PROXY_FACTORY（代理工厂）            Invoker<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> invoker <span class="token operator">=</span> PROXY_FACTORY<span class="token punctuation">.</span><span class="token function">getInvoker</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>         interfaceClass<span class="token punctuation">,</span> registryURL<span class="token punctuation">.</span><span class="token function">addParameterAndEncoded</span><span class="token punctuation">(</span>EXPORT_KEY<span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">toFullString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            到这里完成了 service 到 Invoker 的转化            <span class="token number">2</span><span class="token punctuation">.</span> Invoker <span class="token operator">-</span> Exporter           <span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Exporter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">export</span><span class="token punctuation">(</span><span class="token keyword">final</span> Invoker<span class="token operator">&lt;</span>T<span class="token operator">></span> originInvoker<span class="token punctuation">)</span>获取具体的注册中心，进行服务注册。zkClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token function">toUrlPath</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">,</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>DYNAMIC_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token number">2</span><span class="token punctuation">.</span> export MetadataService  <span class="token number">3</span><span class="token punctuation">.</span> Register the local ServiceInstance <span class="token keyword">if</span> required</code></pre><p><img src="http://lion-heart.online/blog/2021-02-07-034547.png" alt="image-20210207114547098"></p><p><img src="http://lion-heart.online/blog/2021-02-07-120325.png" alt="image-20210207200322039"></p><h5 id="整体目录结构如下：注册中心目录（工厂-模版-包装）"><a href="#整体目录结构如下：注册中心目录（工厂-模版-包装）" class="headerlink" title="整体目录结构如下：注册中心目录（工厂+模版+包装）"></a>整体目录结构如下：注册中心目录（工厂+模版+包装）</h5><p><img src="http://lion-heart.online/blog/2021-02-07-043657.png" alt="image-20210207123654587"></p><h5 id="服务注册完整流程："><a href="#服务注册完整流程：" class="headerlink" title="服务注册完整流程："></a>服务注册完整流程：</h5><p>20:56:41.497 [main] INFO  org.apache.dubbo.config.ServiceConfig.exportLocal(ServiceConfig.java:509) -  [DUBBO] Export dubbo service org.jinhc.dubbo.service.TestService to local registry url : injvm://127.0.0.1/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:41.498 [main] INFO  org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:455) -  [DUBBO] Register dubbo service org.jinhc.dubbo.service.TestService url dubbo://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446 to registry registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-test-provider&amp;dubbo=2.0.2&amp;owner=jhc&amp;pid=27449&amp;registry=zookeeper&amp;release=2.7.5&amp;timeout=10000&amp;timestamp=1612616191435, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:46.716 [main] INFO  org.apache.dubbo.remoting.transport.AbstractServer.<init>(AbstractServer.java:73) -  [DUBBO] Start NettyServer bind /0.0.0.0:20883, export /192.168.31.54:20883, dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:46.728 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.loadProperties(AbstractRegistry.java:217) -  [DUBBO] Load registry cache file /Users/jinhongcai/.dubbo/dubbo-registry-dubbo-test-provider-127.0.0.1-2181.cache, data: {org.jinhc.dubbo.service.TestService=empty://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=26828&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612615642883, org.jinhc.dubbo.service.HelloService=empty://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=26828&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612615653225}, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:46.729 [main] INFO  org.apache.dubbo.remoting.zookeeper.ZookeeperTransporter.connect(AbstractZookeeperTransporter.java:58) -  [DUBBO] find valid zookeeper client from the cache for address: zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-test-provider&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.registry.RegistryService&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;timeout=10000&amp;timestamp=1612616191435, dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:46.732 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.register(AbstractRegistry.java:285) -  [DUBBO] Register: dubbo://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:46.745 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.subscribe(AbstractRegistry.java:310) -  [DUBBO] Subscribe: provider://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:46.750 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.notify(AbstractRegistry.java:404) -  [DUBBO] Notify urls for subscribe url provider://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446, urls: [empty://192.168.31.54:20883/org.jinhc.dubbo.service.TestService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.TestService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616196446], dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:46.803 [main] INFO  org.apache.dubbo.metadata.DynamicConfigurationServiceNameMapping.lambda$map$0(DynamicConfigurationServiceNameMapping.java:61) -  [DUBBO] Dubbo service[null] mapped to interface name[org.jinhc.dubbo.service.TestService]., dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:46.812 [main] INFO  org.apache.dubbo.config.ServiceConfig.findConfigedHosts(ServiceConfig.java:552) -  [DUBBO] No valid ip found from environment, try to find valid host from DNS., dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:51.819 [main] INFO  org.apache.dubbo.config.ServiceConfig.exportLocal(ServiceConfig.java:509) -  [DUBBO] Export dubbo service org.jinhc.dubbo.service.HelloService to local registry url : injvm://127.0.0.1/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:51.820 [main] INFO  org.apache.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:455) -  [DUBBO] Register dubbo service org.jinhc.dubbo.service.HelloService url dubbo://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806 to registry registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-test-provider&amp;dubbo=2.0.2&amp;owner=jhc&amp;pid=27449&amp;registry=zookeeper&amp;release=2.7.5&amp;timeout=10000&amp;timestamp=1612616206806, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:51.822 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.register(AbstractRegistry.java:285) -  [DUBBO] Register: dubbo://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:51.825 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.subscribe(AbstractRegistry.java:310) -  [DUBBO] Subscribe: provider://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806, dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:51.828 [main] INFO  org.apache.dubbo.registry.zookeeper.ZookeeperRegistry.notify(AbstractRegistry.java:404) -  [DUBBO] Notify urls for subscribe url provider://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806, urls: [empty://192.168.31.54:20883/org.jinhc.dubbo.service.HelloService?anyhost=true&amp;application=dubbo-test-provider&amp;bind.ip=192.168.31.54&amp;bind.port=20883&amp;category=configurators&amp;check=false&amp;deprecated=false&amp;dubbo=2.0.2&amp;dynamic=true&amp;generic=false&amp;interface=org.jinhc.dubbo.service.HelloService&amp;methods=sayHello&amp;owner=jhc&amp;pid=27449&amp;release=2.7.5&amp;side=provider&amp;timestamp=1612616206806], dubbo version: 2.7.5, current host: 192.168.31.54</p><p>20:56:51.835 [main] INFO  org.apache.dubbo.metadata.DynamicConfigurationServiceNameMapping.lambda$map$0(DynamicConfigurationServiceNameMapping.java:61) -  [DUBBO] Dubbo service[null] mapped to interface name[org.jinhc.dubbo.service.HelloService]., dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:51.840 [main] INFO  org.apache.dubbo.config.bootstrap.DubboBootstrap.start(DubboBootstrap.java:716) -  [DUBBO] DubboBootstrap has started., dubbo version: 2.7.5, current host: 192.168.31.54<br>20:56:51.902 [NettyServerWorker-5-1] INFO  org.apache.dubbo.remoting.transport.netty4.NettyServerHandler.channelActive(NettyServerHandler.java:76) -  [DUBBO] The connection of /192.168.31.54:53319 -&gt; /192.168.31.54:20883 is established., dubbo version: 2.7.5, current host: 192.168.31.54</p><h5 id="服务发现流程："><a href="#服务发现流程：" class="headerlink" title="服务发现流程："></a>服务发现流程：</h5><p><img src="http://lion-heart.online/blog/2021-02-08-054048.png" alt="image-20210208134043968"></p><p>首先 ReferenceConfig 类的 init 方法调用 createProxy() ,期间 使用 Protocol 调用 refer 方法生</p><p>成 Invoker 实例(如上图中的红色部分)，这是服务消费的关键。接下来使用ProxyFactory把 Invoker转换为客户端需要的接口(如：HelloService)。 </p><h4 id="二、集群智能容错源码分析"><a href="#二、集群智能容错源码分析" class="headerlink" title="二、集群智能容错源码分析"></a>二、集群智能容错源码分析</h4><p><img src="http://lion-heart.online/blog/2021-02-08-134601.png" alt="image-20210208214600487"></p><p>集群工作过程可分为两个阶段</p><ul><li>第一个阶段是在<strong>服务消费者初始化</strong>期间，集群 Cluster 实现类为<strong>服务消费者创建 Cluster Invoker 实例</strong>，即上图中的 merge 操作。</li><li>第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker列表，可简单类比为 List。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker实例的 invoke 方法，进行真正的远程调用。</li></ul><p>Dubbo 主要提供了这样几种容错方式：</p><ul><li>Failover Cluster - 失败自动切换 失败时会重试其它服务器</li><li>Failfast Cluster - 快速失败 请求失败后快速返回异常结果 不重试</li><li>Failsafe Cluster - 失败安全 出现异常 直接忽略 会对请求做负载均衡</li><li>Failback Cluster - 失败自动恢复 请求失败后 会自动记录请求到失败队列中</li><li>Forking Cluster - 并行调用多个服务提供者 其中有一个返回 则立即返回结果</li></ul><h5 id="Directory：缓存当前可以被调用的提供者列表信息接口"><a href="#Directory：缓存当前可以被调用的提供者列表信息接口" class="headerlink" title="Directory：缓存当前可以被调用的提供者列表信息接口"></a>Directory：缓存当前可以被调用的提供者列表信息接口</h5><pre class=" language-java"><code class="language-java">第一步：查看类接口和主要方法<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Directory</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 获取服务的类型,也就是我们demo中所使用的HelloService</span>  Class<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 根据本次调用的信息来获取所有可以被执行的提供者信息</span>  List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">list</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> RpcException<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 获取所有的提供者信息 </span>  List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">getAllInvokers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>第二步：消费者进行调用时都会通过这个接口来获取所有的提供者列表<span class="token keyword">public</span> List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">doList</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 当没有提供者的时候会直接抛出异常 </span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>forbidden<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 1. No service provider 2. Service providers are disabled </span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> invokers <span class="token operator">=</span> null<span class="token punctuation">;</span>   <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 交给路由chain去处理并且获取所有的invokers </span>    invokers <span class="token operator">=</span> routerChain<span class="token punctuation">.</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token function">getConsumerUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Failed to execute router: "</span> <span class="token operator">+</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", cause: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">return</span> invokers <span class="token operator">==</span> null <span class="token operator">?</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> invokers<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Invoker<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">doRefer</span><span class="token punctuation">(</span>Cluster cluster<span class="token punctuation">,</span> Registry registry<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">,</span> URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//    创建注册中心目录实现类</span>    RegistryDirectory<span class="token operator">&lt;</span>T<span class="token operator">></span> directory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RegistryDirectory</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    设置注册中心</span>    directory<span class="token punctuation">.</span><span class="token function">setRegistry</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//    设置协议</span>    directory<span class="token punctuation">.</span><span class="token function">setProtocol</span><span class="token punctuation">(</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// all attributes of REFER_KEY</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> parameters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>directory<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//    生成监听路径URL</span>    URL subscribeUrl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span>CONSUMER_PROTOCOL<span class="token punctuation">,</span> parameters<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>REGISTER_IP_KEY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> parameters<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ANY_VALUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>url<span class="token punctuation">.</span><span class="token function">getServiceInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span>REGISTER_KEY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置监听的consumerurl地址</span>directory<span class="token punctuation">.</span><span class="token function">setRegisteredConsumerUrl</span><span class="token punctuation">(</span><span class="token function">getRegisteredConsumerUrl</span><span class="token punctuation">(</span>subscribeUrl<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//    设置注册中心消费者地址</span>        registry<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>directory<span class="token punctuation">.</span><span class="token function">getRegisteredConsumerUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//    构建 路由chain</span>    directory<span class="token punctuation">.</span><span class="token function">buildRouterChain</span><span class="token punctuation">(</span>subscribeUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//    进行监听所有的provider</span>    directory<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>subscribeUrl<span class="token punctuation">.</span><span class="token function">addParameter</span><span class="token punctuation">(</span>CATEGORY_KEY<span class="token punctuation">,</span>            PROVIDERS_CATEGORY <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> CONFIGURATORS_CATEGORY <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> ROUTERS_CATEGORY<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 加入到集群中</span>    Invoker invoker <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>directory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> invoker<span class="token punctuation">;</span></code></pre><h5 id="路由规则："><a href="#路由规则：" class="headerlink" title="路由规则："></a>路由规则：</h5><h4 id="三、负载均衡源码分析"><a href="#三、负载均衡源码分析" class="headerlink" title="三、负载均衡源码分析"></a>三、负载均衡源码分析</h4><h5 id="LoadBalance入口分析"><a href="#LoadBalance入口分析" class="headerlink" title="LoadBalance入口分析"></a>LoadBalance入口分析</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 初始化 负载均衡组件或规则 * 如果invokers不是空的，则从第一个调用的url和调用初始化 * 如果invokes为空，初始化一个默认的LoadBalance(RandomLoadBalance) */</span><span class="token keyword">protected</span> LoadBalance <span class="token function">initLoadBalance</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> invokers<span class="token punctuation">,</span> Invocation invocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>invokers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token comment" spellcheck="true">//    第一个invoker的url获取loadbalance，默认为random</span>        <span class="token keyword">return</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>LoadBalance<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>invokers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">getMethodParameter</span><span class="token punctuation">(</span>RpcUtils<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">,</span> LOADBALANCE_KEY<span class="token punctuation">,</span> DEFAULT_LOADBALANCE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//    如果为空，使用random</span>        <span class="token keyword">return</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>LoadBalance<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>DEFAULT_LOADBALANCE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token punctuation">(</span>RandomLoadBalance<span class="token punctuation">.</span>NAME<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoadBalance</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * select one invoker in list.     *     * @param invokers   invokers.     * @param url        refer url     * @param invocation invocation.     * @return selected invoker.     */</span>    <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token string">"loadbalance"</span><span class="token punctuation">)</span>    <span class="token operator">&lt;</span>T<span class="token operator">></span> Invoker<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">select</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Invoker<span class="token operator">&lt;</span>T<span class="token operator">>></span> invokers<span class="token punctuation">,</span> URL url<span class="token punctuation">,</span> Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> RpcException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="Invoker执行逻辑"><a href="#Invoker执行逻辑" class="headerlink" title="Invoker执行逻辑"></a>Invoker执行逻辑</h3><h5 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Invoker</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * get service interface.     *     * @return service interface.     */</span>    Class<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * invoke.     *     * @param invocation     * @return result     * @throws RpcException     */</span>    Result <span class="token function">invoke</span><span class="token punctuation">(</span>Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> RpcException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="设计模式：模版-策略"><a href="#设计模式：模版-策略" class="headerlink" title="设计模式：模版 + 策略"></a>设计模式：模版 + 策略</h5><h5 id="核心逻辑：ExchangeChannel-依赖-netty"><a href="#核心逻辑：ExchangeChannel-依赖-netty" class="headerlink" title="核心逻辑：ExchangeChannel 依赖 netty"></a>核心逻辑：ExchangeChannel 依赖 netty</h5><p><img src="http://lion-heart.online/blog/2021-02-09-134324.png" alt="image-20210209214320920"></p><h4 id="四、网络通讯原理分析"><a href="#四、网络通讯原理分析" class="headerlink" title="四、网络通讯原理分析"></a>四、网络通讯原理分析</h4><h5 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h5><p>请求都是基于TCP的，协议采用固定长度的消息头（16字节）和不定长度的消息体来进行数据传输，消息头定义了底层框架（netty）在IO线程处理时需要的信息，协议的报文格式如下：</p><p><img src="http://lion-heart.online/blog/2021-02-09-111157.png" alt="image-20210209191157522"></p><h5 id="数据协议ExchangeCodec类：交换编解码器，数据需要通过当前组件进行收、发行为"><a href="#数据协议ExchangeCodec类：交换编解码器，数据需要通过当前组件进行收、发行为" class="headerlink" title="数据协议ExchangeCodec类：交换编解码器，数据需要通过当前组件进行收、发行为"></a>数据协议ExchangeCodec类：交换编解码器，数据需要通过当前组件进行收、发行为</h5><p>这个类中 encode 和 decode 分别用于将对象数据发送到 ByteBuffer 中，还有就是将其反向的转换为对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">encode</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ChannelBuffer buffer<span class="token punctuation">,</span> Object msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">Request</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">encodeRequest</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span>Request<span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">Response</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">encodeResponse</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span>Response<span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Object <span class="token function">decode</span><span class="token punctuation">(</span>Channel channel<span class="token punctuation">,</span> ChannelBuffer buffer<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> readable <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> header <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>readable<span class="token punctuation">,</span> HEADER_LENGTH<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">.</span><span class="token function">readBytes</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">decode</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> readable<span class="token punctuation">,</span> header<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="处理粘包、拆包问题"><a href="#处理粘包、拆包问题" class="headerlink" title="处理粘包、拆包问题"></a>处理粘包、拆包问题</h5><h4 id="五、SPI-源码分析"><a href="#五、SPI-源码分析" class="headerlink" title="五、SPI 源码分析"></a>五、SPI 源码分析</h4><p>ExtensitonLoader类，它是SPI的入口</p><p>主要方法</p><ul><li>getExtensionLoader：获取类加载器，用于加载所有扩展点实现</li><li>getExtension：根据name获取指定扩展实现</li></ul><h5 id="getExtenstionLoader方法核心逻辑"><a href="#getExtenstionLoader方法核心逻辑" class="headerlink" title="getExtenstionLoader方法核心逻辑"></a>getExtenstionLoader方法核心逻辑</h5><pre class=" language-java"><code class="language-java">第一步：获取指定类型的扩展加载器<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ExtensionLoader<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>ExtensionLoader<span class="token operator">&lt;</span>T<span class="token operator">></span> loader <span class="token operator">=</span> <span class="token punctuation">(</span>ExtensionLoader<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>loader <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ExtensionLoader</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        loader <span class="token operator">=</span> <span class="token punctuation">(</span>ExtensionLoader<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> EXTENSION_LOADERS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> loader<span class="token punctuation">;</span>第二步：加载ExtensionFactory默认扩展实现<span class="token keyword">private</span> <span class="token function">ExtensionLoader</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>        objectFactory <span class="token operator">=</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> ExtensionFactory<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">?</span> null <span class="token operator">:</span>              ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>ExtensionFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>第三步：加载指定类型的SPI实现<span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token function">loadExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">cacheDefaultExtensionName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> extensionClasses <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// internal extension load from ExtensionLoader's ClassLoader first</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_INTERNAL_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_INTERNAL_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> DUBBO_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> SERVICES_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">loadDirectory</span><span class="token punctuation">(</span>extensionClasses<span class="token punctuation">,</span> SERVICES_DIRECTORY<span class="token punctuation">,</span> type<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"org.apache"</span><span class="token punctuation">,</span> <span class="token string">"com.alibaba"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> extensionClasses<span class="token punctuation">;</span><span class="token punctuation">}</span>总结：通过当前方法加载配置文件中配置的key <span class="token operator">-</span> value保存到指定容器内</code></pre><h5 id="getExtension方法核心逻辑"><a href="#getExtension方法核心逻辑" class="headerlink" title="getExtension方法核心逻辑"></a>getExtension方法核心逻辑</h5><pre class=" language-java"><code class="language-java">第一步：获取扩展实现<span class="token keyword">public</span> T <span class="token function">getExtension</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//    Holder思想：封装引用，用于线程安全的创建实例</span>    <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>Object<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token function">getOrCreateHolder</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//    双重验证方式保证线程安全</span>    Object instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>holder<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> holder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                instance <span class="token operator">=</span> <span class="token function">createExtension</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                holder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span>第二步：创建扩展实现实例<span class="token keyword">private</span> T <span class="token function">createExtension</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//    通过extensionLoader方法已经缓存了指定SPI的所有扩展实现，直接获取即可</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> <span class="token function">getExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>clazz <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token function">findException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//    反射进行对象实例化行为</span>            T instance <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">putIfAbsent</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                instance <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> EXTENSION_INSTANCES<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//    依赖注入</span>            <span class="token function">injectExtension</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> wrapperClasses <span class="token operator">=</span> cachedWrapperClasses<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>wrapperClasses<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> wrapperClass <span class="token operator">:</span> wrapperClasses<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token function">injectExtension</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> wrapperClass<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>              <span class="token comment" spellcheck="true">//    初始化行为</span>            <span class="token function">initExtension</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Extension instance (name: "</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">", class: "</span> <span class="token operator">+</span>                    type <span class="token operator">+</span> <span class="token string">") couldn't be instantiated: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="getAdapativeExtension方法核心逻辑"><a href="#getAdapativeExtension方法核心逻辑" class="headerlink" title="getAdapativeExtension方法核心逻辑"></a>getAdapativeExtension方法核心逻辑</h5><pre class=" language-java"><code class="language-java">第一步：获取目标类<span class="token keyword">public</span> T <span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//    Holder思想，保证线程安全创建实例</span>    Object instance <span class="token operator">=</span> cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//    异常</span>    <span class="token punctuation">}</span>  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>cachedAdaptiveInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>    instance <span class="token operator">=</span> cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token function">createAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cachedAdaptiveInstance<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        createAdaptiveInstanceError <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Failed to create adaptive instance: "</span> <span class="token operator">+</span> t<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> instance<span class="token punctuation">;</span><span class="token punctuation">}</span>第二步：获取目标类 <span class="token keyword">private</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">getExtensionClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>cachedAdaptiveClass <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> cachedAdaptiveClass<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> cachedAdaptiveClass <span class="token operator">=</span> <span class="token function">createAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>第三步：创建Adapative Extension 类<span class="token keyword">private</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">createAdaptiveExtensionClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//    实例化一个新的Adapative的代码生成器 字符串格式</span>        String code <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AdaptiveClassCodeGenerator</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> cachedDefaultName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    获取类加载器</span>        ClassLoader classLoader <span class="token operator">=</span> <span class="token function">findClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    通过SPI寻找Java自带编译器、Javassist编译器</span>        org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>Compiler compiler <span class="token operator">=</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>Compiler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAdaptiveExtension</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    编译生成class</span>        <span class="token keyword">return</span> compiler<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> classLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>personal-project</title>
      <link href="/2021/01/24/personal-project/"/>
      <url>/2021/01/24/personal-project/</url>
      
        <content type="html"><![CDATA[<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><h4 id="登陆模块"><a href="#登陆模块" class="headerlink" title="登陆模块"></a>登陆模块</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h2 id="权限模块"><a href="#权限模块" class="headerlink" title="权限模块"></a>权限模块</h2><h4 id="用户表"><a href="#用户表" class="headerlink" title="用户表"></a>用户表</h4><h4 id="角色表"><a href="#角色表" class="headerlink" title="角色表"></a>角色表</h4><h4 id="权限功能表"><a href="#权限功能表" class="headerlink" title="权限功能表"></a>权限功能表</h4><h4 id="用户角色关联表"><a href="#用户角色关联表" class="headerlink" title="用户角色关联表"></a>用户角色关联表</h4><h4 id="角色权限功能关联表"><a href="#角色权限功能关联表" class="headerlink" title="角色权限功能关联表"></a>角色权限功能关联表</h4><h3 id="第一步：公网IP："><a href="#第一步：公网IP：" class="headerlink" title="第一步：公网IP："></a>第一步：公网IP：</h3><p>8.131.62.192</p><h3 id="第二步：连接工具"><a href="#第二步：连接工具" class="headerlink" title="第二步：连接工具"></a>第二步：连接工具</h3><p>ssh <a href="mailto:root@8.131.62.192">root@8.131.62.192</a></p><h3 id="第三步：各种工具"><a href="#第三步：各种工具" class="headerlink" title="第三步：各种工具"></a>第三步：各种工具</h3><h3 id="第四步：注意事项"><a href="#第四步：注意事项" class="headerlink" title="第四步：注意事项"></a>第四步：注意事项</h3><p>端口</p><p>防火墙</p><p>更新配置</p><p>阿里云ECS官网给的配置错误，使用下面的资源连接</p><p><a href="https://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.59/bin/apache-tomcat-8.5.59.tar.gz" target="_blank" rel="noopener">https://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.59/bin/apache-tomcat-8.5.59.tar.gz</a></p><h5 id="前端文件传输"><a href="#前端文件传输" class="headerlink" title="前端文件传输"></a>前端文件传输</h5><p>scp -r /Users/jinhongcai/Documents/work/space/gitee/smart-admin/smart-admin-web/dist <a href="mailto:root@8.131.62.192">root@8.131.62.192</a>:/usr/local/tomcat/Tomcat8.5/webapps</p><h5 id="jar-传输"><a href="#jar-传输" class="headerlink" title="jar 传输"></a>jar 传输</h5><p>scp -r /Users/jinhongcai/Documents/work/space/gitee/smart-admin/smart-admin-service/smart-admin-api/target/smart-admin-api-1.0.0.jar <a href="mailto:root@8.131.62.192">root@8.131.62.192</a>:/usr/local/java</p><h5 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h5><pre class=" language-shell"><code class="language-shell">nohup java -jar demo-0.0.1-SNAPSHOT.jar  > log.file  2>&1 &</code></pre><h3 id="第五步：其他"><a href="#第五步：其他" class="headerlink" title="第五步：其他"></a>第五步：其他</h3><p>参考：<a href="https://blog.csdn.net/evil_wdpp/article/details/107709376" target="_blank" rel="noopener">https://blog.csdn.net/evil_wdpp/article/details/107709376</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试汇总</title>
      <link href="/2021/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/"/>
      <url>/2021/01/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E9%80%89/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h4><p>Java 语言层面：Object object = new Object()</p><p>Java 字节码层面：</p><ol><li>new指令</li><li>dup指令</li><li>invoke指令</li><li>返回引用</li></ol><p>JVM 实现：运行时数据区</p><ol><li>堆内开辟空间</li><li>对象field赋初始值</li><li>执行构造方法</li><li>返回地址给引用</li></ol><h5 id="标准答案-1～3-类加载流程，4～6-内存分配、初始化流程"><a href="#标准答案-1～3-类加载流程，4～6-内存分配、初始化流程" class="headerlink" title="标准答案 1～3:类加载流程，4～6:内存分配、初始化流程"></a>标准答案 1～3:类加载流程，4～6:内存分配、初始化流程</h5><ol><li><p>class loading</p></li><li><p>class linking</p><p>2.1 verification：验证文件是否符合JVM规范<br>2.2 preparation：半初始化，静态变量赋默认值<br>2.3 resolution：将类/方法/属性的符号引用解析为直接饮用</p></li><li><p>initializing：静态变量赋初始值</p><p>前三步：method area内生成类对象</p></li><li><p>申请对象内存</p></li><li><p>成员变量赋默认值</p></li><li><p>调用对象构造方法init</p><p>6.1成员变量顺序赋初始值<br>​6.2执行构造方法语句，先super()</p></li></ol><h4 id="Object-类中的方法"><a href="#Object-类中的方法" class="headerlink" title="Object 类中的方法"></a>Object 类中的方法</h4><p>​    hashCode<br>​    equals<br>​    toString<br>​    wait<br>​    notify<br>​    clone<br>​    finalize</p><p>Object的hashcode方法重写了，equals方法要不要重写？<br>    看场景,官方的建议是要重写这俩方法一起重写</p><p>hashcode 和 equals 方法常用地方？<br>    对象比较是否相同</p><h5 id="Object-toString-方法常用的地方，为什么要重写该方法"><a href="#Object-toString-方法常用的地方，为什么要重写该方法" class="headerlink" title="Object toString 方法常用的地方，为什么要重写该方法"></a>Object toString 方法常用的地方，为什么要重写该方法</h5><p>​    默认实现打印对象堆地址信息</p><h5 id="finally块一定会执行吗"><a href="#finally块一定会执行吗" class="headerlink" title="finally块一定会执行吗"></a>finally块一定会执行吗</h5><p>​    不一定，只有 try finally 正常执行完毕的情况下，才会执行</p><h5 id="正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行"><a href="#正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行" class="headerlink" title="正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行"></a>正常情况下，当在try块或catch块中遇到return语句时，finally语句块在方法返回之前还是之后被执行</h5><p>​    返回之前</p><h5 id="try、catch、finally语句块的执行顺序"><a href="#try、catch、finally语句块的执行顺序" class="headerlink" title="try、catch、finally语句块的执行顺序"></a>try、catch、finally语句块的执行顺序</h5><p>​    try - catch - finally</p><h5 id="一个空Object对象的占多大空间"><a href="#一个空Object对象的占多大空间" class="headerlink" title="一个空Object对象的占多大空间"></a>一个空Object对象的占多大空间</h5><p>​    对象头(markword + 类型指针)<br>​    实例变量    看情况</p><h5 id="对象引用类型分为哪几类"><a href="#对象引用类型分为哪几类" class="headerlink" title="对象引用类型分为哪几类"></a>对象引用类型分为哪几类</h5><ol><li>强：普通的对象。只有发生GC 空间和地址才会被回收。</li><li>软：主动声明对象类型为SoftReference的对象为软引用对象。内存不够才回收<ul><li>适用场景：缓存</li></ul></li><li>弱：主动声明对象类型为WeakReference的对象为弱饮用对象。只要发生GC 就会回收。</li><li>虚：主动声明对象类型为PhantomReference的对象为虚引用对象，必须结合ReferenceQueue使用，要回收的对象会被加入队列，由GC线程检查队列内应用对象。<ul><li>使用场景：堆外内存 堆内应用指向堆外地址 nio - zero copy </li></ul></li></ol><h5 id="Java中的参数传递时传值呢？还是传引用"><a href="#Java中的参数传递时传值呢？还是传引用" class="headerlink" title="Java中的参数传递时传值呢？还是传引用"></a>Java中的参数传递时传值呢？还是传引用</h5><p>​    值传递</p><h5 id="动态代理的几种实现方式及优缺点"><a href="#动态代理的几种实现方式及优缺点" class="headerlink" title="动态代理的几种实现方式及优缺点"></a>动态代理的几种实现方式及优缺点</h5><p>​    静态<br>​        实现简单，由程序员实现，可读性好，变更灵活，需要源文件<br>​        类爆炸，不易维护，被代理类新增方法，代理类需要跟着变更<br>​    动态<br>​        jdk动态：java.lang.reflect 包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力。反射机制生成代理类的对象<br>​            针对接口进行增强<br>​        cglib动态 - 基于asm实现，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。典型实现就是Spring AOP<br>​            针对类进行增强<br>​        运行时生成，增强逻辑集中，易于维护</p><h5 id="类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样"><a href="#类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样" class="headerlink" title="类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样"></a>类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样</h5><h5 id="Override和Overload的区别，分别用在什么场景"><a href="#Override和Overload的区别，分别用在什么场景" class="headerlink" title="Override和Overload的区别，分别用在什么场景"></a>Override和Overload的区别，分别用在什么场景</h5><p>​    重载：同一类<br>​    重写：父子类</p><h5 id="java的反射是如何实现的"><a href="#java的反射是如何实现的" class="headerlink" title="java的反射是如何实现的"></a>java的反射是如何实现的</h5><p>​    Reflection APIs 需要了解 Class 文件结构</p><h3 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h3><h5 id="Synchronized-用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？"><a href="#Synchronized-用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？" class="headerlink" title="Synchronized 用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？"></a>Synchronized 用过吗？其原理是什么？偏向锁，轻量级锁，重量级锁都介绍下？</h5><p>是什么 ：多线程并发环境下保证同步和数据安全<br>    多线程访问同步方法或代码块时，线程必须先获取对象监视器才有方法执行权。获取失败进入同步队列，线程状态变为<code>BLOCKED</code>状态。只有当持有锁的线程释放锁后，唤醒阻塞在同步队列中的线程，使其重新尝试获取监视器锁，往复此流程，如果持有锁的线程调用<code>wait()</code>方法，当前线程释放<code>monitor</code>，线程状态变成<code>WAITING</code>，进入等待队列，等待其他线程唤醒，如若唤醒则从等待队列进入到同步队列继续抢夺monitor持有权</p><pre><code>原理：    Java 语言层面：使用 synchronized 关键字修饰方法或代码段    JVM 层面实现：被 synchronized 关键字修饰的代码段，通过JVM被编译为monitorenter、monitorexit指令来获取和释放互斥锁，解释器执行monitorenter时会进入到InterpreterRuntime.cpp的InterpreterRuntime::monitorenter函数，达到线程安全的目的    被 synchronized 关键字修饰的方法，方法的访问修饰符添加 sychronized 标识锁升级过程：偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态，    偏向锁在JDK6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁重量级锁升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。    </code></pre><h5 id="Monitor是什么"><a href="#Monitor是什么" class="headerlink" title="Monitor是什么"></a>Monitor是什么</h5><p>​    Monitor是一个同步工具，也可以说是一种同步机制，具体体现在它是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用<br>​    Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。</p><h5 id="“锁”到底是什么"><a href="#“锁”到底是什么" class="headerlink" title="“锁”到底是什么"></a>“锁”到底是什么</h5><p>​    锁是对象的一种状态</p><h5 id="如何确定对象的锁"><a href="#如何确定对象的锁" class="headerlink" title="如何确定对象的锁"></a>如何确定对象的锁</h5><p>​    获取对象头的markword，查看锁标志位，用2位来表示不同状态</p><h5 id="什么是可重入性，为什么说-Synchronized-是可重入锁"><a href="#什么是可重入性，为什么说-Synchronized-是可重入锁" class="headerlink" title="什么是可重入性，为什么说 Synchronized 是可重入锁"></a>什么是可重入性，为什么说 Synchronized 是可重入锁</h5><p>线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞</p><pre><code>可重入原理：c++代码 - entry()方法1.通过CAS尝试把monitor的`_owner`字段设置为当前线程2.设置成功再判断是否是第一次进去`monitor`    如果第一次设置_recursions = 1，_owner为当前线程    如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁，_recursions代表当前线程获取锁次数3.设置失败更改线程状态在监视器上阻塞4.通过自旋执行尝试等待锁的释放5.最后如果没有获取成功，当前线程被封装成ObjectWaiter对象node，通过CAS把node节点push到_cxq列表中，则通过park将当前线程挂起，等待被唤醒</code></pre><h5 id="Synchronized-为什么是重量级锁"><a href="#Synchronized-为什么是重量级锁" class="headerlink" title="Synchronized 为什么是重量级锁"></a>Synchronized 为什么是重量级锁</h5><p>​    根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成 </p><p>​    ***** 阻塞和唤醒需要OS进行状态切换，上下文切换可以认为是内核在 CPU 上对于进程（包括线程）进行以下的活动：</p><pre><code>      1. 挂起一个进程，将这个进程在 CPU 中的状态存储于内存中的某处        2. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复          3. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程</code></pre><p>​    1.6之前，通过Monitor实现，对象通过ObjectMonitor的enter()方法获取锁，通过exit()方法释放锁，这也是导致我们经常会说synchronize是重量级锁的原因，因为java的线程是映射到操作系统的原生线程，如果要wait()或notify()一个线程就需要OS帮助，需要从用户态切换到内核态，俗称上下文切换<br>​    </p><h5 id="JVM对Java的原生锁做了哪些优化"><a href="#JVM对Java的原生锁做了哪些优化" class="headerlink" title="JVM对Java的原生锁做了哪些优化"></a>JVM对Java的原生锁做了哪些优化</h5><p>​    JDK1.6对加锁的实现引入大量的优化来减少锁操作开销<br>​    还有我们经常说的对synchronize的升级也是1.6之后对锁的实现和类型进行了优化，目的是降低加锁、释放锁的开销，出现了偏向锁、轻量级锁<br>偏向锁：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作<br>轻量级锁：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放<br>适应性自旋：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环，即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间</p><h5 id="为什么说-Synchronized-是非公平锁"><a href="#为什么说-Synchronized-是非公平锁" class="headerlink" title="为什么说 Synchronized 是非公平锁"></a>为什么说 Synchronized 是非公平锁</h5><p>​    entryList内的线程并行通过 cas 尝试把 owner 字段设置为当前线程，也就是无需排队获取同步资源，直接尝试获取锁</p><h5 id="什么是锁消除和锁粗化"><a href="#什么是锁消除和锁粗化" class="headerlink" title="什么是锁消除和锁粗化"></a>什么是锁消除和锁粗化</h5><p>​    锁粗化：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗<br>​    锁消除：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁<br>​    </p><h5 id="为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）"><a href="#为什么说-Synchronized-是一个悲观锁？乐观锁的实现原理又是什么？什么是-CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）" class="headerlink" title="为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）"></a>为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？CAS的实现（unsafe类cas相关方法，和CPU中CAS相关指令）</h5><pre class=" language-html"><code class="language-html">悲观锁:    原理：认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改    实现：Java中，synchronized关键字和Lock的实现类都是悲观锁乐观锁:    原理：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。    实现：乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法和版本号机制</code></pre><pre><code>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁的情况下实现多线程之间的变量同步java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁主要就是Unsafe类 属性：valueOffSet、voliatile valueCAS算法涉及到三个操作数：需要读写的内存值 V进行比较的值 A要写入的新值 B当且仅当A时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止CAS 存在的问题1.ABA问题    CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。    JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。2.循环时间长开销大    CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。3.只能保证一个共享变量的原子操作    对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。    Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</code></pre><h5 id="乐观锁一定就是好的吗"><a href="#乐观锁一定就是好的吗" class="headerlink" title="乐观锁一定就是好的吗"></a>乐观锁一定就是好的吗</h5><p>​    竞争激烈的情况，乐观锁会浪费更多的cpu资源</p><h5 id="Synchronized、ReentrantLock-原理区别"><a href="#Synchronized、ReentrantLock-原理区别" class="headerlink" title="Synchronized、ReentrantLock 原理区别"></a>Synchronized、ReentrantLock 原理区别</h5><p>​    原理：ReentrantLock基于AQS实现，而AQS底层使用的是改进的CLH队列，CAS+阻塞+唤醒，对于暂时获取不到资源以及尚未被父节点唤醒的线程在队列中阻塞休眠，被唤醒后CAS获取资源。并不是单纯的阻塞或者CAS，兼顾了性能和效率<br>​    ReentrantLock里面有一个内部类Sync，Sync继承AQS，添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。<br>​    公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。<br>​    hasQueuedPredecessors()方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是就去尝试加锁并返回<br>​    综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p><h5 id="AQS-流程分析"><a href="#AQS-流程分析" class="headerlink" title="AQS 流程分析"></a>AQS 流程分析</h5><p>​    <a href="https://processon.com/diagraming/5f53739963768959e2d612c4" target="_blank" rel="noopener">https://processon.com/diagraming/5f53739963768959e2d612c4</a></p><h5 id="公平和非公平"><a href="#公平和非公平" class="headerlink" title="公平和非公平"></a>公平和非公平</h5><p>​    公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><pre><code>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</code></pre><h5 id="请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。"><a href="#请尽可能详尽地对比下-Synchronized-和-ReentrantLock-的异同。" class="headerlink" title="请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。"></a>请尽可能详尽地对比下 Synchronized 和 ReentrantLock 的异同。</h5><p>​    相同点：<br>​    都是用来协调多线程对共享对象、变量的访问都是可重入锁，同一线程可以多次获得同一个锁都保证了可见性和互斥性<br>​    不同点：<br>​        1、底层实现不一样，synchronized它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成。也就是说synchronized隐式获得释放锁，ReentrantLock 显示的获得、释放锁。<br>​        2、synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock 时需要在 finally块中释放锁<br>​        3、synchronized是同步阻塞，使用的是悲观策略，lock是同步非阻塞，采用的是乐观并发策略。<br>​        4、ReentrantLock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。通过ReentrantLock可以知道有没有成功获取锁，而synchronized却无法办到。最重要的是ReentrantLock可以提供公平锁，而synchronized只能是非公平锁</p><p>ReentrantLock 是如何实现可重入性的？分析可重入锁的实现（涉及AQS中同步状态如何控制）<br>    ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0<br>    当前线程获取锁成功，status = 1，当前线程再次获取锁时，判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。</p><p>除了 ReetrantLock，你还接触过 JUC 中的哪些并发工具？<br>如何让 Java 的线程彼此同步？你了解过哪些同步器？请分别介绍下。</p><p>CyclicBarrier 和 CountDownLatch 看起来很相似，请对比下呢？<br>分析Java CountDownLatch类的实现？<br>分析Java Condition类实现（同步队列和等待队列）<br>分析Java Samphore类实现（AQS）<br>分析Java 阻塞队列实现<br>读写锁设计主要解决什么问题？</p><p>java有哪些锁？<br>乐观锁 悲观锁 </p><h3 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h3><h5 id="为什么object的wait和notify还有condition-await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象"><a href="#为什么object的wait和notify还有condition-await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象" class="headerlink" title="为什么object的wait和notify还有condition.await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象"></a>为什么object的wait和notify还有condition.await和signal都要放在同步代码块中，并且锁的和wait的还是同一个对象</h5><p>​    是因为设计者防止出现lost wake up的问题出现的，就是假设一个生产者和消费者，生产消息+1，消费消息-1，那么如果刚开始count=0，消费者进来发现count=0，就准备阻塞，但是这时候生产者生产了一条消息，并且执行了notify消息，但是没有线程需要你notify，然后消费者执行下一步wait方法等待，所以这条消息就丢失了 </p><h5 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h5><p>​    sleep不释放锁，wait释放锁<br>​    sleep是Thread方法，wait是Object的方法<br>​    sleep必须设置时间，wait不用必须<br>​    sleep不需要被唤醒，wait需要调用唤醒</p><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><p>​    start，runnable，blocked，waiting，timedwaited，terminate</p><h5 id="线程的阻塞的方式"><a href="#线程的阻塞的方式" class="headerlink" title="线程的阻塞的方式"></a>线程的阻塞的方式</h5><p>Blocked状态<br>    线程在等待同步锁，也就是synchronized，<br>waiting状态<br>    调用Object对象的wait方法，但没有指定超时值。<br>    调用Thread对象的join方法，但没有指定超时值。<br>    调用LockSupport对象的park方法。<br>TIMED_WAITING状态<br>    调用Thread.sleep方法。<br>    调用Object对象的wait方法，指定超时值。<br>    调用Thread对象的join方法，指定超时值。<br>    调用LockSupport对象的parkNanos方法。<br>    调用LockSupport对象的parkUntil方法。</p><h3 id="Java-线程池相关问题"><a href="#Java-线程池相关问题" class="headerlink" title="Java 线程池相关问题"></a>Java 线程池相关问题</h3><p>Java 中的线程池是如何实现的？<br>创建线程池的几个核心构造参数？<br>线程池中的线程是怎么创建的？是一开始就随着线程池的启动创建好的吗？<br>线程池有哪几种？有哪几种拒绝策略？如何自定义拒绝策略？<br>项目中你怎么使用线程池，为什么要使用线程池？<br>按线程池内部机制，当提交新任务时，有哪些异常要考虑？<br>java线程池中基于缓存和基于定长的两种线程池，当请求太多时分别是如何处理的？定长的事用的队列，如果队列也满了呢？交换进磁盘？基于缓存的线程池解决方法呢？</p><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><p>如何实现普通IO和NIO一样的效果？<br>nio的底层实现？<br>虚拟机，IO相关知识点？<br>NIO是什么？适用于何种场景？<br>怎么理解零拷贝，直接ip和mmap都避免了用户态到内核态的切换，<br>（1）零拷贝：在内核态将数据直接从pagecache拷贝到socketbuffer<br>（2）直接io：通过dma直接写数据到磁盘<br>（3）mmap将物理地址和虚拟地址对应，直接写数据到pagecache<br>IO会阻塞吗？<br>readLine是不是阻塞的<br>readLine()是一个阻塞函数，当没有数据读取时，就一直会阻塞在那，而不是返回null<br>readLine()只有在数据流发生异常或者另一端被close()掉时，才会返回null值。</p><h3 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h3><p>谈一下设计模式有几种？<br>Spring使用了什么设计模式？<br>适配器和代理模式的区别<br>门面模式，类图(外观模式)<br>mybatis如何映射表结构<br>请列举出在 JDK 中几个常用的设计模式？<br>什么是设计模式？你是否在你的代码里面使用过任何设计模式？<br>Java 中什么叫单例设计模式？请用 Java 写出线程安全的单例模式<br>在 Java 中，什么叫观察者设计模式（observer design pattern）？<br>使用工厂模式最主要的好处是什么？在哪里使用？<br>举一个用 Java 实现的装饰模式(decorator design pattern)？它是作用于对象层次还是类层次？</p><h3 id="Spring相关"><a href="#Spring相关" class="headerlink" title="Spring相关"></a>Spring相关</h3><p>Spring AOP的实现原理和场景<br>Spring bean的作用域和生命周期<br>Spring 5比Spring4做了哪些改进<br>Spring IOC是什么？优点是什么？<br>讲一讲FactroyBean?<br>aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理<br>通过动态代理进行对目标方法的横切，每次运行时会生成一个proxy对象，拥有目标类的所有方法，并且在在特定的切点进行增强处理，然后回调原对象的方法<br>我会疯转成工厂类<br>spring的bean配置的几种方式<br>基于XML的配置、基于注解的配置和基于Java类的配置<br>web.xml的配置<br>最终加载顺序：ServletContext -&gt; listener -&gt; filter -&gt; servlet<br>spring的监听器。<br>ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息<br>spring Aop的实现原理，具体说说<br>何时会内存泄漏，内存泄漏会抛哪些异常<br>是否用过Autowire注解<br>spring的注入bean的方式<br>Spring Bean 的生命周期<br>说说Spring的IOC容器初始化流程？<br>@Transaction注解一般写在什么位置?如何控制其回滚?<br>如Spring中如何对同名Bean加载时的处理<br>答：spring会在DefaultListableBeanFactory这个类中会根据扫描到的bean进行加载到ioc容器中时，遇到重名的会进行覆盖，如果不想覆盖可以在web.xml中设置allowBeanDefinitionOverriding 为false即可<br>什么是 Spring 框架？Spring 框架有哪些主要模块？<br>使用 Spring 框架能带来哪些好处？<br>什么是控制反转(IOC)？什么是依赖注入？<br>请解释下 Spring 框架中的 IoC？<br>BeanFactory 和 ApplicationContext 有什么区别？<br>Spring 有几种配置方式？<br>如何用基于 XML 配置的方式配置 Spring？<br>如何用基于 Java 配置的方式配置 Spring？<br>怎样用注解的方式配置 Spring？<br>请解释 Spring Bean 的生命周期？<br>Spring Bean 的作用域之间有什么区别？<br>什么是 Spring inner beans？<br>Spring 框架中的单例 Beans 是线程安全的么？<br>请举例说明如何在 Spring 中注入一个 Java Collection？<br>如何向 Spring Bean 中注入一个 Java.util.Properties？<br>请解释 Spring Bean 的自动装配？<br>请解释自动装配模式的区别？<br>如何开启基于注解的自动装配？<br>请举例解释@Required 注解？<br>请举例解释@Autowired 注解？<br>请举例说明@Qualifier 注解？<br>构造方法注入和设值注入有什么区别？<br>Spring 框架中有哪些不同类型的事件？<br>FileSystemResource 和 ClassPathResource 有何区别？<br>Spring 框架中都用到了哪些设计模式？</p><h3 id="集合相关"><a href="#集合相关" class="headerlink" title="集合相关"></a>集合相关</h3><p>ConcurrentHashmap的锁是如何加的？是不是分段越多越好分段加锁<br>    并不是，参考锁粗化的优化</p><p>concurrenhashmap求size是如何加锁的，如果刚求完一段后这段发生了变化该如何处理<br>hashmap如果只有一个写其他全读会出什么问题<br>java有哪些容器<br>HashMap 和 hashTable 区别？</p><p>hashtable和ConcurrentHashMap如何实现线程安全？<br>LinkedHashmap的底层实现<br>ArrayList的原理讲一讲，扩容等<br>hashmap的底层实现<br>1.7是数组+链表  1.8是数组 + 链表 链表长度超过8并且数组元素大于64会转成红黑树，不然只是会扩容<br>Hashmap 线程不安全的出现场景</p><p>hashmap put 方法存放的时候怎么判断是否是重复的<br>Set 和 List 区别？<br>ArrayList 和 LinkedList 区别<br>如果存取相同的数据，ArrayList 和 LinkedList 谁占用空间更大？<br>Set 存的顺序是有序的吗？<br>常见 Set 的实现有哪些？<br>HashSet 的底层实现呢<br>TreeSet 底层源码有看过吗？<br>红黑树的实现原理和应用场景；</p><p>HashMap内部的数据结构是什么？底层是怎么实现的？</p><h1 id="熟悉Spring、SpringMVC、MyBatis"><a href="#熟悉Spring、SpringMVC、MyBatis" class="headerlink" title="熟悉Spring、SpringMVC、MyBatis"></a>熟悉Spring、SpringMVC、MyBatis</h1><h1 id="熟悉-MQ-、Redis-等常用中间件的原理与使用"><a href="#熟悉-MQ-、Redis-等常用中间件的原理与使用" class="headerlink" title="熟悉 MQ 、Redis 等常用中间件的原理与使用"></a>熟悉 MQ 、Redis 等常用中间件的原理与使用</h1><h2 id="说说你们公司线上生产环境用的是什么消息中间件"><a href="#说说你们公司线上生产环境用的是什么消息中间件" class="headerlink" title="说说你们公司线上生产环境用的是什么消息中间件?"></a>说说你们公司线上生产环境用的是什么消息中间件?</h2><h2 id="为什么要使用MQ？"><a href="#为什么要使用MQ？" class="headerlink" title="为什么要使用MQ？"></a>为什么要使用MQ？</h2><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是<strong>同步执行</strong>经常出问题，所以引入了mq</p><p><strong>解耦</strong></p><p>系统耦合度降低，没有强依赖关系</p><p><strong>异步</strong></p><p>不需要同步执行的远程调用可以有效提高响应时间</p><p><strong>削峰</strong></p><p>请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮</p><h3 id="多个mq如何选型？"><a href="#多个mq如何选型？" class="headerlink" title="多个mq如何选型？"></a>多个mq如何选型？</h3><p><strong>RabbitMQ</strong></p><p>erlang开发，延迟比较低</p><p><strong>RocketMQ</strong></p><p>java开发，面向互联网集群化功能丰富</p><p><strong>kafka</strong></p><p>Scala开发，面向日志功能丰富</p><p><strong>ActiveMQ</strong></p><p>java开发，简单，稳定</p><p>小项目：ActiveMQ</p><p>大项目：RocketMQ或kafka、RabbitMq</p><h2 id="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h2><p>nameserver 无状态 动态列表</p><p>producer</p><p>broker</p><p>consumer</p><h2 id="RocketMQ中的Topic和ActiveMQ有什么区别？"><a href="#RocketMQ中的Topic和ActiveMQ有什么区别？" class="headerlink" title="RocketMQ中的Topic和ActiveMQ有什么区别？"></a>RocketMQ中的Topic和ActiveMQ有什么区别？</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>有destination的概念，即消息目的地</p><p>destination分为两类：</p><ul><li>topic<ul><li>广播消息</li></ul></li><li>queue<ul><li>队列消息</li></ul></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ的Topic是一组Message Queue的集合 ConsumeQueue</p><p>一条消息是广播消息还是队列消息由客户端消费决定</p><h2 id="RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="RocketMQ Broker中的消息被消费后会立即删除吗？"></a>RocketMQ Broker中的消息被消费后会立即删除吗？</h2><p>不会，每条消息都会持久化到CommitLog中，每个consumer连接到broker后会维持消费进度信息，当有消息消费后只是当前consumer的消费进度（CommitLog的offset）更新了。</p><h3 id="那么消息会堆积吗？什么时候清理过期消息？"><a href="#那么消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="那么消息会堆积吗？什么时候清理过期消息？"></a>那么消息会堆积吗？什么时候清理过期消息？</h3><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p><ul><li>检查这个文件最后访问时间</li><li>判断是否大于过期时间</li><li>指定时间删除，默认凌晨4点</li></ul><h2 id="RocketMQ消费模式有几种？"><a href="#RocketMQ消费模式有几种？" class="headerlink" title="RocketMQ消费模式有几种？"></a>RocketMQ消费模式有几种？</h2><p>消费模型由consumer决定，消费维度为Topic</p><h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>一组consumer同时消费一个topic，可以分配消费负载均衡策略分配consumer对应消费topic下的哪些queue</p><p>多个group同时消费一个topic时，每个group都会消费到数据</p><p>一条消息只会被一个group中的consumer消费，</p><h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p><h2 id="消费消息时使用的是push还是pull？"><a href="#消费消息时使用的是push还是pull？" class="headerlink" title="消费消息时使用的是push还是pull？"></a>消费消息时使用的是push还是pull？</h2><p>在刚开始的时候就要决定使用哪种方式消费</p><p>两种：</p><p><code>DefaultLitePullConsumerImpl</code> 拉</p><p><code>DefaultMQPushConsumerImpl</code>推</p><p>两个实现 <code>DefaultLitePullConsumerImpl</code> <code>DefaultMQPushConsumerImpl</code>都实现了MQConsumerInner接口接口</p><p>名称上看起来是一个推，一个拉，但实际底层实现都是采用的<strong>长轮询机制</strong>，即拉取方式</p><p>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p><h3 id="为什么要主动拉取消息而不使用事件监听方式？"><a href="#为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="为什么要主动拉取消息而不使用事件监听方式？"></a>为什么要主动拉取消息而不使用事件监听方式？</h3><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p><p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p><h4 id="说一说几种常见的消息同步机制？"><a href="#说一说几种常见的消息同步机制？" class="headerlink" title="说一说几种常见的消息同步机制？"></a>说一说几种常见的消息同步机制？</h4><p>push：</p><p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p><p>pull：</p><p>轮训时间间隔，固定值的话会造成资源浪费</p><p>长轮询：</p><p>上连接 短连接（每秒） 长轮询</p><h3 id="broker如何处理拉取请求的？"><a href="#broker如何处理拉取请求的？" class="headerlink" title="broker如何处理拉取请求的？"></a>broker如何处理拉取请求的？</h3><p>consumer首次请求broker</p><ul><li><p>broker中是否有符合条件的消息</p></li><li><p>有 -&gt;</p></li></ul><ul><li>响应consumer</li><li>等待下次consumer的请求</li></ul><ul><li><p>没有</p><ul><li>挂起consumer的请求，即不断开连接，也不返回数据</li><li>挂起时间长短，写死在代码里的吗？长轮询写死，短轮询可以配</li><li>使用consumer的offset，<ul><li>DefaultMessageStore#ReputMessageService#run方法<ul><li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li><li>当有新消息的时候返回请求</li></ul></li><li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li></ul></li></ul></li></ul><h2 id="RocketMQ如何做负载均衡？"><a href="#RocketMQ如何做负载均衡？" class="headerlink" title="RocketMQ如何做负载均衡？"></a>RocketMQ如何做负载均衡？</h2><p>通过Topic在多broker种分布式存储实现</p><h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>发送端指定Target message queue发送消息到相应的broker，来达到写入时的负载均衡</p><ul><li>提升写入吞吐量，当多个producer同时向一个broker写入数据的时候，性能会下降</li><li>消息分布在多broker种，为负载消费做准备</li></ul><p>每 30 秒从 nameserver获取 Topic 跟 Broker 的映射关系，近实时获取最新数据存储单元，queue落地在哪个broker中</p><p>在使用api中send方法的时候，可以指定Target message queue写入或者使用MessageQueueSelector</p><h4 id="默认策略是随机选择："><a href="#默认策略是随机选择：" class="headerlink" title="默认策略是随机选择："></a><strong>默认策略是随机选择：</strong></h4><ul><li>producer维护一个index</li><li>每次取节点会自增</li><li>index向所有broker个数取余</li><li>自带容错策略</li></ul><h4 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h4><ul><li>SelectMessageQueueByHash<ul><li>hash的是传入的args</li></ul></li><li>SelectMessageQueueByRandom</li><li>SelectMessageQueueByMachineRoom 没有实现</li></ul><p>也可以自定义实现<strong>MessageQueueSelector</strong>接口中的select方法</p><pre><code>MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);</code></pre><p>可以自定义规则来选择mqs</p><h4 id="如何知道mqs的，mqs的数据从哪儿来？"><a href="#如何知道mqs的，mqs的数据从哪儿来？" class="headerlink" title="如何知道mqs的，mqs的数据从哪儿来？"></a>如何知道mqs的，mqs的数据从哪儿来？</h4><p>producer.start()方法</p><p>参考源码</p><ul><li>启动producer的时候会向nameserver发送心跳包</li><li>获取nameserver中的topic列表</li><li>使用topic向nameserver获取topicRouteData</li></ul><p><strong>TopicRouteData</strong>对象表示与某一个topic有关系的broker节点信息，内部包含多个QueueData对象（可以有多个broker集群支持该topic）和多个BrokerData信息（多个集群的多个节点信息都在该列表中）</p><p><strong>producer加工TopicRouteData，对应的多节点信息后返回mqs。</strong></p><h3 id="consumer端"><a href="#consumer端" class="headerlink" title="consumer端"></a>consumer端</h3><p>客户端完成负载均衡</p><ul><li><p>获取集群其他节点</p></li><li><p>当前节点消费哪些queue</p></li><li><p><strong>负载粒度直到Message Queue</strong></p></li><li><p><strong>consumer的数量最好和Message Queue的数量对等或者是倍数，不然可能会有消费倾斜</strong></p></li><li><p>每个consumer通过</p><p>balanced</p><p>维护processQueueTable</p><ul><li><p>processQueueTable为当前consumer的消费queue</p></li><li><p>processQueueTable中有</p></li></ul></li></ul><pre><code>- ProcessQueue ：维护消费进度，从broker中拉取回来的消息缓冲- MessageQueue ： 用来定位查找queue</code></pre><p>DefaultMQPushConsumer默认 使用AllocateMessageQueueAveragely（平均分配）</p><h3 id="当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>当消费负载均衡consumer和queue不对等的时候会发生什么？</h3><h4 id="平均分配"><a href="#平均分配" class="headerlink" title="平均分配"></a>平均分配</h4><p><img src="http://lion-heart.online/blog/2020-10-10-234835.png" alt="image20200313171617553"></p><h4 id="环形分配"><a href="#环形分配" class="headerlink" title="环形分配"></a>环形分配</h4><p><img src="http://lion-heart.online/blog/2020-10-10-234837.png" alt="image20200313171645109"></p><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>平均分配策略(默认)(AllocateMessageQueueAveragely) 环形分配策略(AllocateMessageQueueAveragelyByCircle) 手动配置分配策略(AllocateMessageQueueByConfig) 机房分配策略(AllocateMessageQueueByMachineRoom) 一致性哈希分配策略(AllocateMessageQueueConsistentHash) 靠近机房策略(AllocateMachineRoomNearby)</p><p>consumer启动流程参考源码</p><h2 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h2><h4 id="SendResult"><a href="#SendResult" class="headerlink" title="SendResult"></a>SendResult</h4><p>producer在发送同步/异步可靠消息后，会接收到SendResult，表示消息发送成功</p><p>SendResult其中属性sendStatus表示了broker是否真正完成了消息存储</p><p>当sendStatus!=”ok”的时候，应该重新发送消息，避免丢失</p><p>当producer.setRetryAnotherBrokerWhenNotStoreOK</p><h2 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h2><p>影响消息正常发送和消费的重要原因是网络的不确定性。</p><p><strong>可能是因为consumer首次启动引起重复消费</strong></p><p>需要设置<code>consumer.setConsumeFromWhere</code></p><p>只对一个新的consumeGroup第一次启动时有效,设置从头消费还是从维护开始消费</p><p><strong>你们怎么保证投递出去的消息只有一条且仅仅一条，不会出现重复的数据?</strong></p><p>绑定业务key</p><p><strong>如果消费了重复的消息怎么保证数据的准确性?</strong></p><h3 id="引起重复消费的原因"><a href="#引起重复消费的原因" class="headerlink" title="引起重复消费的原因"></a>引起重复消费的原因</h3><h4 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a><strong>ACK</strong></h4><p>正常情况下在consumer真正消费完消息后应该发送ack，通知broker该消息已正常消费，从queue中剔除</p><p>当ack因为网络原因无法发送到broker，broker会认为词条消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer</p><h4 id="group"><a href="#group" class="headerlink" title="group"></a><strong>group</strong></h4><p>在CLUSTERING模式下，消息在broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h4><p>处理消息前，使用消息主键在表中带有约束的字段中insert</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>单机时可以使用map <em>ConcurrentHashMap</em> -&gt; putIfAbsent guava cache</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>使用主键或set操作</p><h2 id="如何让RocketMQ保证消息的顺序消费"><a href="#如何让RocketMQ保证消息的顺序消费" class="headerlink" title="如何让RocketMQ保证消息的顺序消费"></a>如何让RocketMQ保证消息的顺序消费</h2><p><strong>你们线上业务用消息中间件的时候，是否需要保证消息的顺序性?</strong></p><p><strong>如果不需要保证消息顺序，为什么不需要?假如我有一个场景要保证消息的顺序，你们应该如何保证?</strong></p><ul><li>同一topic</li><li>同一个QUEUE</li><li>发消息的时候一个线程去发送消息</li><li>消费的时候 一个线程 消费一个queue里的消息或者使用MessageListenerOrderly</li><li>多个queue 只能保证单个queue里的顺序</li></ul><h3 id="应用场景是啥？"><a href="#应用场景是啥？" class="headerlink" title="应用场景是啥？"></a>应用场景是啥？</h3><p>应用系统和现实的生产业务绑定，避免在分布式系统中多端消费业务消息造成顺序混乱</p><p>比如需要严格按照顺序处理的数据或业务</p><p><strong>数据包装</strong>/清洗</p><p>数据：</p><pre><code>import java.nio.ByteBuffer;import java.nio.charset.Charset;import java.util.HashMap;import java.util.Iterator;import java.util.Map;</code></pre><ol><li>去掉import</li><li>统计某个字符出现次数</li></ol><p><strong>业务流程处理</strong></p><p>返修过程</p><ol><li>收件录入信息</li><li>信息核对</li><li>送入检修系统处理</li></ol><p>电商订单</p><ol><li>创建订单</li><li>检查库存预扣库存</li><li>支付</li><li>真扣库存</li></ol><p>binlog同步</p><h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><ol><li>生产端如何保证投递出去的消息不丢失：消息在半路丢失，或者在MQ内存中宕机导致丢失，此时你如何基于MQ的功能保证消息不要丢失？</li><li>MQ自身如何保证消息不丢失？</li><li>消费端如何保证消费到的消息不丢失：如果你处理到一半消费端宕机，导致消息丢失，此时怎么办？</li></ol><h3 id="解耦的思路"><a href="#解耦的思路" class="headerlink" title="解耦的思路"></a>解耦的思路</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>发送消息时做消息备份（记日志或同步到数据库），判断sendResult是否正常返回</p><h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p><strong>节点保证</strong></p><ul><li>master接受到消息后同步刷盘，保证了数据持久化到了本机磁盘中</li><li>同步写入slave</li><li>写入完成后返回SendResult</li></ul><h4 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h4><ul><li>记日志</li><li>同步执行业务逻辑，最后返回ack</li><li>异常控制 </li></ul><p><strong>磁盘保证</strong></p><p>使用Raid磁盘阵列保证数据磁盘安全</p><p><strong>网络数据篡改</strong></p><p>内置TLS可以开启，默认使用crc32校验数据</p><h3 id="消息刷盘机制底层实现"><a href="#消息刷盘机制底层实现" class="headerlink" title="消息刷盘机制底层实现"></a>消息刷盘机制底层实现</h3><p>每间隔10ms，执行一次数据持久化操作</p><p>两种， 同步刷、异步刷</p><pre><code>   public void run() {            CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);            while (!this.isStopped()) {                try {                    this.waitForRunning(10);                    this.doCommit();                } catch (Exception e) {                    CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);                }            }</code></pre><h2 id="rocketMq的消息堆积如何处理"><a href="#rocketMq的消息堆积如何处理" class="headerlink" title="rocketMq的消息堆积如何处理"></a>rocketMq的消息堆积如何处理</h2><p><strong>下游消费系统如果宕机了，导致几百万条消息在消息中间件里积压，此时怎么处理?</strong></p><p><strong>你们线上是否遇到过消息积压的生产故障?如果没遇到过，你考虑一下如何应对?</strong></p><p>具体表现为 ui中转圈圈</p><p>对于大规模消息发送接收可以使用pull模式，手动处理消息拉取速度,消费的时候统计消费时间以供参考</p><p>保证消息消费速度固定，即可通过上线更多consumer临时解决消息堆积问题</p><h3 id="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"><a href="#如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？" class="headerlink" title="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"></a>如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</h3><ul><li>准备一个临时的topic</li><li>queue的数量是堆积的几倍</li><li>queue分不到多broker种</li><li>上线一台consumer做消息的搬运工，把原来topic中的消息挪到新的topic里，不做业务逻辑处理，只是挪过去</li><li>上线N台consumer同时消费临时topic中的数据</li><li>改bug</li><li>恢复原来的consumer，继续消费之前的topic</li></ul><h3 id="堆积时间过长消息超时了？"><a href="#堆积时间过长消息超时了？" class="headerlink" title="堆积时间过长消息超时了？"></a>堆积时间过长消息超时了？</h3><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时</p><h3 id="堆积的消息会不会进死信队列？"><a href="#堆积的消息会不会进死信队列？" class="headerlink" title="堆积的消息会不会进死信队列？"></a>堆积的消息会不会进死信队列？</h3><p>不会，消息在消费失败后会进入重试队列（%RETRY%+consumergroup），多次（默认16）才会进入死信队列（%DLQ%+consumergroup）</p><h2 id="你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的"><a href="#你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的" class="headerlink" title="你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?"></a>你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?</h2><h2 id="零拷贝等技术是如何运用的"><a href="#零拷贝等技术是如何运用的" class="headerlink" title="零拷贝等技术是如何运用的?"></a>零拷贝等技术是如何运用的?</h2><p>使用nio的MappedByteBuffer调起数据输出</p><h2 id="你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理"><a href="#你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理" class="headerlink" title="你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?"></a>你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?</h2><p>分布式系统中的事务可以使用TCC（Try、Confirm、Cancel）、2pc来解决分布式系统中的消息原子性</p><p>RocketMQ 4.3+提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p><h4 id="RocketMQ实现方式"><a href="#RocketMQ实现方式" class="headerlink" title="RocketMQ实现方式"></a>RocketMQ实现方式</h4><p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p><p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，等待下一次回调。</p><p><strong>超时：</strong>如果超过回查次数，默认回滚消息</p><h4 id="TransactionListener的两个方法"><a href="#TransactionListener的两个方法" class="headerlink" title="TransactionListener的两个方法"></a>TransactionListener的两个方法</h4><h5 id="executeLocalTransaction"><a href="#executeLocalTransaction" class="headerlink" title="executeLocalTransaction"></a>executeLocalTransaction</h5><p>半消息发送成功触发此方法来执行本地事务</p><h5 id="checkLocalTransaction"><a href="#checkLocalTransaction" class="headerlink" title="checkLocalTransaction"></a>checkLocalTransaction</h5><p>broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p><h5 id="本地事务执行状态"><a href="#本地事务执行状态" class="headerlink" title="本地事务执行状态"></a>本地事务执行状态</h5><p><strong>LocalTransactionState.COMMIT_MESSAGE</strong></p><p>执行事务成功，确认提交</p><p><strong>LocalTransactionState.ROLLBACK_MESSAGE</strong></p><p>回滚消息，broker端会删除半消息</p><p><strong>LocalTransactionState.UNKNOW</strong></p><p>暂时为未知状态，等待broker回查</p><h2 id="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现"><a href="#如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现" class="headerlink" title="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?"></a>如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?</h2><h2 id="看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解"><a href="#看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解" class="headerlink" title="看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?"></a>看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?</h2><h2 id="高吞吐量下如何优化生产者和消费者的性能"><a href="#高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="高吞吐量下如何优化生产者和消费者的性能?"></a>高吞吐量下如何优化生产者和消费者的性能?</h2><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>同一group下，多机部署，并行消费</li><li>单个consumer提高消费线程个数</li><li>批量消费<ul><li>消息批量拉取</li><li>业务逻辑批量处理</li></ul></li></ul><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><ul><li>网卡调优</li><li>jvm调优</li><li>多线程与cpu调优</li><li>Page Cache</li></ul><h2 id="再说说RocketMQ-是如何保证数据的高容错性的"><a href="#再说说RocketMQ-是如何保证数据的高容错性的" class="headerlink" title="再说说RocketMQ 是如何保证数据的高容错性的?"></a>再说说RocketMQ 是如何保证数据的高容错性的?</h2><ul><li>在不开启容错的情况下，轮询队列进行发送，如果失败了，重试的时候过滤失败的Broker</li><li>如果开启了容错策略，会通过RocketMQ的预测机制来预测一个Broker是否可用</li><li>如果上次失败的Broker可用那么还是会选择该Broker的队列</li><li>如果上述情况失败，则随机选择一个进行发送</li><li>在发送消息的时候会记录一下调用的时间与是否报错，根据该时间去预测broker的可用时间</li></ul><h2 id="Redis-面试题"><a href="#Redis-面试题" class="headerlink" title="Redis 面试题"></a>Redis 面试题</h2><p>高并发量大的话怎么处理热点数据<br>缓存击穿有哪些方案解决<br>什么是redis<br>Reids的特点<br>Redis支持的数据类型<br>Redis是单进程单线程的<br>虚拟内存<br>Redis锁<br>读写分离模型<br>数据分片模型<br>Redis的回收策略<br>使用Redis有哪些好处？<br>redis相比memcached有哪些优势？<br>redis常见性能问题和解决方案<br>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据<br>Memcache与Redis的区别都有哪些？<br>Redis 常见的性能问题都有哪些？如何解决？<br>Redis 最适合的场景</p><h2 id="熟悉-MySQL-关系型数据库"><a href="#熟悉-MySQL-关系型数据库" class="headerlink" title="熟悉 MySQL 关系型数据库"></a>熟悉 MySQL 关系型数据库</h2><h3 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h3><ol><li>客户端</li><li>Server 进程<ul><li>连接器：控制用户连接</li><li>分析器：词法分析、语法分析</li><li>优化器：优化 SQL，规定执行流程<ul><li>RBO</li><li>CBO</li></ul></li><li>执行器：执行组件</li></ul></li><li>存储引擎：不同的存放位置，不同的文件格式<ul><li>MyISAM：磁盘</li><li>Innodb：磁盘</li><li>Memory：内存</li></ul></li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="增删改操作时背后对应的原理"><a href="#增删改操作时背后对应的原理" class="headerlink" title="增删改操作时背后对应的原理"></a>增删改操作时背后对应的原理</h3><h3 id="Buffer-Pool-原理"><a href="#Buffer-Pool-原理" class="headerlink" title="Buffer Pool 原理"></a>Buffer Pool 原理</h3><p>Buffer Pool就是数据库的一个内存组件，具有完整的数据结构，里面缓存了磁盘上的真实数据，增删改操作首先就是针对这个内存中的Buffer Pool里的数据执行的，同时配合了后续的redo log、刷磁盘等机制和操作。</p><p>![crud](/Users/jinhongcai/Desktop/屏幕快照 2020-10-09 上午9.53.00.png)</p><h4 id="数据页：MySQL中抽象出来的数据单位"><a href="#数据页：MySQL中抽象出来的数据单位" class="headerlink" title="数据页：MySQL中抽象出来的数据单位"></a><strong>数据页：MySQL中抽象出来的数据单位</strong></h4><p>实际上MySQL对数据抽象出来了一个数据页的概念，他是把很多行数据放在了一个数据页里，也就是说我们的磁盘文件中就是会有很多的数据页，每一页数据里放了很多行数据</p><h4 id="磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？"><a href="#磁盘上的数据页和Buffer-Pool中的缓存页是如何对应起来的？" class="headerlink" title="磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？"></a><strong>磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？</strong></h4><p>缓存页 和 数据页 一一对应，每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的比如包含如下的一些东西：这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址以及别的一些杂七杂八的东西。</p><p>![屏幕快照 2020-10-09 上午10.21.16](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.21.16.png)</p><h4 id="数据库启动的时候，是如何初始化Buffer-Pool的？"><a href="#数据库启动的时候，是如何初始化Buffer-Pool的？" class="headerlink" title="数据库启动的时候，是如何初始化Buffer Pool的？"></a><strong>数据库启动的时候，是如何初始化Buffer Pool的？</strong></h4><p>数据库只要一启动，就会按照你设置的Buffer Pool大小，稍微再加大一点，去找操作系统申请一块内存区域，作为Buffer Pool的内存区域</p><p>然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的16KB的大小以及对应的800个字节左右的描述数据的大小，在Buffer Pool中划分出来一个一个的缓存页和一个一个的他们对应的描述数据</p><p>执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入Buffer Pool中的缓存页中</p><h4 id="我们怎么知道哪些缓存页是空闲的呢？"><a href="#我们怎么知道哪些缓存页是空闲的呢？" class="headerlink" title="我们怎么知道哪些缓存页是空闲的呢？"></a><strong>我们怎么知道哪些缓存页是空闲的呢？</strong></h4><p>数据库会为Buffer Pool设计一个<strong>free链表</strong></p><p>![屏幕快照 2020-10-09 上午10.33.10](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.33.10.png)</p><h4 id="如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？"><a href="#如何将磁盘上的数据页读取到Buffer-Pool的缓存页中去？" class="headerlink" title="如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？"></a><strong>如何将磁盘上的数据页读取到Buffer Pool的缓存页中去？</strong></h4><p>逻辑：</p><ol><li>Bufferpool 还会有一个哈希表数据结构，用表空间号+数据页号，作为一个key，然后缓存页的地址作为value</li><li>从free链表中找到一个空闲的缓存页</li><li>从磁盘上读取数据页写入缓存页</li><li>写入描述数据</li><li>从free指针清空</li></ol><p>![屏幕快照 2020-10-09 上午10.56.47](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午10.56.47.png)</p><h4 id="数据一致性问题？"><a href="#数据一致性问题？" class="headerlink" title="数据一致性问题？"></a>数据一致性问题？</h4><p>描述数据维护了flush 链表，flush 链表同 free 链表结构、作用相同，就是意义不同，描述缓存页是否是脏页</p><h4 id="缓存页淘汰问题？脏页淘汰机制"><a href="#缓存页淘汰问题？脏页淘汰机制" class="headerlink" title="缓存页淘汰问题？脏页淘汰机制"></a>缓存页淘汰问题？脏页淘汰机制</h4><p>![缓存命中率概念 + LRU 算法](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 上午11.21.52.png)</p><p>通过LRU维护了一个最近最少使用的 缓存页 结构。当需要加载数据页到缓存页，同时缓存页不足的情况下，就会通过LRU淘汰掉缓存命中率低的缓存页，触发刷盘机制。            </p><h4 id="什么是预读机制？"><a href="#什么是预读机制？" class="headerlink" title="什么是预读机制？"></a>什么是预读机制？</h4><p>从磁盘上加载一个数据页的时候，可能会把数据页相邻的其他数据页也加载到缓存里去</p><h4 id="什么情况会发生预读？"><a href="#什么情况会发生预读？" class="headerlink" title="什么情况会发生预读？"></a>什么情况会发生预读？</h4><ol><li>参数：innodb_read_ahead_theshold，默认值56。意思就是如果顺序的访问了一个区里的多个数据页，超过阈值，此时会触发预读机制，把下一个相邻区的所有数据页都加载到缓存里去</li><li>参数：innodb_random_read_ahead，默认 OFF。Buffer pool里缓存了一个区里的13个连续的数据页，而且这些数据页都是比较频繁会被访问，此时直接触发预读机制，当前区里其他数据页加载到缓存里</li><li>全表扫描，导致当前表空间内所有数据页全部加载到缓存页中</li></ol><h4 id="预读机制好处？"><a href="#预读机制好处？" class="headerlink" title="预读机制好处？"></a>预读机制好处？</h4><p>减少磁盘IO，提升性能</p><h4 id="什么场景会用到预读机制？预读带来的问题？"><a href="#什么场景会用到预读机制？预读带来的问题？" class="headerlink" title="什么场景会用到预读机制？预读带来的问题？"></a>什么场景会用到预读机制？预读带来的问题？</h4><p>发生预读，加载很多数据页到内存，这些缓存页未来可能都不会被访问到。如果free缓存页充足的情况下，没有问题。如果free不充足的情况，会将LRU上缓存页淘汰，但是很多预读的缓存页，在当前时刻可能是在 LRU 链表的头部区域，而经常被访问的缓存页，就会被优先淘汰，刷盘到磁盘</p><p>![预读问题](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.28.27.png)</p><h4 id="解决简单LRU链表带来的问题？"><a href="#解决简单LRU链表带来的问题？" class="headerlink" title="解决简单LRU链表带来的问题？"></a>解决简单LRU链表带来的问题？</h4><p>真正的LRU链表，会被拆分两部分，一部分热数据，一部分是冷数据，比例根据 innodb_old_blocks_pct 参数控制，默认37</p><p><img src="/Users/jinhongcai/Desktop/mysql/%E5%86%B7%E7%83%AD%E9%93%BE%E8%A1%A8%E6%8B%86%E5%88%86.png" alt="冷热链表拆分"></p><p>冷数据区域数据什么时候进入热数据区域，通过参数：innodb_old_blocks_time ，默认1000 ms，数据页被加载到缓存页 1s 后，访问当前缓存页，才会由冷数据区域挪动到热数据区域</p><p>![屏幕快照 2020-10-09 下午1.52.32](/Users/jinhongcai/Desktop/mysql/屏幕快照 2020-10-09 下午1.52.32.png)</p><h4 id="缓存数据刷盘"><a href="#缓存数据刷盘" class="headerlink" title="缓存数据刷盘"></a>缓存数据刷盘</h4><ol><li>定时通过后台线程，把冷数据区域尾部一些缓存页刷入磁盘。缓存页加入free链表、从flush链表移除、从lru链表移除</li><li>后台线程会在 mysql 不繁忙的时候，把flush链表中的缓存页刷入磁盘。flush、lru链表移除缓存页，free链表增加缓存页</li><li>无空闲缓存页，还需要加载数据页情况。先删掉LRU 冷数据区域尾部缓存页。</li></ol><h4 id="多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？"><a href="#多线程访问-Buffer-Pool-需要加锁吗？如果加锁，性能能高吗？" class="headerlink" title="多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？"></a>多线程访问 Buffer Pool 需要加锁吗？如果加锁，性能能高吗？</h4><p>由于是共享变量，必须加锁。性能不会低</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>缓存页加载到 Buffer Pool 中，更新和读取缓存页里的数据。涉及到 free、flush、lru 链表。还包括后台线程是如何定时根据 flush、lru 链表将部分更新的缓存页刷盘，以及缓存页用完了以后是如何根据 lru 链表将一些冷数据缓存页刷盘。如何避免每次 crud 频繁刷盘 + 加载缓存页 这种多次磁盘 IO 浪费性能的操作</p><h3 id="为什么不能直接更新磁盘上的数据？"><a href="#为什么不能直接更新磁盘上的数据？" class="headerlink" title="为什么不能直接更新磁盘上的数据？"></a>为什么不能直接更新磁盘上的数据？</h3><p>每一个请求如果直接对磁盘文件进行随机读写，然后更新磁盘里的数据，最终结果就是性能低，并发度低，根本无法承受高并发的请求</p><h3 id="为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？"><a href="#为什么-MySql-可以承受高并发请求，高性能是如何做到的呢？" class="headerlink" title="为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？"></a>为什么 MySql 可以承受高并发请求，高性能是如何做到的呢？</h3><p>通过内存更新数据，然后写 redo log 以及提交事物，后台再通过定时刷盘机制，保证了没个更新请求，尽量就是更新内存，然后顺序写日志文件。更新内存的性能极高，然后顺序写磁盘上的日志文件性能也是比较高。</p><h3 id="MySql-为什么要引入数据页？"><a href="#MySql-为什么要引入数据页？" class="headerlink" title="MySql 为什么要引入数据页？"></a>MySql 为什么要引入数据页？</h3><p>数据更新如果不直接更新磁盘，更新哪些数据，保存在哪？所有问题都需要一个介质来链接，那就是缓存页，把磁盘上的数据加载到内存，更新缓存数据，同时写 redo log 到磁盘上</p><p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E4%B8%8D%E4%BB%A5%E7%A3%81%E7%9B%98%E4%B8%BA%E5%AA%92%E4%BB%8B.png" alt="数据更新不以磁盘为媒介"></p><h3 id="每次加载多少数据到内存？"><a href="#每次加载多少数据到内存？" class="headerlink" title="每次加载多少数据到内存？"></a>每次加载多少数据到内存？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E6%95%B0%E6%8D%AE%E6%AF%8F%E6%AC%A1%E6%8C%89%E9%A1%B5%E7%BB%B4%E5%BA%A6%E5%8A%A0%E8%BD%BD.png" alt="数据每次按页维度加载"></p><h3 id="一行数据在磁盘上是如何存储的？包含哪些东西？"><a href="#一行数据在磁盘上是如何存储的？包含哪些东西？" class="headerlink" title="一行数据在磁盘上是如何存储的？包含哪些东西？"></a>一行数据在磁盘上是如何存储的？包含哪些东西？</h3><p>头字段描述 + 字段值</p><p>例如：”hello a a”，这一行数据具体有多少字段，都是什么，如果没有描述信息，根本无法解析</p><p>头字段描述 = 变长字段的长度列表，解决一行数据的读取问题</p><p>最终数据存储格式为：0x05 null值列表 数据头 hello a a </p><p>null值列表：所有允许为 NULL 的字段默认使用 bit表示，值为 NULL bit = 1 ，反之为 0，NULL 为什么不存 “NULL” 浪费空间</p><p>最终存储如下</p><pre><code>**变长字段列表 + NULL 值列表 + 字段头描述(40 bit ) + 隐藏字段 + 真实数据部分**</code></pre><p>隐藏字段</p><ol><li>DB_ROW_ID：数据库默认实现，行标识。</li><li>DB_TRX_ID：最近一次更新这条数据的事物id</li><li>DB_ROLL_PTR：回滚指针，事物回滚，指向你更新这个事务之前生成的 undo log</li></ol><p>每次数据变更都会更新隐藏字段</p><p>多事务串行更新一行数据，roll_poniter字段会把之前多个数据快照对应的undo log串联起来，形成重要的版本链</p><h3 id="ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"><a href="#ReadView-机制：通过-undo-log-版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值" class="headerlink" title="ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值"></a>ReadView 机制：通过 undo log 版本链条机制，保证你只能读到你事务开启前，别的事务提交更新的值，还有就是你自己事务更新的值</h3><p>触发时机：开启事务</p><p>关键结构：</p><ol><li>m_ids：未提交事务id集合</li><li>min_tx_id：未提交事务集合内最小事务id</li><li>max_tx_id：未提交事务id集合内最大事务id + 1</li><li>creator_tx_id：当前事务id</li></ol><p>原理</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>  可以读，数据的更新时间是在当前事务开启前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>      当前tx_id 是否存在 m_ids 内。存在就顺着 roll_poniter 日志链往下找，找到小于 min_trx_id 的记录    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="什么是行益出？"><a href="#什么是行益出？" class="headerlink" title="什么是行益出？"></a>什么是行益出？</h3><p>结合 Buffer Pool + 行数据在磁盘的存储结构，我们很容易就得到如下结论</p><p>一个 BufferPool 包含多个 <code>cache line</code> ，一个<code>cache line</code> 默认大小是 16KB，包含若干条行数据。如果行数据特别大或正巧一个磁盘数据页包含了半行数据，这样的数据如何处理。这样的问题也叫<code>行益出</code>，益出到其他数据页，存放益出数据页，也叫<code>益出页</code></p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>insert 一条数据的时候，实际上 mysql 是在内存插入了一个复杂的数据结构，这些有复杂结构的行数据会被刷新到磁盘</p><h3 id="NULL-为啥用-bit-表示？"><a href="#NULL-为啥用-bit-表示？" class="headerlink" title="NULL 为啥用 bit 表示？"></a>NULL 为啥用 bit 表示？</h3><p>存储空间问题</p><h3 id="为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？"><a href="#为什么用头描述-null-值列表。。。。方式存储行数据，而不是用类似-java-序列化的方式存储？" class="headerlink" title="为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？"></a>为什么用头描述 + null 值列表。。。。方式存储行数据，而不是用类似 java 序列化的方式存储？</h3><p>语言特性导致，不同语言如果用特定的序列化方式，跨语言将会反序列化异常。而数据库作为通用存储介质，不允许这种定制化存储方式来存储数据</p><h4 id="Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？"><a href="#Java-级别写了一个-SQL-语句，维度为-表名-条件（行）。如何对应到-MySql-中的-Buffer-Pool，维度为-表空间-缓存页-？" class="headerlink" title="Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？"></a>Java 级别写了一个 SQL 语句，维度为 表名 + 条件（行）。如何对应到 MySql 中的 Buffer Pool，维度为 表空间 + 缓存页 ？</h4><p>逻辑概念 = 只需要知道有哪些表，表里有哪些字段，表里有多少行，在哪存储并不关心</p><p>物理概念 = 表里的数据都是存储在一个表空间里，表空间是由一堆磁盘里的数据文件组成，这些数据文件就一个个数据页</p><h3 id="redo-log-作用-crash-safe"><a href="#redo-log-作用-crash-safe" class="headerlink" title="redo log 作用 crash safe"></a>redo log 作用 crash safe</h3><p>提交事物了，事物修改的缓存页没来得及刷盘，此时MySQL宕机了，会导致 buffer pool 里被事物修改过的数据全部丢失</p><p>只要有 redo log 重启MySQL之后完全可以把这些修改了的缓存页还未刷盘的事物操作，他们对应的 redo log 都加载出来，在 buffer pool 的缓存页重新做一遍，保证数据不丢失 【checkpoint lsb】</p><p>![curd 对应的 redo log 操作](/Users/jinhongcai/Desktop/mysql/curd 对应的 redo log 操作.png)</p><h3 id="事物执行了一半后，回滚了怎么办？什么逻辑？"><a href="#事物执行了一半后，回滚了怎么办？什么逻辑？" class="headerlink" title="事物执行了一半后，回滚了怎么办？什么逻辑？"></a>事物执行了一半后，回滚了怎么办？什么逻辑？</h3><p><img src="/Users/jinhongcai/Desktop/mysql/%E4%BA%8B%E7%89%A9%E6%89%A7%E8%A1%8C%E4%B8%80%E5%8D%8A%EF%BC%8C%E5%8F%91%E7%94%9F%E5%9B%9E%E6%BB%9A.png" alt="事物执行一半，发生回滚"></p><p>从目前的架构和流程来看，buffer pool 已经变更，redo log block 也写入若干条日志信息，无法完成回滚或恢复的操作。</p><p>如果想要回滚就需要另一个非常重要的日志组件，undo log 回滚日志</p><h3 id="undo-log-回滚日志-作用"><a href="#undo-log-回滚日志-作用" class="headerlink" title="undo log(回滚日志) 作用"></a>undo log(回滚日志) 作用</h3><p>回滚事物或叫恢复 buffer pool 里的缓存页数据</p><p>因为只有事物操作才会更新 buffer pool ，并且操作是不可逆的，事务操作包括 insert、update、delete 语句去更新缓存页的数据，但是万一事务回滚了，你必须有每条 SQL 语句对应的 undo log 回滚日志，根据回滚日志去恢复缓存页里被更新的数据</p><h3 id="undo-log-回滚日志是什么格式？如何存储？"><a href="#undo-log-回滚日志是什么格式？如何存储？" class="headerlink" title="undo log 回滚日志是什么格式？如何存储？"></a>undo log 回滚日志是什么格式？如何存储？</h3><p>undo log 文件格式<br>每种 DML 对应的文件格式都不同</p><p>INSERT<br>日志开始位置：指定位置进行磁盘随机读写<br>主键的各列长度和值：每条记录都有主键，id、联合主键等等，即使没有主动设置过主键字段，MySQL 也会给你弄一个 row_id 作为隐藏主键<br>表id：表维度标示<br>日志编号：没个undo log 都有自己的编号，例如一个事物里有多个 SQL 语句，事物内的 undo log 记录为一组，默认从0开始<br>日志类型：TRX_UNDO_INSERT_REC<br>日志结束位置：指定位置进行磁盘随机读写</p><p>插入操作回滚流程 ：<br>    buffer pool 缓存页里插入了一条数据，执行了 insert，生成了 INSERT undo log<br>    回滚时直接把这条 insert 语句的 undo log 拿出来，undo log 里有表id、主键信息就可以直接定位到对应的表空间 + 缓存页，从里面删除掉之前 insert 进去的数据</p><pre class=" language-java"><code class="language-java">crud 实现原理buffer pool 机制：找到表空间 <span class="token operator">-</span><span class="token operator">></span> 找到数据页 <span class="token operator">-</span><span class="token operator">></span> 加载到缓存页 <span class="token operator">-</span><span class="token operator">></span>更新缓存页 <span class="token operator">-</span><span class="token operator">></span>写 undo log <span class="token operator">-</span><span class="token operator">></span>写 redo log    数据结构    DescriptionDataBlock    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  数据块 对应redo、undo log 头文件中标记的 数据块编号     </span>        block_id <span class="token operator">=</span> block02<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  free 链表的前、后节点</span>        free_pre <span class="token operator">=</span> block01<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  未使用情况</span>        free_next <span class="token operator">=</span> block03<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  使用情况</span>        free_next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  flush 链表的前、后节点</span>        flush_pre <span class="token operator">=</span> null<span class="token punctuation">;</span>        flush_next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  基础节点，数据页映射到缓存页，变更基础信息</span>    FreeLinkedListBaseNode    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  指向开始和结束节点指针</span>        start <span class="token operator">=</span> block01<span class="token punctuation">;</span>        end <span class="token operator">=</span> block03<span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  基础节点，缓存页更新过，当前节点就为脏节点</span>    FlushLinkedListBaseNode    <span class="token punctuation">{</span>        start <span class="token operator">=</span> block02<span class="token punctuation">;</span>        end <span class="token operator">=</span> block02<span class="token punctuation">;</span>        count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//  冷热数据区划分等情况</span>    LRUBaseNode    <span class="token punctuation">{</span>        start    <span class="token punctuation">}</span>undo log 机制：事物回滚流程redo log 机制：由于事物提交后，并没有把事物更新的缓存页进行刷盘，很容易丢数据，同时也保证了 MySQL 高性能。所以在事物提交后，把对缓存页的修改以日志的形式写入 redo log，以保证修改的数据不丢失保证核心疑问点：把缓存页刷盘，跟你做的 redo log 都写入日志文件，都是磁盘操作，有什么差别？ A：二个方面来回答    <span class="token number">1</span>。刷盘方式        缓存页采用的是磁盘随机读写        类似 datafile<span class="token punctuation">.</span>locatexxx            datafile<span class="token punctuation">.</span>writexxxx        redo log 文件采用的是磁盘顺序写            引入 mmap 原理    <span class="token number">2</span>。磁盘IO，数据量的大小很关键        缓存页大小 16KB【有可能你只修改了缓存页里的几个<span class="token keyword">byte</span>，也要把整个缓存页都刷盘吗，浪费资源】        redo log 大小 521byte磁盘加载数据页 <span class="token operator">-</span><span class="token operator">></span> buffer pool <span class="token operator">-</span><span class="token operator">></span> 变更缓存页 <span class="token operator">-</span><span class="token operator">></span> 记录 undo log、redo logredo log 文件格式磁盘上存在若干个可以指定大小的 redo log 磁盘文件MySQL 进程内有一块 redo log buffer 缓存区域默认 16M，里面存放大量 redo log block对象<span class="token punctuation">(</span>一种复杂的数据结构<span class="token punctuation">)</span>redo log block<span class="token punctuation">{</span>       header 12byte    <span class="token punctuation">{</span>        块编号        写入数据长度        日志分组偏移量        checkpoint no    <span class="token punctuation">}</span>        body <span class="token number">496</span> <span class="token keyword">byte</span>    <span class="token punctuation">{</span>        日志类型 <span class="token operator">+</span> 表空间ID <span class="token operator">+</span> 缓存页号 <span class="token operator">+</span> 偏移量 <span class="token operator">+</span> 修改里几个字节值 <span class="token operator">+</span> 具体值    <span class="token punctuation">}</span>    trailer <span class="token number">4</span> <span class="token keyword">byte</span><span class="token punctuation">}</span></code></pre><h3 id="事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行"><a href="#事物：一个事物包含了一个或多个-SQL-语句，当前模型下，每个-SQL-语句都是串行化执行" class="headerlink" title="事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行"></a>事物：一个事物包含了一个或多个 SQL 语句，当前模型下，每个 SQL 语句都是串行化执行</h3><h3 id="多事务并发执行带来的问题"><a href="#多事务并发执行带来的问题" class="headerlink" title="多事务并发执行带来的问题"></a>多事务并发执行带来的问题</h3><p>脏读：读取到了其他事物更新过但未提交的数据<br>脏写：更新了其他事物更新过但未提交的数据<br>不可重复读：事物内对于同一共享变量，应该是可重复读的。不可重复读就是读取其他事物对同一共享变量修改过后并提交了事物的值<br>幻读：事物内查询到之前没有看到过的数据         </p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><h5 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h5><table><thead><tr><th align="center">隔离级别/问题</th><th align="center">脏读/脏写</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">read uncommited</td><td align="center">V</td><td align="center">V</td><td align="center">V</td></tr><tr><td align="center">read commited</td><td align="center">X</td><td align="center">V</td><td align="center">V</td></tr><tr><td align="center">repeatable read</td><td align="center">X</td><td align="center">X</td><td align="center">V</td></tr><tr><td align="center">serializer read</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table><h4 id="MVCC机制"><a href="#MVCC机制" class="headerlink" title="MVCC机制"></a>MVCC机制</h4><p>原理：undoLog 多版本链条机制 + ReadView 视图机制</p><h4 id="MySQL-的-RR-如何实现避免幻读问题"><a href="#MySQL-的-RR-如何实现避免幻读问题" class="headerlink" title="MySQL 的 RR 如何实现避免幻读问题"></a>MySQL 的 RR 如何实现避免<code>幻读</code>问题</h4><p>RC：每次发起查询，都重新生成一个ReadView视图，每次查询都会更新 活跃事务id 列表，未在列表内且在最大事务id范围内的事务则是已提交事务</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id <span class="token operator">||</span> tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      可以读，数据的更新时间是在当前事务开启前就已经提交了    可以读，说明当前数据在生成 ReadView 之前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>RR：事务开启后，只会有一个 ReadView 视图，不会更新 活跃事务id 列表</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>tx_id <span class="token operator">==</span> creator_tx_id <span class="token operator">||</span> tx_id<span class="token operator">&lt;</span>min_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>  可以读，数据的更新时间是在当前事务开启前就已经提交了<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">></span> max_tx_id<span class="token punctuation">)</span><span class="token punctuation">{</span>        不可读，当前事务开启后，新的事务操作的数据，顺着 undoLog 继续往下找 tx_id，只到 tx_id 满足第一个 <span class="token keyword">if</span> 条件    <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>tx_id <span class="token operator">&lt;</span> max_tx_id <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>m_ids<span class="token punctuation">.</span><span class="token function">isContains</span><span class="token punctuation">(</span>tx_id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      可以读，说明当前数据在生成 ReadView 之前就已经提交了  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="MVCC-和-隔离级别关系"><a href="#MVCC-和-隔离级别关系" class="headerlink" title="MVCC 和 隔离级别关系"></a>MVCC 和 隔离级别关系</h3><p>早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。</p><p>对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化。有的数据库内建乐观锁，但是有的没有（比如MySQL就没有），所以需要开发人员自己在数据表里加version列，自己写业务代码实现。</p><blockquote><p>顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度</p><p>如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p></blockquote><p>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是<strong>对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁</strong>。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。</p><p>这样，实现两个隔离级别就非常容易：</p><ul><li>Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本</li><li>Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）</li></ul><p>也可以主动添加共享锁</p><ul><li>select…… lock in share mode</li></ul><p>MVCC并不是万灵药。大量的业务问题的关键点在于，<strong>你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效</strong>。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景</p><p>在这种场景下</p><ul><li>在MySQL InnoDB，使用者会使用<code>select ... for update</code>手工加锁。或者干脆用Serializable隔离级别</li></ul><h3 id="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"><a href="#锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题" class="headerlink" title="锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题"></a>锁机制：多事务更新同一行数据的时候串行化，避免同时更新统一行数据带来的问题</h3><table><thead><tr><th align="center">锁类型</th><th align="center">独占锁</th><th align="center">共享锁</th></tr></thead><tbody><tr><td align="center">独占锁</td><td align="center">互斥</td><td align="center">互斥</td></tr><tr><td align="center">共享锁</td><td align="center">互斥</td><td align="center">不互斥</td></tr></tbody></table><p>基于MVCC的并发读，是不需要加锁，根据隔离级别选择读取对应的版本，但是也可以主动加读锁 - 共享锁</p><h3 id="undo-log-写入时机"><a href="#undo-log-写入时机" class="headerlink" title="undo log 写入时机"></a>undo log 写入时机</h3><p>![undo log 回滚日志的写入时机](/Users/jinhongcai/Desktop/mysql/undo log 回滚日志的写入时机.png)</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h2 id="锁的底层机制"><a href="#锁的底层机制" class="headerlink" title="锁的底层机制"></a>锁的底层机制</h2><h2 id="索引底层原理"><a href="#索引底层原理" class="headerlink" title="索引底层原理"></a>索引底层原理</h2><h2 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h2><p>Buffer Pool（数据页 = 内存级别更新速度） 磁盘随机写</p><p>redo log 磁盘顺序写</p><p>undo log 磁盘顺序写</p><h2 id="查询优化的底层原理"><a href="#查询优化的底层原理" class="headerlink" title="查询优化的底层原理"></a>查询优化的底层原理</h2><h2 id="数据库的建模"><a href="#数据库的建模" class="headerlink" title="数据库的建模"></a>数据库的建模</h2><h2 id="在数据库建模的时候，应该如何注意字段类型"><a href="#在数据库建模的时候，应该如何注意字段类型" class="headerlink" title="在数据库建模的时候，应该如何注意字段类型"></a>在数据库建模的时候，应该如何注意字段类型</h2><h2 id="索引类型的一些问题"><a href="#索引类型的一些问题" class="headerlink" title="索引类型的一些问题"></a>索引类型的一些问题</h2><h2 id="如何保证数据库避免死锁、高性能的运行"><a href="#如何保证数据库避免死锁、高性能的运行" class="headerlink" title="如何保证数据库避免死锁、高性能的运行"></a>如何保证数据库避免死锁、高性能的运行</h2><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><ol><li><p>必要性，sql 慢，分析具体是哪个步骤慢</p><ul><li>方法 show profile show processlist 晋级版本 - performance schema</li></ul></li><li><p>针对具体步骤进行优化，一般都是 执行阶段，执行阶段一般就是索引优化</p><ul><li>有没有索引</li><li>走没走索引</li></ul></li></ol><h3 id="类型优化"><a href="#类型优化" class="headerlink" title="类型优化"></a>类型优化</h3><p>越小越好</p><p>越简单越好</p><p>避免使用 NULL</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h5 id="数据库连接池有哪些？"><a href="#数据库连接池有哪些？" class="headerlink" title="数据库连接池有哪些？"></a>数据库连接池有哪些？</h5><p>DBCP</p><p>C3P0</p><p>druid</p><h5 id="索引是什么？如何实现？优缺点？用途？分类？技术点？"><a href="#索引是什么？如何实现？优缺点？用途？分类？技术点？" class="headerlink" title="索引是什么？如何实现？优缺点？用途？分类？技术点？"></a>索引是什么？如何实现？优缺点？用途？分类？技术点？</h5><pre class=" language-html"><code class="language-html">索引：一种特殊的数据结构实现1.文件操作 -> IO 操作、磁盘文件操作2.复杂的数据结构参考结构1.hash表2.二叉树3.AVL树4.read-black5.B Tree6.B+ Tree优点1.大大减少服务器扫描的数据量2.随机 IO -> 顺序 IO缺点1.增删改操作需要维护索引结构2.需要额外的空间来存储索引数据</code></pre><pre class=" language-html"><code class="language-html">用途1.where 子句2.排序和分组可以利用索引天然的顺序特性，加快查询效率3.可以使用 min max 函数</code></pre><table><thead><tr><th align="center">索引分类</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">主键</td><td align="center">主键列，值不为空</td></tr><tr><td align="center">唯一</td><td align="center">唯一列，值可以为空</td></tr><tr><td align="center">普通</td><td align="center">普通列</td></tr><tr><td align="center">联合</td><td align="center">多个普通列</td></tr><tr><td align="center">全文</td><td align="center"></td></tr></tbody></table><table><thead><tr><th align="center">技术点</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">回表</td><td align="center">非主键索引树，获取到主键后，再次进行主键索引树查询</td></tr><tr><td align="center">覆盖索引</td><td align="center">不进行回表的查询行为</td></tr><tr><td align="center">最左匹配</td><td align="center">联合索引，where 子句 条件顺序要满足 联合索引顺序，才可以走索引树</td></tr><tr><td align="center">索引下推</td><td align="center">联合索引下，在存储引擎内完成数据的检索</td></tr><tr><td align="center">索引合并</td><td align="center"></td></tr></tbody></table><p>mysql的三大引擎是啥？ 文件存储结构、索引类型、索引结构、事务、锁级别、使用场景<br>    mysql常用的引擎有InnoDB，MyISAM，Memory，默认是InnoDB<br>    InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引<br>    ps:优点：具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。<br>    缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大</p><pre><code>MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引ps: 优点：占用空间小，处理速度快（相对InnoDB来说）缺点：不支持事务的完整性和并发性MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型ps: 优点：速度要求快的，临时数据缺点：丢失数据myisam读的效果好，写的效率差，这和它数据存储格式，索引的指针和锁的策略有关的，它的数据是顺序存储的，他的索引btree上的节点是一个指向数据物理位置的指针，所以查找起来很快innodb支持行锁，行锁是加在索引上的，不是加在数据记录上的，如果sql没有用到索引，仍然会锁定表,mysql的读写之间是可以并发的普通的select是不需要锁的，当查询的记录遇到锁时，用的是一致性的非锁定快照读，也就是根据数据库隔离级别策略，会去读被锁定行的快照，其它更新或加锁读语句用的是当前读，读取原始行因为普通读与写不冲突，所以innodb不会出现读写饿死的情况，又因为在使用索引的时候用的是行锁，锁的粒度小，竞争相同锁的情况就少，就增加了并发处理，所以并发读写的效率还是很优秀的，问题在于索引查询后的根据主键的二次查找导致效率低</code></pre><p>innodb对一行数据的读会加锁吗<br>    早期数据库不论读取还是写入，都用锁来实现。但是锁会带来性能的问题。人们尝试各种优化方案。写入和读取的优化方式不同。<br>    对于数据库写入操作，没有特别好的办法，因为无论如何要避免并发修改一个数据，就得靠锁。不同的数据库对于写入操作都会加悲观锁（比如MySQL是X锁）。为了避免X锁带来的性能问题，人们在合适的场合会选择用乐观锁来优化，所以需要开发人员自己在数据表里加version列，自己写业务代码实现。<br>    顺便提一句，乐观锁并不一定总是比悲观锁性能表现更好，这要看竞争的程度<br>        如果数据访问竞争的非常厉害，乐观锁只会让CPU和IO白白浪费而已。</p><pre><code>对于读取，优化就是MVCC。MVCC的意思用简单的话讲就是对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。这样读某一个数据时，事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁。这样，实现两个隔离级别就非常容易：Read Committed - 一个事务读取数据时总是读这个数据最近一次被commit的版本Repeatable Read - 一个事务读取数据时总是读取当前事务开始之前最后一次被commit的版本（所以底层实现时需要比较当前事务和数据被commit的版本号）也可以主动添加共享锁select…… lock in share modeMVCC并不是万灵药。大量的业务问题的关键点在于，你在提交一个事务那一刹那，你提交事务的所有修改依赖的读取是否都还有效。对于这种场景，无论是Read Committed还是Repeatable Read都没有什么卵用。比如扣库存就是这样典型的业务场景在这种场景下，在MySQL InnoDB，使用者会使用select ... for update手工加锁。或者干脆用Serializable隔离级别</code></pre><p>mysql是如何实现事务的<br>    undo log 回滚日志<br>    redo log 重做日志</p><p>MySQL事务特性和隔离级别<br>    ACID<br>    RR<br>    RU<br>    RC<br>    S</p><p>mysql的默认隔离级别<br>    RR</p><p>mysql的binlog<br>    主从复制也需要依靠binlog</p><pre><code>binlog 存在于Mysql Server层中，主要用于数据恢复；当数据被误删时，可以通过上一次的全量备份数据加上某段时间的binlog将数据恢复到指定的某个时间点的数据。redo log 存在于InnoDB 引擎中，InnoDB引擎是以插件形式引入Mysql的，redo log的引入主要是为了实现Mysql的crash-safe能力。statement：statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.row：row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter able),因此这种模式的文件保存的信息太多,日志量太大.mixed：mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</code></pre><p>主从复制<br>读写分离何时强制要读主库，读哪个从库是通过什么方式决定的，从库的同步mysql用的什么方式</p><p>索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；<br>聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。<br>聚簇索引：有主键时，根据主键创建聚簇索引<br>        没有主键时，会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引<br>        如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引</p><p>非聚簇索引：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引</p><p>B+树和B树区别？<br>B树的非叶子节点存储实际记录的指针，而B+树的叶子节点存储实际记录的指针<br>B+树的叶子节点通过指针连起来了, 适合扫描区间和顺序查找。</p><p>查看 SQL 是不是使用了索引？<br>    执行计划</p><p>mysql的级锁加在哪个位置<br>表级：直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许<br>行级：仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。<br>页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p><p>索引的类型<br>    主键<br>    唯一<br>    普通<br>    联合<br>    全文</p><p>redo log的概念是什么？为什么会存在？<br>    在思考这个问题之前，我们可以先看看MySQL INNODB执行一条update语句的流程<br>    1.将数据所在的数据页加载到BufferPool对应的缓存页(事务开始)<br>    2.将数据的旧值写入到undolog中<br>    3.更新数据在BufferPool中的值<br>    4.写redolog日志<br>    5.写binlog归档日志<br>    6.事务提交，在redolog中写commit标记<br>    7.数据会在之后的某个时刻刷入硬盘中的数据页<br>    redolog其实就是上面第四步的操作，他记录的是数据修改之后的值，他的意义在于，当我们事务提交之后但bufferpool中修改后的数据还没有刷入磁盘的时候机器宕机了，那么我们就可以根据redolog中的日志来恢复内存中的数据</p><p>那为什么不直接在提交事务的将修改的数据刷入硬盘？<br>    原因有以下几点：<br>    1.数据在内存中修改的数据很快，但磁盘随机写很慢<br>    2.数据在磁盘和内存中是以页为单位的，默认是16kb，假如你就改了一天数据的某个属性就需要将这一整个数据页刷入硬盘，效率很低。而redolog就快很多，首先他不是随机在磁盘写    ，而是通过追加的方式写入redolog文件，速度快很多，然后他也不是直接往硬盘中的redolog文件写，而是先写入redologbuffer（默认大小16mb）中的redologblock（默认大小512字节）这个内存结构中，首先往redologbuffer中写的很快，然后会在极短时间内以redolog block为单位刷入到磁盘，这样的话性能就会很高</p><pre><code>redolog刷盘点 - page cache，由操作系统保证数据可靠性    1.写满8M    2.事务commit</code></pre><p>什么是WAL机制？好处是什么？<br>    (1).将redo log写入到buffer中的block中<br>    (2).调用写磁盘操作,这一步将redo log buffer中的 block 日志写到操作系统中的page cache里面。<br>    (3).调用os的fsync操作,将page cache中的redolog日志落盘,落盘之后数据便在磁盘上了</p><pre><code>上面就是WAL机制在redo log刷盘过程中的具体实现,其实我的理解就是将日志先写到内存中,然后某个时间在刷入磁盘,日志异步落盘。其实把数据从内存写入到磁盘看似就一个操作(1).从磁盘随机写变成顺序写,性能提升巨大(2).组提交,上面redolog的执行步骤第三步,调用fsync可以同时将多次第二步write操作写入到pagecache的数据一批落盘,这样的话就大量的减少了iops,减少磁盘压力</code></pre><p>redo log为什么能保证crash safe机制？<br>    MySQL通过两阶段提交的方式来保证CrashSafe。CrashSafe需要Server层、Binlog和InnoDB的协同工作才能完成。由于DDL和MyISAM不支持事务性，因此没办法保证CrashSafe</p><p>redo log和bin log 不同点有哪些？<br>    Redo Log是属于InnoDB引擎功能;Binlog是属于MySQL Server自带功能，所有引擎都可以使用，并且是以二进制文件记录。<br>    Redo Log属于物理日志，记录该数据页更新状态内容;Binlog是逻辑日志，记录更新操作语句的原始逻辑。<br>    Redo Log日志是循环写，日志空间大小是固定;Binlog是追加写入，写完一个写下一个，不会覆盖使用。<br>    Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力</p><p>什么是两阶段提交？为什么需要两阶段提交？两阶段提交如何保证数据库中两份日志间的逻辑一致性？<br>执行器在执行update语句时候的流程是什么样子的？<br>如果不是两阶段提交，先写binlog和先写redolog两种场景，各会遇到什么问题？<br>如何使用缓冲实现惰性B树？</p><p>Q：mysql对于千万级的大表如何优化？<br>很多人第一反应是各种切分；<br>我给的顺序是:<br>第一优化你的sql和索引；<br>第二加缓存，memcached,redis；<br>第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；<br>第四如果以上都做了还是慢，不要想着去做切分，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；<br>第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；<br>第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的shardingkey,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p><p>有人也许要说第一步优化sql和索引这还用说吗？的确，大家都知道，但是很多情况下，这一步做的并不到位，甚至有的只做了根据sql去建索引，根本没对sql优化（中枪了没？），除了最简单的增删改查外，想实现一个查询，可以写出很多种查询语句，不同的语句，根据你选择的引擎、表中数据的分布情况、索引情况、数据库优化策略、查询中的锁策略等因素，最终查询的效率相差很大；优化要从整体去考虑，有时你优化一条语句后，其它查询反而效率被降低了，所以要取一个平衡点；即使精通mysql的话，除了纯技术面优化，还要根据业务面去优化sql语句，这样才能达到最优效果</p><p>mysql怎么实现redo log和binlog的一致性<br>    伪2pc分布式事务</p><h2 id="熟悉-GC常用算法，熟悉常见垃圾收集器，具有-JVM-调优经验"><a href="#熟悉-GC常用算法，熟悉常见垃圾收集器，具有-JVM-调优经验" class="headerlink" title="熟悉 GC常用算法，熟悉常见垃圾收集器，具有 JVM 调优经验"></a>熟悉 GC常用算法，熟悉常见垃圾收集器，具有 JVM 调优经验</h2><h2 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h2><p>Java 类加载过程？<br>描述一下 JVM 加载 Class 文件的原理机制?<br>Java 内存分配。<br>如何判断一个对象是否存活？（或者 GC 对象的判定方法）<br>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？<br>System.gc() 和 Runtime.gc() 会做什么事情？<br>finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？<br>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？<br>什么是分布式垃圾回收（DGC）？它是如何工作的？<br>串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？<br>在 Java 中，对象什么时候可以被垃圾回收？<br>简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。<br>JVM 的永久代中会发生垃圾回收么？<br>Java 中垃圾收集的方法有哪些？<br>什么是类加载器，类加载器有哪些？<br>类加载器双亲委派模型机制？<br>3.JVM怎么监控<br>4.OOM没有heap文件怎么办?<br>    查看JVM配置是否配置oom导出dump文件，配置是否正确，一般合理的配置内存使用率来生成内存快照文件，不用非要oom后才生成快照文件<br>    配置方式<br>        一、<br>            jmap -dump:format=b,file=/usr/local/base/02.hprof 12942<br>        二、<br>            -XX:+HeapDumpOnOutOfMemoryError<br>            -XX:HeapDumpPath=/usr/local/base<br>    分析方式<br>        一、MAT<br>        二、在线分析</p><pre><code>如果未配置可以通过查看log去分析，同时赶紧配置自动导出dump配置，以应对以后的oom，能通过log去看出问题的原因一般很简单，例如：死循环、查询服务为分页获取了全量的数据，这些可以通过log很快定位。</code></pre><p>synchronized在jvm层面上是如何实现的？<br>Jvm的方法区存储了什么，有什么作用？<br>java堆的内存分配？<br>eden区和survivior区的比例，为什么survivor区分为俩块？<br>full GC问题如何定位？<br>java内存模型，垃圾回收机制，不可达算法？<br>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范，简化到什么地步？就是主内存，各个线程的工作内存，和CPU，而我们怎么在这一套内存模型中工作<br>read（从主存读取），load（将主存读取到的值写入工作内存），use（从工作内存读取数据来计算），assign（将计算好的值重新赋值到工作内存中），store（将工作内存数据写入主存），write（将store过去的变量值赋值给主存中的变量）<br>jvm的一些命令？<br>jps jstat -gc (查看gc情况)<br>jmap pid（查看进程内存状态）<br>jmap -heap pid（查看进程的堆状态）<br>jmap -histo PID这里会生成一个类的统计报表，此表非常简单，如显示什么类有多少个实例，共占了多少字节等<br>jmap -dump:format=b,file=heapdump.phrof pid （生成堆的快照文件）<br>jhat是一个Java堆复制浏览器。这个工具分析Java堆复制文件（例如，由上面的”jmap -dump”所产生的）<br>jstack 查看线程上下文<br>jinfo pid 描述：输出当前 jvm 进程的全部参数和系统属性</p><p>如何把java内存的数据全部dump出来？<br>答：1、获取内存详情：jmap -dump:format=b,file=e.bin pid<br>这种方式可以用 jvisualvm.exe 进行内存分析，或者采用 Eclipse Memory Analysis Tools (MAT)这个工具</p><ol start="2"><li>获取内存dump： ?jmap -histo:live pid<br>这种方式会先出发fullgc，所有如果不希望触发fullgc 可以使用jmap -histo pid</li></ol><p>3.第三种方式：jdk启动加参数：<br>-XX:+HeapDumpBeforeFullGC?<br>-XX:HeapDumpPath=httxlogsdump<br>这种方式会产生dump日志，再通过jvisualvm.exe 或者Eclipse Memory Analysis Tools 工具进行分析</p><p>如何手动触发全量回收垃圾，如何立即触发垃圾回收<br>静态内部类加载到了哪个区？方法区<br>class文件编译后加载到了哪<br>java虚拟机的区域分配，各区分别存什么<br>jvm的内存布局，垃圾回收机制<br>类加载机制里的，双亲委派模型</p><p>什么是Java虚拟机，为什么要使用？</p><p>说说Java虚拟机的生命周期及体系结构。</p><p>说一说Java内存区域。<br>Java虚拟机中，数据类型可以分为哪几类？</p><p>怎么理解栈、堆？堆中存什么？栈中存什么？</p><p>为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？</p><p>在Java中，什么是是栈的起始点，同是也是程序的起始点？</p><p>为什么不把基本类型放堆中呢？</p><p>Java中，栈的大小通过什么参数来设置？</p><p>讲一讲垃圾回收算法。</p><p>如何解决内存碎片的问题？</p><p>如何解决同时存在的对象创建和对象回收问题？</p><p>讲一讲内存分代及生命周期。</p><p>什么情况下触发垃圾回收？</p><p>如何选择合适的垃圾收集算法？</p><p>JVM中最大堆大小有没有限制？</p><p>堆大小通过什么参数设置？</p><p>JVM有哪三种垃圾回收器？</p><p>吞吐量优先选择什么垃圾回收器？响应时间优先呢？</p><p>如何进行JVM调优？有哪些方法？</p><p>如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？JVM内存模型，GC机制和原理；GC分哪两种；什么时候会触发Full GC？</p><p>JVM里的有几种classloader，为什么会有多种？</p><p>什么是双亲委派机制？介绍一些运作过程，双亲委派模型的好处；(这个我真的不会…)</p><p>什么情况下我们需要破坏双亲委派模型；</p><p>常见的JVM调优方法有哪些？可以具体到调整哪个参数，调成什么值？</p><p>JVM虚拟机内存划分、类加载器、垃圾收集算法、垃圾收集器、class文件结构是如何解析的；<br>happens before 原理<br>进程没有挂，但是没响应了了怎么查原因?<br>    手动生成：java core和dump文件分析cup和内存<br>    cpu:是否正在大量的计算占用了全部资源<br>    模拟请求：查看响应码和数据<br>    日志：查看请求日志，看是否有交互，定位是客户端问题还是服务端问题<br>    。。。。。<br>堆栈溢出一般什么情况下发⽣生,怎么应对<br>    堆溢出<br>        堆空间：空间不足<br>        栈空间：新建立线程的时候没有足够的内存去创建对应的虚拟机栈<br>        元数据空间：原来的class没有被卸载掉<br>                  如果应用程序本身比较大，涉及的类库比较多，但是我们分配给持久带的内存（通过-XX:PermSize和-XX:MaxPermSize来设置）比较小的时候也可能出现此种问题。<br>                  一些第三方框架，比如spring,hibernate都通过字节码生成技术（比如CGLib）来实现一些增强的功能，这种情况可能需要更大的方法区来存储动态生成的Class文件</p><pre><code>栈溢出    栈的深度超过了虚拟机容许的最大深度所致：死循环、递归所致    栈空间太小 XSS指定</code></pre><p>gc的策略，线上你遇到的问题，如何查看outofmemery,如果没有dump文件，该怎么排查；你们老年代用的那种收集器</p><h1 id="大促、备战需要做什么"><a href="#大促、备战需要做什么" class="headerlink" title="大促、备战需要做什么"></a>大促、备战需要做什么</h1><h2 id="面试题汇总"><a href="#面试题汇总" class="headerlink" title="面试题汇总"></a>面试题汇总</h2><ul><li><p>项目有没有进行 mysql 调优，如何做的？为什么这么做？</p><ul><li><pre class=" language-html"><code class="language-html">- 查询语句无论是使用哪种判断条件 **等于、小于、大于**， `WHERE` 左侧的条件查询字段不要使用函数或者表达式- 使用 `EXPLAIN` 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分析，进行优化。- 当你的 SELECT 根据业务合理使用 limit- 为每一张表设置一个 ID 属性- 避免在 `WHERE` 字句中对字段进行 `NULL` 判断- 避免在 `WHERE` 中使用 `!=` 或 `&lt;>` 操作符- 使用 `BETWEEN AND` 替代 `IN`- 为搜索字段创建索引- 选择正确的存储引擎，InnoDB 、MyISAM 、MEMORY 等- 最左匹配原则- 对于枚举类型的字段(即有固定罗列值的字段)，建议使用`ENUM`而不是`VARCHAR`，如性别、星期、类型、类别等- 拆分大的 DELETE 或 INSERT 语句- 选择合适的字段类型，选择标准是 **尽可能小、尽可能定长、尽可能使用整数**。- 字段设计尽可能使用 `NOT NULL`</code></pre></li></ul></li><li><p>mysql 事务隔离级别知道吗？</p><ul><li>RU</li><li>RC</li><li>RR</li><li>serializable</li></ul></li><li><p>mvcc了解吗？mvcc 解决了什么问题？</p><ul><li>事务可以根据隔离级别选择要读取哪个版本的数据。过程中完全不需要加锁</li><li>通过 readview + undolog 基于 RC + RR</li><li>readView 视图机制描述一下</li><li>undo log 版本描述一下</li><li>RC 事务隔离级别存在的问题描述一下</li><li>RR 事务隔离级别存在的问题描述一下</li></ul></li><li><p>redis 项目中使用了吗？怎么用的？</p><ul><li>五大value类型描述，各个类型的使用场景</li></ul></li><li><p>redis 的数据结构你知道的说一下</p></li><li><p>redis 常见问题以及解决方案（雪崩、穿透、击穿）</p></li><li><p>跳表、布隆过滤器数据结构说一下。有什么使用场景、好处。</p></li><li><p>redis 集群，项目中如何使用的</p></li><li><p>redis 内存淘汰策略</p></li><li><p>juc 包下用过哪些类，有没有看过源码</p></li><li><p>线程池执行过程</p></li><li><p>线程池淘汰策略</p></li><li><p>AQS 原理</p></li><li><p>手写 LRU 算法</p></li><li><p>Object 类了解吗？有哪些方法，具体说下每个方法的作用。</p></li><li><p>说下你了解的设计模式，项目中如何使用的。</p></li><li><p>设计模式的 8 大原则知道吗？开闭原则你如何理解的。</p></li><li><p>hashMap 了解吗？底层数据结构是什么，有没有看过源码，扩容机制了解吗？</p></li><li><p>mysql 了解吗？索引底层数据结构，为什么是 B+ 树。</p><ul><li>mysql 架构描述一下，最主要是三层结构，各层内的组件和功能</li><li>B+ 树的结构特点</li></ul></li><li><p>mysql 事务的原子性实现原理</p><ul><li>redo log + undo log</li></ul></li><li><p>说下 juc 下的 lock</p></li><li><p>线程池的参数以及各自的作用</p></li><li><p>介绍一个自己熟悉的项目，主要是业务逻辑。</p></li><li><p>项目中的难点，哪些地方做的不好有什么改进的方法。</p></li><li><p>设计一个可以支撑峰值20万QPS，5千写库操作的系统。</p></li><li><p>系统设计（上一个问题）的缺陷在哪里，如何解决</p></li><li><p>介绍一下自己做的最好的一个项目，有哪些亮点。具体说一下细节。</p></li><li><p>数据库与缓存一致性解决方案，不同方案适用场景以及存在的问题。</p></li><li><p>设计一个支撑 10 万 QPS 的系统查看当前滴滴司机查看历史订单的系统。</p></li><li><p>手写一个时间复杂度为O（n），空间复杂度为O（1）的将一个单链表转为为一个新的按照奇偶顺序的新的单链表。</p></li><li><p>hashMap 底层数据结构，扩容过程。树化的条件，平时项目怎么使用的。</p></li><li><p>synchronized 和 lock 的区别。各自实现原理</p></li><li><p>说说你对并发中的原子性、可见性、有序性的理解</p></li><li><p>线程有几个状态？线程池各个参数说一下</p></li><li><p>jvm 垃圾回收算法有哪些</p></li><li><p>jvm 垃圾回收器你知道哪些？jdk8 默认垃圾回收器是什么？</p></li><li><p>项目中有没有 jvm 调优的经验</p></li><li><p>如果让你设计一个 jvm 内存管理系统，你会怎么做。</p></li><li><p>说下你认为做的最好的一个项目的业务逻辑。</p></li><li><p>项目中遇到最大的问题，你是如何解决的。</p></li><li><p>java8 新特性了解吗？项目中怎么使用的</p></li><li><p>有没有进行过代码重构，怎么做的以及原因</p></li><li><p>项目中如何进行 mysql 调优的，说下过程</p></li><li><p>为什么使用索引会加快查询速度</p></li><li><p>分布式锁了解吗？什么场景下会用，怎么使用。</p></li><li><p>redis 集群有几种，热 key 问题如何解决。</p></li><li><p>redis 持久化方式有几种，原理是什么？</p></li><li><p>手写一个 demo 可以控制多个线程在同一时间同时执行相同任务。</p></li><li><p>spring 中 bean 的生命周期 spring 事务实现原理，事务不生效的场景有哪些</p></li><li><p>分布式事务了解吗？如何实现，各自优缺点</p></li><li><p>java 自带的 jvm 监控工具使用过吗？可以说一下具体使用案例吗？</p></li><li><p>线上 oom 如何排查</p></li><li><p>如何在不影响线上系统运行的情况下进行数据库水平扩容，给出一个可行的方案</p></li><li><p>一条SQL的执行流程</p><ul><li>From on join where group by having select order by</li><li><a href="https://github.com/bjmashibing/InternetArchitect" target="_blank" rel="noopener">https://github.com/bjmashibing/InternetArchitect</a></li><li><a href="https://github.com/algorithmzuo/algorithmbasic2020" target="_blank" rel="noopener">https://github.com/algorithmzuo/algorithmbasic2020</a></li><li>列不可分</li><li>不能存在传递依赖</li><li>表内数据依赖主键</li></ul></li><li><p>统计一个文本  总工有多少行出现hello单词</p><ul><li>cat xxx | grep  ‘hello’ | wc -l</li></ul></li><li><p>如何定位到占用cpu高的线程</p><ul><li>top 命令</li></ul></li><li><p>top命令里面load值含义</p><ul><li><p><strong>服务器CPU和LOAD高是什么原因呢？</strong></p></li><li><p><strong>经常遇到的一个问题，收到CPU高或者LOAD高或者都有的监控告警信息，是有问题了吗？</strong></p></li><li><p><strong>应该怎么处理呢？</strong></p></li><li><p><strong>怎么找到原因呢？</strong></p></li><li><p>一、 了解下什么是系统负载load </p></li><li><p>1、我们通过top命令w命令uptime命令都能看到我们讲的load 平均值</p><p>2、实际是从/proc/loadavg读取到的</p><p><img src="http://lion-heart.online/blog/2020-10-13-160540.png" alt="Top命令"></p><p>先大致说下这三个数字的含义：顺序解释为，系统在过去1分钟、5分钟、15分钟内运行队列的情况 </p></li></ul></li></ul><pre><code>二、 根据单核CPU和多核CPU情况区分判断 1、 单核CPU – 举例为单车道过桥 - 数字在0.00-1.00正常；如果在0.00-1.00之间，属于畅通；刚好1.00，刚好达到这条路的承载量；超过1.00，属于拥堵需要等待前面的车辆先通过2、 多核CPU – 举例为多车道过桥 - 数字/CPU核数 在0.00-1.00之间正常；多核CPU的话，满负荷状态的数字为 “1.00 * CPU核数”，即双核CPU为2.00，四核CPU为4.00，64核为64。3、 获得CPU逻辑核心数目的方法 grep &#39;model name&#39; /proc/cpuinfo |wc –l 三、 对系统负载的一些误解:1. 负载高就是性能有问题？    - 负载高可能是应用在进行大量CPU密集型计算调动资源，这样属于正常情况。2. 负载高就是CPU能力问题或者数量不够 ？   - 负载高只代表运行的队列累积过多。具体的队列累计原因可能是CPU排队，也可能是IO密集型计算时IO排队造成3. 系统长期负载高，应该增加CPU ？   - 不一定，系统负载高是表象，要找到根本原因，是因为CPU资源过少造成的排队，还是因为应用本身逻辑造成资源浪费 四、 cpu load 过高原因以及排查 **造成cpu load过高的原因：从编程语言层次上full gc次数的增大或死循环都有可能造成cpu load 增高** 具体的排查一句话描述就是： 首先要找到哪几个线程在占用cpu，之后再通过线程的id值在堆栈文件中查找具体的线程，看看出来什么问题。 寻找最占CPU的进程：1、通过命令 ps aux2、通过top -c命令显示进程运行信息列表 (按键P按CPU占有资源排序) 寻找最耗CPU的线程 3、top -Hp 进程ID 显示一个进程ID的线程运行信息列表 (按键P按CPU占有资源排序) 如果该进程是java进程，需要具体查看是哪段代码造成的CPU负载过高，根据上述获得到的线程ID可以使用JDK下的jstack来查看堆栈。 由于在堆栈中线程id是用16进制表示的，因此可以将上述线程转化成16进制的表示。 4、jstack java进程id | grep 16进制的线程id -C5 –color 五、 查看系统负载vmstat具体解释1. r 列表示运行和等待cpu时间片的进程数，如果长期大于1，说明cpu不足，需要增加cpu。2. b 列表示在等待资源的进程数，比如正在等待I/O、或者内存交换等。3. cpu 表示cpu的使用状态4. us 列显示了用户方式下所花费 CPU 时间的百分比。us的值比较高时，说明用户进程消耗的cpu时间多，但是如果长期大于50%，需要考虑优化用户的程序。5. sy 列显示了内核进程所花费的cpu时间的百分比。这里us + sy的参考值为80%，如果us+sy 大于 80%说明可能存在CPU不足。6. wa 列显示了IO等待所占用的CPU时间的百分比。这里wa的参考值为30%，如果wa超过30%，说明IO等待严重，这可能是磁盘大量随机访问造成的，也可能磁盘或者磁盘访问控制器的带宽瓶颈造成的(主要是块操作)。7. id 列显示了cpu处在空闲状态的时间百分比8. system 显示采集间隔内发生的中断数9. in 列表示在某一时间间隔中观测到的每秒设备中断数。10. cs列表示每秒产生的上下文切换次数，如当 cs 比磁盘 I/O 和网络信息包速率高得多，都应进行进一步调查。11. memory12. swpd 切换到内存交换区的内存数量(k表示)。如果swpd的值不为0，或者比较大，比如超过了100m，只要si、so的值长期为0，系统性能还是正常13. free 当前的空闲页面列表中内存数量(k表示)14. buff 作为buffer cache的内存数量，一般对块设备的读写才需要缓冲。15. cache: 作为page cache的内存数量，一般作为文件系统的cache，如果cache较大，说明用到cache的文件较多，如果此时IO中bi比较小，说明文件系统效率比较好。16. swap17. si 由内存进入内存交换区数量。18. so由内存交换区进入内存数量。19. IO20. bi 从块设备读入数据的总量（读磁盘）（每秒kb）。21. bo 块设备写入数据的总量（写磁盘）（每秒kb）22. 这里我们设置的bi+bo参考值为1000，如果超过1000，而且wa值较大应该考虑均衡磁盘负载，可以结合iostat输出来分析。 六、 查看磁盘负载iostat具体解释 每隔2秒统计一次磁盘IO信息，直到按Ctrl+C终止程序，-d 选项表示统计磁盘信息， -k 表示以每秒KB的形式显示，-t 要求打印出时间信息，2 表示每隔 2 秒输出一次。第一次输出的磁盘IO负载状况提供了关于自从系统启动以来的统计信息。随后的每一次输出则是每个间隔之间的平均IO负载状况。1. rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s2. wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s3. r/s: 每秒完成的读 I/O 设备次数。即 delta(rio)/s4. w/s: 每秒完成的写 I/O 设备次数。即 delta(wio)/s5. rsec/s: 每秒读扇区数。即 delta(rsect)/s6. wsec/s: 每秒写扇区数。即 delta(wsect)/s7. rkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)8. wkB/s: 每秒写K字节数。是 wsect/s 的一半。(需要计算)9. avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)10. avgqu-sz: 平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。11. await: 平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)12. svctm: 平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)13. %util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)14. 如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。15. idle小于70% IO压力就较大了,一般读取速度有较多的wait.16. 同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高)七、 对于公司内部服务器load负载高，CPU占用高的原因排查，利用监控辅助综合判断 先通过mdc监控进行查看系统负载、CPU利用率，内存使用率系统负载如果出现超过申请的弹性云核数的情况，属于负载高，就是说4核8G内存的弹性云服务器，系统负载持续超过4就是在持续超负载运行了CPU使用率超过80%属于CPU使用率 造成原因分3种情况，那么接下来开始查看是什么原因造成1. 可能性最大的，自身应用造成负载和CPU飙高，只要重启一下这台服务器上的应用，在监控上看到CPU使用率和负载在重启期间下降了，应用启动后没有升高到原先高度，判断为因为程序中有阻塞造成CPU飙高，CPU飙高造成系统负载高。 建议再重启应用前，如果条件允许，先使用WLOMC自助运维平台的CPU飙高分析功能查看造成CPU高的线程信息，找到对应阻塞原因2. 还可能是因为流量大，超过了此配置单台弹性云处理能力，通过mdc监控查看网络流量是不是较CPU飙高前的流量大很多，如果是流量增大造成的CPU高，典型现象是重启应用时，系统负载和CPU使用率下降，然后启动后瞬间到达很高（比重启前还高），因为流量的增大造成CPU排队使负载增高，然后大概几分钟降到重启前的数值。   ```   另一典型现象是在命令行执行ss -s查看，发现TCP连接数高，但是链接中的ESTABLISHED并不多，CLOSED和TIMEWAIT很多，就说明流量大，处理比较吃力，很多链接来不及释放。   ```3. 还有一种可能，是属于弹性云服务器的BUG，停止服务器上的所有应用，没有CPU使用高的应用，依然负载很高，说明不是本机使用造成的负载高通过cat /etc/config_info查看弹性云服务器的宿主物理机IP，联系CAP运维提供弹性云IP帮忙排查，通常情况会建议缩容此台弹性云，另申请一台不同ZONE的弹性云使用。</code></pre><ul><li><p>threadlocal</p></li><li><p>hashMap hashSet</p></li><li></li><li><p>索引失效原因</p></li><li><p>什么是慢sql</p></li><li><p>在线问答网站日活2亿   设计数据库</p></li><li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/blob/master/03%20数据库/SQL优化原理/sql优化原理.md" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/blob/master/03%20数据库/SQL优化原理/sql优化原理.md</a></p></li><li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/InnoDB%20MVCC的实现原理" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/InnoDB%20MVCC的实现原理</a></p></li><li><p><a href="https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/根据树型数据结构分析Mysql索引" target="_blank" rel="noopener">https://git.jd.com/jdwl_tc/JavaCourse/tree/master/03%20数据库/02%20索引技巧与使用/根据树型数据结构分析Mysql索引</a></p></li><li><p>Eden区 和from to 的默认比例</p></li><li></li><li><p>分布式事务</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题精选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2021/01/17/zookeeper/"/>
      <url>/2021/01/17/zookeeper/</url>
      
        <content type="html"><![CDATA[<h4 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h4><p>原子消息广播协议</p><h4 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h4><p> 开源的<code>分布式协调服务</code>，让分布式系统中每个节点的信息能够<code>同步</code>和<code>共享</code>,也是一种<code>数据一致性解决方案</code>。</p><p>同步：通过网络进行信息同步，类似邮件、IM工具等</p><p>共享：通过共享存储完成共享，类似Git、SVN等</p><p>基于 <code>ZAB</code> 协议，实现了一种 <code>主备</code> 系统架构模式来保证集群中 <code>副本</code> 之间的<code>数据一致性</code>。通过<code>单一进程</code>接受、处理客户端请求，同步给<code>其他进程</code>，减少重复计算，提高性能</p><h4 id="Zookeeper-特性"><a href="#Zookeeper-特性" class="headerlink" title="Zookeeper 特性"></a>Zookeeper 特性</h4><ul><li>顺序一致性</li><li>原子性</li><li>可靠性</li><li>实时性</li><li>单一视图</li></ul><h4 id="Zookeeper-数据节点"><a href="#Zookeeper-数据节点" class="headerlink" title="Zookeeper 数据节点"></a>Zookeeper 数据节点</h4><p>Zookeeper为了保证高吞吐和低延迟，在内存中维护了一个树状的目录结构 ZNode - Tree，我们称之为数据节点</p><p>类型分为</p><ul><li>持久节点</li><li>临时节点</li><li>持久顺序节点</li><li>临时顺序节点</li></ul><h4 id="Watcher：数据变更通知机制"><a href="#Watcher：数据变更通知机制" class="headerlink" title="Watcher：数据变更通知机制"></a>Watcher：数据变更通知机制</h4><p>Zookeeper允许客户端向服务端的某个Znode注册一个Watcher监听，当服务端的一些指定事件触发了这个Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据Watcher通知状态和事件类型做出业务上的改变</p><p>一个Watch事件是一个一次性的触发器，当被设置了Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了Watch的客户端，以便通知它们</p><p>羊群效应：大量的网络IO给服务器造成压力</p><h4 id="ACL-控制"><a href="#ACL-控制" class="headerlink" title="ACL 控制"></a>ACL 控制</h4><p>UGO（User/Group/Ohters）：粗粒度文件系统权限控制模式</p><p>ACL(Access Control List)</p><ul><li>权限模式</li><li>授权对象</li><li>权限<ul><li>C</li><li>R</li><li>D</li><li>W</li><li>A</li></ul></li></ul><h4 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h4><ul><li>Leader：事物请求调度、处理者，保证集群事物处理的顺序性，集群内各服务的调度者</li><li>Follower：处理客户端非事务请求，参与事物 proposal 投票，参与 leader 选举投票</li><li>ObServer：处理客户端非事务请求，不参与投票</li></ul><h4 id="Server-工作状态"><a href="#Server-工作状态" class="headerlink" title="Server 工作状态"></a>Server 工作状态</h4><ul><li>Looking ：寻找Leader状态</li><li>Leading：领导者状态</li><li>Follwing：跟随者状态</li><li>ObServing：观察者状态</li></ul><h4 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h4><ol><li>服务器初始化启动</li><li>服务器运行期间无法和Leader保持网络连接</li></ol><h4 id="zookeeper是如何保证事务的顺序一致性的"><a href="#zookeeper是如何保证事务的顺序一致性的" class="headerlink" title="zookeeper是如何保证事务的顺序一致性的"></a>zookeeper是如何保证事务的顺序一致性的</h4><p>zookeeper采用了全局递增的事务Id来标识(zxid)，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader周期，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行</p><h4 id="Zookeeper-特性与其使用场景"><a href="#Zookeeper-特性与其使用场景" class="headerlink" title="Zookeeper 特性与其使用场景"></a>Zookeeper 特性与其使用场景</h4><h5 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h5><p>配置中心：配置信息集中管理和数据的动态更新</p><p>模型：push、pull</p><p>基于Zookeeper的实现方式：</p><ol><li>数据存储：将数据（配置信息）存储到Zookeeper上的一个数据节点</li><li>数据获取：应用在启动初始化节点从Zookeeper数据节点读取数据，并在该节点上注册一个数据变更Watcher</li><li>数据变更：当变更数据时，更新Zookeeper对应节点数据，Zookeeper会将数据变更通知发到各客户端，客户端接到通知后重新读取变更后的数据即可。</li></ol><h5 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h5><p>日志收集系统：</p><h5 id="Maste-选举"><a href="#Maste-选举" class="headerlink" title="Maste 选举"></a>Maste 选举</h5><p>海量数据处理与共享模型</p><h5 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h5><p>RPC 注册中心</p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>排它锁：临时节点</p><p>共享锁：临时顺序节点</p><h5 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h5><p>临时顺序节点</p><h4 id="Zookeeper-java客户端"><a href="#Zookeeper-java客户端" class="headerlink" title="Zookeeper java客户端"></a>Zookeeper java客户端</h4><p>自带：zkClient</p><p>apache：curator</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="服务端启动流程"><a href="#服务端启动流程" class="headerlink" title="服务端启动流程"></a>服务端启动流程</h3><ol><li><p>参数解析</p><ul><li>配置文件加载并解析</li></ul></li><li><p>历史文件清理器 - 清理快找文件</p></li><li><p>cluster|| standalone</p></li><li><p>单机模式……</p><ul><li><p>服务配置对象 - 解析配置文件：封装配置value到对应属性</p></li><li><p>初始化</p><ul><li><p>创建数据管理器</p></li><li><p>初始化zkServer对象，设置参数</p></li><li><p>创建cnxnFactory处理网络事件</p></li><li><p>cnxn服务启动</p><ul><li><p>启动相关线程</p></li><li><p>启动服务</p></li><li><p>加载数据到zkDataBase</p></li></ul></li></ul></li></ul></li><li><p>集群模式…..</p><ul><li><img src="http://lion-heart.online/blog/2021-01-30-132249.png" alt="image-20210130212245638"></li></ul></li></ol><h2 id="Leader-选举原理"><a href="#Leader-选举原理" class="headerlink" title="Leader 选举原理"></a>Leader 选举原理</h2><p>FastLeaderElection 标准 fast paxos 算法实现，基于TCP协议进行选举</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Vote <span class="token function">lookForLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            HashMap<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> Vote<span class="token operator">></span> recvset <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> Vote<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            HashMap<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> Vote<span class="token operator">></span> outofelection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> Vote<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> notTimeout <span class="token operator">=</span> finalizeWait<span class="token punctuation">;</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//    给自己投票</span>                logicalclock<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">updateProposal</span><span class="token punctuation">(</span><span class="token function">getInitId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getInitLastLoggedZxid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getPeerEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//    将投票信息发送给集群中的每个服务器</span>            <span class="token function">sendNotifications</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//    循环，如果是竞选状态一直到选举出结果</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">getPeerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> ServerState<span class="token punctuation">.</span>LOOKING<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//    接收其他 实例的选举消息</span>                Notification n <span class="token operator">=</span> recvqueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>notTimeout<span class="token punctuation">,</span>                        TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//    没有收到投票信息</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>manager<span class="token punctuation">.</span><span class="token function">haveDelivered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">sendNotifications</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        manager<span class="token punctuation">.</span><span class="token function">connectAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">//收到投票信息</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">getCurrentAndNextConfigVoters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>sid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">switch</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">case</span> LOOKING<span class="token operator">:</span>                        <span class="token comment" spellcheck="true">// 判断投票是否过时，如果过时就清除之前已经接收到的信息                      </span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>electionEpoch <span class="token operator">></span> logicalclock<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            logicalclock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                            recvset<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//    更新投票信息</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">totalOrderPredicate</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span>                                    <span class="token function">getInitId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getInitLastLoggedZxid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getPeerEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                <span class="token function">updateProposal</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token function">updateProposal</span><span class="token punctuation">(</span><span class="token function">getInitId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        <span class="token function">getInitLastLoggedZxid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                        <span class="token function">getPeerEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            <span class="token comment" spellcheck="true">//    发送投票信息</span>                            <span class="token function">sendNotifications</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>electionEpoch <span class="token operator">&lt;</span> logicalclock<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//    忽略</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">totalOrderPredicate</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span>                                proposedLeader<span class="token punctuation">,</span> proposedZxid<span class="token punctuation">,</span> proposedEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">//    更新投票信息</span>                            <span class="token function">updateProposal</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">sendNotifications</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                                             recvset<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>sid<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//    判断是否投票结束</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">termPredicate</span><span class="token punctuation">(</span>recvset<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>proposedLeader<span class="token punctuation">,</span> proposedZxid<span class="token punctuation">,</span>                                        logicalclock<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proposedEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> recvqueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>finalizeWait<span class="token punctuation">,</span>                                    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">totalOrderPredicate</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span>                                        proposedLeader<span class="token punctuation">,</span> proposedZxid<span class="token punctuation">,</span> proposedEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                    recvqueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token keyword">break</span><span class="token punctuation">;</span>                                <span class="token punctuation">}</span>                            <span class="token punctuation">}</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                self<span class="token punctuation">.</span><span class="token function">setPeerState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>proposedLeader <span class="token operator">==</span> self<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                   ServerState<span class="token punctuation">.</span>LEADING<span class="token operator">:</span> <span class="token function">learningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                Vote endVote <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>proposedLeader<span class="token punctuation">,</span>                                        proposedZxid<span class="token punctuation">,</span> proposedEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token function">leaveInstance</span><span class="token punctuation">(</span>endVote<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">return</span> endVote<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> OBSERVING<span class="token operator">:</span>                        <span class="token comment" spellcheck="true">//忽略</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">case</span> FOLLOWING<span class="token operator">:</span>                    <span class="token keyword">case</span> LEADING<span class="token operator">:</span>                        <span class="token comment" spellcheck="true">//如果是同一轮投票</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>electionEpoch <span class="token operator">==</span> logicalclock<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            recvset<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>sid<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//判断是否投票结束</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">termPredicate</span><span class="token punctuation">(</span>recvset<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span>                                            n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>                                            <span class="token operator">&amp;&amp;</span> <span class="token function">checkLeader</span><span class="token punctuation">(</span>outofelection<span class="token punctuation">,</span> n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                self<span class="token punctuation">.</span><span class="token function">setPeerState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader <span class="token operator">==</span> self<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                        ServerState<span class="token punctuation">.</span>LEADING<span class="token operator">:</span> <span class="token function">learningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                Vote endVote <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token function">leaveInstance</span><span class="token punctuation">(</span>endVote<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">return</span> endVote<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">//记录投票已经完成</span>                        outofelection<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>sid<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span>                                 IGNOREVALUE<span class="token punctuation">,</span> IGNOREVALUE<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">termPredicate</span><span class="token punctuation">(</span>outofelection<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span>                                IGNOREVALUE<span class="token punctuation">,</span> IGNOREVALUE<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">,</span> n<span class="token punctuation">.</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token operator">&amp;&amp;</span> <span class="token function">checkLeader</span><span class="token punctuation">(</span>outofelection<span class="token punctuation">,</span> n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> IGNOREVALUE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                logicalclock<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>electionEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                                self<span class="token punctuation">.</span><span class="token function">setPeerState</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader <span class="token operator">==</span> self<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span>                                        ServerState<span class="token punctuation">.</span>LEADING<span class="token operator">:</span> <span class="token function">learningState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            Vote endVote <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vote</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>leader<span class="token punctuation">,</span> n<span class="token punctuation">.</span>zxid<span class="token punctuation">,</span> n<span class="token punctuation">.</span>peerEpoch<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">leaveInstance</span><span class="token punctuation">(</span>endVote<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> endVote<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token keyword">default</span><span class="token operator">:</span>                        <span class="token comment" spellcheck="true">//忽略</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"Ignoring notification from non-cluster member "</span> <span class="token operator">+</span> n<span class="token punctuation">.</span>sid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><img src="http://lion-heart.online/blog/2021-01-30-112518.png" alt=""></p><ul><li>服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。</li><li>服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。</li><li>服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。</li><li>服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为小弟。</li><li>服务器5启动，后面的逻辑同服务器4成为小弟</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目 - 系统 - 应用 - 工程关系和管理</title>
      <link href="/2020/11/29/%E9%A1%B9%E7%9B%AE%20-%20%E7%B3%BB%E7%BB%9F%20-%20%E5%BA%94%E7%94%A8%20-%20%E5%B7%A5%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%92%8C%E7%AE%A1%E7%90%86/"/>
      <url>/2020/11/29/%E9%A1%B9%E7%9B%AE%20-%20%E7%B3%BB%E7%BB%9F%20-%20%E5%BA%94%E7%94%A8%20-%20%E5%B7%A5%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%92%8C%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="项目-系统-应用-工程-主机-关系和管理"><a href="#项目-系统-应用-工程-主机-关系和管理" class="headerlink" title="项目 - 系统 - 应用 - 工程 - 主机 关系和管理"></a>项目 - 系统 - 应用 - 工程 - 主机 关系和管理</h2><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><h5 id="定义：一款产品或一个生态，背后需要一系列系统进行支撑"><a href="#定义：一款产品或一个生态，背后需要一系列系统进行支撑" class="headerlink" title="定义：一款产品或一个生态，背后需要一系列系统进行支撑"></a>定义：一款产品或一个生态，背后需要一系列系统进行支撑</h5><h5 id="分类：传统项目、互联网项目"><a href="#分类：传统项目、互联网项目" class="headerlink" title="分类：传统项目、互联网项目"></a>分类：传统项目、互联网项目</h5><h4 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h4><h5 id="定义：系统是有一个由各种功能组成的一个有机体，解决某种特定的需求。为实现一套业务或一个产品的一系列应用的集合。"><a href="#定义：系统是有一个由各种功能组成的一个有机体，解决某种特定的需求。为实现一套业务或一个产品的一系列应用的集合。" class="headerlink" title="定义：系统是有一个由各种功能组成的一个有机体，解决某种特定的需求。为实现一套业务或一个产品的一系列应用的集合。"></a>定义：系统是有一个由各种功能组成的一个有机体，解决某种特定的需求。为实现一套业务或一个产品的一系列应用的集合。</h5><h5 id="级别：电商核心系统-0级-、业务运营系统-1级-、业务支撑系统-2级-、外围系统-3级"><a href="#级别：电商核心系统-0级-、业务运营系统-1级-、业务支撑系统-2级-、外围系统-3级" class="headerlink" title="级别：电商核心系统(0级)、业务运营系统(1级)、业务支撑系统(2级)、外围系统(3级)"></a>级别：电商核心系统(0级)、业务运营系统(1级)、业务支撑系统(2级)、外围系统(3级)</h5><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><h5 id="定义：一个产品或一套业务的一部分或整体的载体"><a href="#定义：一个产品或一套业务的一部分或整体的载体" class="headerlink" title="定义：一个产品或一套业务的一部分或整体的载体"></a>定义：一个产品或一套业务的一部分或整体的载体</h5><h5 id="分类：web-应用、work应用"><a href="#分类：web-应用、work应用" class="headerlink" title="分类：web 应用、work应用"></a>分类：web 应用、work应用</h5><h4 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h4><h5 id="定义：系统或应用的抽象，就是为解决某个应用、系统而建立的一个具体的Project"><a href="#定义：系统或应用的抽象，就是为解决某个应用、系统而建立的一个具体的Project" class="headerlink" title="定义：系统或应用的抽象，就是为解决某个应用、系统而建立的一个具体的Project"></a>定义：系统或应用的抽象，就是为解决某个应用、系统而建立的一个具体的Project</h5><h5 id="分类：系统可以抽象为一个工程表示、一个应用也可以抽象为一个工程表示。具体的实现"><a href="#分类：系统可以抽象为一个工程表示、一个应用也可以抽象为一个工程表示。具体的实现" class="headerlink" title="分类：系统可以抽象为一个工程表示、一个应用也可以抽象为一个工程表示。具体的实现"></a>分类：系统可以抽象为一个工程表示、一个应用也可以抽象为一个工程表示。具体的实现</h5><h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><h5 id="定义：一台真实存在的计算机"><a href="#定义：一台真实存在的计算机" class="headerlink" title="定义：一台真实存在的计算机"></a>定义：一台真实存在的计算机</h5><h4 id="依赖管理：两种方式进行依赖管理。按需选择"><a href="#依赖管理：两种方式进行依赖管理。按需选择" class="headerlink" title="依赖管理：两种方式进行依赖管理。按需选择"></a>依赖管理：两种方式进行依赖管理。按需选择</h4><p><img src="http://lion-heart.online/blog/2020-11-29-055526.png" alt="依赖关系"></p><p>参考 SpringBoot 的包管理模式</p><p>父工程 -》包管理</p><p>​    ｜-》子工程 - 模版工程 - framework（web、work）</p><p>​                  ｜-》具体工程：farm-config-center</p><p>​                  ｜-》具体工程：farm- large-screen</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何成长</title>
      <link href="/2020/11/29/%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/"/>
      <url>/2020/11/29/%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="如何成长"><a href="#如何成长" class="headerlink" title="如何成长"></a>如何成长</h2><h3 id="别人让自己做什么"><a href="#别人让自己做什么" class="headerlink" title="别人让自己做什么"></a>别人让自己做什么</h3><h3 id="知道自己要做什么"><a href="#知道自己要做什么" class="headerlink" title="知道自己要做什么"></a>知道自己要做什么</h3><h3 id="知道自己应该做什么"><a href="#知道自己应该做什么" class="headerlink" title="知道自己应该做什么"></a>知道自己应该做什么</h3><h3 id="让别人做什么"><a href="#让别人做什么" class="headerlink" title="让别人做什么"></a>让别人做什么</h3><h3 id="未来我们要做什么"><a href="#未来我们要做什么" class="headerlink" title="未来我们要做什么"></a>未来我们要做什么</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springBoot</title>
      <link href="/2020/11/26/springBoot/"/>
      <url>/2020/11/26/springBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-原理"><a href="#SpringBoot-原理" class="headerlink" title="SpringBoot 原理"></a>SpringBoot 原理</h2><p>​    如果使用Spring框架实现一个Web服务，需要导入各种依赖JAR包，然后编写对应的XML文件，步骤繁琐复杂。而使用boot就显得方便、快捷和高效，通过约定优于配置，来解决Spring 的配置繁琐、项目依赖问题</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-起步依赖（jar-管理，解决版本冲突）"><a href="#1-起步依赖（jar-管理，解决版本冲突）" class="headerlink" title="1.起步依赖（jar 管理，解决版本冲突）"></a>1.起步依赖（jar 管理，解决版本冲突）</h4><p>坐标打包到一起，省略手动管理依赖</p><h4 id="2-自动配置（bean配置，解决配置繁琐）"><a href="#2-自动配置（bean配置，解决配置繁琐）" class="headerlink" title="2.自动配置（bean配置，解决配置繁琐）"></a>2.自动配置（bean配置，解决配置繁琐）</h4><p>自动配置bean</p><h4 id="3-Yaml-Json-超集文件格式"><a href="#3-Yaml-Json-超集文件格式" class="headerlink" title="3.Yaml :Json 超集文件格式"></a>3.Yaml :Json 超集文件格式</h4><h5 id="扩展名：yml-yaml"><a href="#扩展名：yml-yaml" class="headerlink" title="扩展名：yml yaml"></a>扩展名：yml yaml</h5><h5 id="配置方式：key：-value，缩紧控制层级关系"><a href="#配置方式：key：-value，缩紧控制层级关系" class="headerlink" title="配置方式：key： value，缩紧控制层级关系"></a>配置方式：key： value，缩紧控制层级关系</h5><h4 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h4><h5 id="配置文件属性值注入"><a href="#配置文件属性值注入" class="headerlink" title="配置文件属性值注入"></a>配置文件属性值注入</h5><p>@ConfigurationProperties</p><p>@Value </p><h5 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h5><p>@PropertySource(“classpath:config.properties”)</p><p>集合使用 @PropertySources({})</p><h5 id="自定义配置类"><a href="#自定义配置类" class="headerlink" title="自定义配置类"></a>自定义配置类</h5><p>@Configuration</p><h5 id="MapperScan：很多mapper接口，无需每个接口都添加-Mapper"><a href="#MapperScan：很多mapper接口，无需每个接口都添加-Mapper" class="headerlink" title="MapperScan：很多mapper接口，无需每个接口都添加@Mapper"></a>MapperScan：很多mapper接口，无需每个接口都添加@Mapper</h5><h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><h4 id="1-依赖管理"><a href="#1-依赖管理" class="headerlink" title="1.依赖管理"></a>1.依赖管理</h4><p>​    工程 spring-boot-starter-parent  -》父工程 dependecy 进行jar版本控制</p><p>​    spring-boot-starter-web 依赖启动器主要作用就是提供web开发场景所需的底层所有依赖</p><h4 id="2-自动配置"><a href="#2-自动配置" class="headerlink" title="2.自动配置"></a>2.自动配置</h4><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h5><ul><li>@SpringBootConfiguration：表示配置类<ul><li>@Configruation：配置类</li></ul></li><li>@EnableAutoConfiguration：启动自动配置<ul><li>@AutoConfigurationPackge：会把 SpringBootConfiguration 所在包路径进行扫描，将组件添加到 IoC 容器</li><li>@Import：底层注解，将组件导入 IoC 容器<ul><li>Selector 组件：将所有符合条件的 @Configuration 配置加载到 IoC 容器</li></ul></li></ul></li><li>@ComponentScan：包扫描器</li></ul><h4 id="3-Starter：可插拔式插件。封装了一些列相关的依赖库"><a href="#3-Starter：可插拔式插件。封装了一些列相关的依赖库" class="headerlink" title="3.Starter：可插拔式插件。封装了一些列相关的依赖库"></a>3.Starter：可插拔式插件。封装了一些列相关的依赖库</h4><p>自定义 starter，封装服务。公司很多中间件就可以封装一下啊，自动进行装配</p><h4 id="4-启动类执行流程"><a href="#4-启动类执行流程" class="headerlink" title="4.启动类执行流程"></a>4.启动类执行流程</h4><p>实例化SpringApplication类</p><p>​    判断应用类型  servlet reactive</p><p>​    设置初始化器</p><p>​    设置监听器</p><p>​    初始化属性</p><p>调用 run 方法</p><p>​    获取启动监听器</p><p>​    配置运行环境</p><p>​    创建Spring容器</p><p>​    前置处理 - 加载启动类，注入容器。触发监听器响应事件、加载资源、设置上下文环境</p><p>​    刷新容器 - 初始化IoC容器、注册JVM关闭钩子</p><p>​    发送事件通知</p><p>​    执行runner</p><p>​    发布上下文就绪事件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC原理</title>
      <link href="/2020/11/24/SpringMVC%E5%8E%9F%E7%90%86/"/>
      <url>/2020/11/24/SpringMVC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC原理</p><p><img src="http://lion-heart.online/blog/2020-11-24-125235.png" alt="工作流程"></p><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><h4 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h4><h5 id="RequestParam-强制进行参数绑定"><a href="#RequestParam-强制进行参数绑定" class="headerlink" title="@RequestParam 强制进行参数绑定"></a>@RequestParam 强制进行参数绑定</h5><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><h4 id="对象嵌套"><a href="#对象嵌套" class="headerlink" title="对象嵌套"></a>对象嵌套</h4><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><h5 id="SpringMVC-类型转换器-gt-FactoryBean-方式-注册到处理器适配器"><a href="#SpringMVC-类型转换器-gt-FactoryBean-方式-注册到处理器适配器" class="headerlink" title="SpringMVC 类型转换器 -&gt; FactoryBean 方式 注册到处理器适配器"></a>SpringMVC 类型转换器 -&gt; FactoryBean 方式 注册到处理器适配器</h5><h4 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装"></a>数据封装</h4><h5 id="Model、Map、ModelMap-gt-BindingAwareModelMap"><a href="#Model、Map、ModelMap-gt-BindingAwareModelMap" class="headerlink" title="Model、Map、ModelMap -&gt; BindingAwareModelMap"></a>Model、Map、ModelMap -&gt; BindingAwareModelMap</h5><h5 id="View"><a href="#View" class="headerlink" title="View"></a>View</h5><h3 id="RestFul-：（资源）表现层状态转移，既不是标准也不是协议，一种风格"><a href="#RestFul-：（资源）表现层状态转移，既不是标准也不是协议，一种风格" class="headerlink" title="RestFul ：（资源）表现层状态转移，既不是标准也不是协议，一种风格"></a>RestFul ：（资源）表现层状态转移，既不是标准也不是协议，一种风格</h3><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><h4 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h4><h3 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h3><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h4 id="监听器："><a href="#监听器：" class="headerlink" title="监听器："></a>监听器：</h4><h4 id="过滤器：作用域-Servlet之前"><a href="#过滤器：作用域-Servlet之前" class="headerlink" title="过滤器：作用域 Servlet之前"></a>过滤器：作用域 Servlet之前</h4><h3 id="造轮子"><a href="#造轮子" class="headerlink" title="造轮子"></a>造轮子</h3><h4 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h4><p>Properties</p><h4 id="扫描类、注解"><a href="#扫描类、注解" class="headerlink" title="扫描类、注解"></a>扫描类、注解</h4><p>找到磁盘文件 -&gt; 加载到内存</p><h4 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h4><p>反射，区分注解类型</p><h4 id="实现依赖注入"><a href="#实现依赖注入" class="headerlink" title="实现依赖注入"></a>实现依赖注入</h4><p>遍历bean，获取相关注解，反射 获取 fields</p><h4 id="构造处理器映射器"><a href="#构造处理器映射器" class="headerlink" title="构造处理器映射器 **"></a>构造处理器映射器 **</h4><p>将URL 和 Method 建立映射 = 封装Handler对象</p><h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><ol><li>获取 handlerMapping 处理器映射器</li><li>获取 handlerAdapter 处理器适配器<ul><li>HttpRequestHandlerAdapter：</li><li>SimpleControllerHandlerAdapter：实现Controller</li><li>RequestMappingHandlerAdapter：HandlerMethod</li></ul></li><li>执行 handler </li><li>视图跳转和渲染</li></ol><p>Spring -》refresh -》onfresh -》Dispatcher -》onfresh -》组件初始化 </p><ol><li>按类型加载</li><li>按 beanName</li><li>按默认策略，默认配置文件</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁原理及其实现</title>
      <link href="/2020/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/"/>
      <url>/2020/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="分布式锁原理及其实现"><a href="#分布式锁原理及其实现" class="headerlink" title="分布式锁原理及其实现"></a>分布式锁原理及其实现</h2><h3 id="什么是锁？"><a href="#什么是锁？" class="headerlink" title="什么是锁？"></a>什么是锁？</h3><h3 id="用来解决问题？"><a href="#用来解决问题？" class="headerlink" title="用来解决问题？"></a>用来解决问题？</h3><p>保护共享资源，解决数据安全性问题</p><h3 id="单机锁分类？"><a href="#单机锁分类？" class="headerlink" title="单机锁分类？"></a>单机锁分类？</h3><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7f749fc8.png" alt="分类"></p><h3 id="分布式锁：分布式系统中保证同步访问资源的一种方式"><a href="#分布式锁：分布式系统中保证同步访问资源的一种方式" class="headerlink" title="分布式锁：分布式系统中保证同步访问资源的一种方式"></a>分布式锁：分布式系统中保证同步访问资源的一种方式</h3><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>银行转账服务、王者排位选英雄、分布式自增主键应用、共享文档平台编辑问题</li><li>秒杀、抢购等业务不适合，可以通过乐观锁和预分配方案来进行代替</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="http://lion-heart.online/blog/2020-11-12-154015.png" alt="分布式锁方案"></p><p>redis</p><ul><li>lua 脚本</li><li>pipline</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><img src="http://lion-heart.online/blog/2020-11-12-154513.png" alt="数据安全性问题"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>锁本身不设置超时时间，但是会有死锁的风险</li><li>服务端被动检测和客户端的存活连接，延迟释放锁</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>大部分业务场景使用 redis</li><li>安全性高的场景需要使用 zk + 共享资源幂等校验</li><li>安全性极高的场景需要对共享资源做一定的处理</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>千万级级别系统搭建</title>
      <link href="/2020/11/12/%E5%8D%83%E4%B8%87%E7%BA%A7%E7%BA%A7%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/11/12/%E5%8D%83%E4%B8%87%E7%BA%A7%E7%BA%A7%E5%88%AB%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="千万级并发系统搭建"><a href="#千万级并发系统搭建" class="headerlink" title="千万级并发系统搭建"></a>千万级并发系统搭建</h2><h3 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h3><ol><li>负载均衡<ul><li>地域维度：DNS</li><li>硬件维度：H5、A10<ul><li>集群和集群之间的负载均衡</li></ul></li><li>软件维度：LVS &amp; Nginx<ul><li>主机和主机之间的负载均衡</li></ul></li><li>负载均衡协议 </li></ul></li><li>防火墙<ul><li>ip tables</li><li>firewall</li></ul></li><li>缓存<ul><li>客户端</li><li>代理层</li><li>网关层</li><li>应用层<ul><li>Redis<ul><li>主备</li><li>集群</li></ul></li></ul></li></ul></li><li>数据库<ul><li>MySQL<ul><li>主从</li><li>高可用</li><li>读写分离</li><li>分库分表</li></ul></li></ul></li><li>日志集群</li><li>集群监控<ul><li>普罗米修斯</li></ul></li><li>ELK</li><li>MQ</li><li>Kafka</li><li>K8s</li><li>Docker</li><li>代码托管<ul><li>Git</li><li>GitLab</li></ul></li><li>自动化部署/持续部署</li><li>持续集成<ul><li>Jenkins</li></ul></li><li>etcd</li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构 概论</title>
      <link href="/2020/11/12/%E6%9E%B6%E6%9E%84%20%E6%A6%82%E8%AE%BA/"/>
      <url>/2020/11/12/%E6%9E%B6%E6%9E%84%20%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="架构-概论"><a href="#架构-概论" class="headerlink" title="架构 概论"></a>架构 概论</h1><h3 id="顶层设计"><a href="#顶层设计" class="headerlink" title="顶层设计"></a>顶层设计</h3><h3 id="按需、预期未来、规划企业架构"><a href="#按需、预期未来、规划企业架构" class="headerlink" title="按需、预期未来、规划企业架构"></a>按需、预期未来、规划企业架构</h3><h4 id="按需"><a href="#按需" class="headerlink" title="按需"></a>按需</h4><h4 id="预期未来"><a href="#预期未来" class="headerlink" title="预期未来"></a>预期未来</h4><h4 id="规划企业架构"><a href="#规划企业架构" class="headerlink" title="规划企业架构"></a>规划企业架构</h4><p>业务全局出发，制定可落地的架构方案</p><h4 id="全局出发"><a href="#全局出发" class="headerlink" title="全局出发"></a>全局出发</h4><h4 id="落地（满足三高）"><a href="#落地（满足三高）" class="headerlink" title="落地（满足三高）"></a>落地（满足三高）</h4><h5 id="特性和方案"><a href="#特性和方案" class="headerlink" title="特性和方案"></a>特性和方案</h5><p>分布式、高性能、高可用、可扩展**、松耦合、高内聚、可复用、边界、安全、成本、规模等等</p><h5 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a>实现手段</h5><p>服务 、缓存、消息、搜索、调度、任务、数据、监控、配置、网关等等</p><h5 id="依赖技术"><a href="#依赖技术" class="headerlink" title="依赖技术"></a>依赖技术</h5><p>Paxos、CAP、BASE、ACID、raft、rpc、Reactor、SLA、SLB等等</p><h4 id="缓冲-Buffer：解决内存、磁盘读-写速度不一致问题。啤酒理论。"><a href="#缓冲-Buffer：解决内存、磁盘读-写速度不一致问题。啤酒理论。" class="headerlink" title="缓冲 Buffer：解决内存、磁盘读\写速度不一致问题。啤酒理论。"></a>缓冲 Buffer：解决内存、磁盘读\写速度不一致问题。啤酒理论。</h4><h4 id="缓存-Cahce：多应用、链接之间数据共享、复用"><a href="#缓存-Cahce：多应用、链接之间数据共享、复用" class="headerlink" title="缓存 Cahce：多应用、链接之间数据共享、复用"></a>缓存 Cahce：多应用、链接之间数据共享、复用</h4><h4 id="Pool：连接、线程、对象"><a href="#Pool：连接、线程、对象" class="headerlink" title="Pool：连接、线程、对象"></a>Pool：连接、线程、对象</h4><h4 id="分治-Sharding"><a href="#分治-Sharding" class="headerlink" title="分治 Sharding"></a>分治 Sharding</h4><h4 id="亲密性-粘性-Sticky"><a href="#亲密性-粘性-Sticky" class="headerlink" title="亲密性(粘性) Sticky"></a>亲密性(粘性) Sticky</h4><p>复杂均衡 -》亲密性。ip 固定发到一台固定的服务</p><p>先竞争后计算 -》先计算后汇总</p><h4 id="权衡-Balance-or-trade-off"><a href="#权衡-Balance-or-trade-off" class="headerlink" title="权衡 Balance or trade-off"></a>权衡 Balance or trade-off</h4><h4 id="QPS：Queries-Per-Second"><a href="#QPS：Queries-Per-Second" class="headerlink" title="QPS：Queries Per Second"></a>QPS：Queries Per Second</h4><h4 id="TPS：Transaction-Per-Second"><a href="#TPS：Transaction-Per-Second" class="headerlink" title="TPS：Transaction Per Second"></a>TPS：Transaction Per Second</h4><h4 id="RT：Response-time"><a href="#RT：Response-time" class="headerlink" title="RT：Response - time"></a>RT：Response - time</h4><h4 id="PV：page-view"><a href="#PV：page-view" class="headerlink" title="PV：page view"></a>PV：page view</h4><h4 id="UV：unique-visitor"><a href="#UV：unique-visitor" class="headerlink" title="UV：unique visitor"></a>UV：unique visitor</h4><h4 id="并发数"><a href="#并发数" class="headerlink" title="并发数"></a>并发数</h4><h4 id="线程数：-挂起时间-运行时间-运行时间-CPU核心"><a href="#线程数：-挂起时间-运行时间-运行时间-CPU核心" class="headerlink" title="线程数：((挂起时间 + 运行时间) / 运行时间) * CPU核心"></a>线程数：((挂起时间 + 运行时间) / 运行时间) * CPU核心</h4><h2 id="千万级流量架构核心策略"><a href="#千万级流量架构核心策略" class="headerlink" title="千万级流量架构核心策略"></a>千万级流量架构核心策略</h2><p>流量计算：峰值qps = (日总PV * 80%)/(日总秒数 * 20%)</p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><ol><li><p>系统维度、业务维度</p><ul><li>基础资料模块</li><li>设备模块</li><li>作业模块<ul><li>农事</li><li>种植计划</li><li>加工计划</li><li>追溯</li></ul></li><li>库存模块</li></ul></li><li><p>功能维度</p><ul><li>设备模块<ul><li>维护设备服务</li><li>使用设备服务</li><li>统计设备服务</li></ul></li></ul></li><li><p>读写维度</p><ul><li>设备写服务</li><li>设备读服务<ul><li>虫情设备</li><li>传感器设备</li><li>视频设备<ul><li>图片设备</li><li>视频流设备</li></ul></li></ul></li></ul></li><li><p>空间维度、资源维度</p><ul><li><p>前后端分离</p><ul><li>动静分离</li><li>负载均衡</li><li>多级缓存</li></ul></li><li><p>计算型模块、服务</p></li><li><p>IO密集型模块、服务</p><ul><li>应用集群</li><li>分布式消息中间件</li><li>分布式存储</li><li>分布式缓存</li><li>分布式搜索引擎</li><li>数据库集群</li></ul></li></ul></li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol><li>异步</li><li>削峰</li><li>解耦</li><li>分布式事务</li></ol><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存分类</p><ol><li>客户端<ul><li>浏览器缓存：非实时数据</li><li>APP 客户端： 素材 + 数据 ，网络不好的情况也可以给用户展示</li></ul></li><li>网络<ul><li>CDN：静态资源，用户无需访问系统通过最近的节点获取资源</li></ul></li><li>接入层<ul><li>Nginx</li></ul></li><li>应用层<ul><li>进程缓存</li><li>独立缓存服务<ul><li>redis<ul><li>cache aside：更新数据时不更新缓存，删除缓存的数据。减少数据不一致问题，但是不保证数据一致性<ul><li><img src="http://lion-heart.online/blog/2020-11-08-152055.png" alt="先更新DB后更新cache1"></li><li><img src="http://lion-heart.online/blog/2020-11-08-152050.png" alt="先更新cache后更新DB1"></li><li><img src="http://lion-heart.online/blog/2020-11-08-152046.png" alt="解决方案1"></li></ul></li><li>read/write through ：用户只与缓存打交道，由缓存和数据库打交道</li></ul></li></ul></li></ul></li></ol><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><ol><li><p>雪崩：缓存服务故障 /大量数据同时失效 -》db 压力大</p><ul><li>解决方案<ul><li>有效期 + 随机值</li><li>高可用 分布式缓存</li><li>热点数据 永远不过期</li><li>缓存失效后，通过加锁或队列控制访问 db 的线程数量</li></ul></li></ul></li><li><p>穿透：缓存未命中</p><ul><li><p>DB 命中：控制并发量</p></li><li><p>DB 未命中解决方案</p><ul><li><p>缓存空值</p></li><li><p>布隆过滤器：二进制数组 +  hash算法。判断一个元素是否在集合中</p><ul><li><p><img src="http://lion-heart.online/blog/2020-11-08-152034.png" alt="流程"></p></li><li><p>不足</p><ul><li>hash冲突，可以使用多个hash函数一起计算，提高精度</li><li>不能删除。可以使用int数组，计数</li></ul></li></ul></li></ul></li></ul></li></ol><h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p><img src="http://lion-heart.online/blog/2020-11-08-152519.png" alt="降级"></p><p>降级方式</p><ol><li>人工</li><li>自动：Hystrix</li></ol><h3 id="限流：对请求进行限制，保证可用性"><a href="#限流：对请求进行限制，保证可用性" class="headerlink" title="限流：对请求进行限制，保证可用性"></a>限流：对请求进行限制，保证可用性</h3><p>限流算法</p><ol><li>固定时间窗口</li><li>滑动时间窗口</li><li>令牌桶</li><li>漏桶</li></ol><p>限流形式</p><ol><li>单机限流</li><li>分布式限流</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构核心策略</title>
      <link href="/2020/11/08/%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5/"/>
      <url>/2020/11/08/%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="流量计算"><a href="#流量计算" class="headerlink" title="流量计算"></a>流量计算</h3><h4 id="峰值qps-日总PV-80-日总秒数-20"><a href="#峰值qps-日总PV-80-日总秒数-20" class="headerlink" title="峰值qps = (日总PV * 80%)/(日总秒数 * 20%)"></a>峰值qps = (日总PV * 80%)/(日总秒数 * 20%)</h4><h3 id="网络机器间通信"><a href="#网络机器间通信" class="headerlink" title="网络机器间通信"></a>网络机器间通信</h3><h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><h5 id="将流从一台机器传输到另一台机器，基于传输协议和网络IO来实现"><a href="#将流从一台机器传输到另一台机器，基于传输协议和网络IO来实现" class="headerlink" title="将流从一台机器传输到另一台机器，基于传输协议和网络IO来实现"></a>将流从一台机器传输到另一台机器，基于传输协议和网络IO来实现</h5><p>协议</p><ul><li>TCP：安全(三次握手、四次挥手)、可靠、效率较低、占用资源较高</li><li>UDP：速度快、不可靠</li></ul><p>IO模型</p><ul><li>bio</li><li>nio</li><li>aio</li></ul><h4 id="Java-技术体系中可以实现远程通信的技术"><a href="#Java-技术体系中可以实现远程通信的技术" class="headerlink" title="Java 技术体系中可以实现远程通信的技术"></a>Java 技术体系中可以实现远程通信的技术</h4><ul><li>RMI</li><li>ESB</li><li>Hessian</li><li>SOAP</li><li>JMS</li></ul><h4 id="RPC：不是一个具体的技术，网络远程调用过程"><a href="#RPC：不是一个具体的技术，网络远程调用过程" class="headerlink" title="RPC：不是一个具体的技术，网络远程调用过程"></a>RPC：不是一个具体的技术，网络远程调用过程</h4><ul><li>RMI</li><li>Hessian</li><li>gRPC</li><li>bRPC</li><li>Dubbo</li></ul><h3 id="一、拆分"><a href="#一、拆分" class="headerlink" title="一、拆分"></a>一、拆分</h3><ol><li>系统维度、业务维度<ul><li>基础资料模块</li><li>设备模块</li><li>作业模块<ul><li>农事</li><li>种植计划</li><li>加工计划</li><li>追溯</li></ul></li><li>库存模块</li></ul></li><li>功能维度<ul><li>设备模块<ul><li>维护设备服务</li><li>使用设备服务</li><li>统计设备服务</li></ul></li></ul></li><li>读写维度<ul><li>设备写服务</li><li>设备读服务<ul><li>虫情设备</li><li>传感器设备</li><li>视频设备<ul><li>图片设备</li><li>视频流设备</li></ul></li></ul></li></ul></li><li>空间维度、资源维度<ul><li>计算型模块、服务</li><li>IO密集型模块、服务<ul><li>应用集群</li><li>分布式消息中间件</li><li>分布式存储</li><li>分布式缓存</li><li>分布式搜索引擎</li><li>数据库集群</li></ul></li></ul></li></ol><h4 id="拆分后带来的问题（分布式系统设计策略）"><a href="#拆分后带来的问题（分布式系统设计策略）" class="headerlink" title="拆分后带来的问题（分布式系统设计策略）"></a>拆分后带来的问题（分布式系统设计策略）</h4><h5 id="节点存活问题"><a href="#节点存活问题" class="headerlink" title="节点存活问题"></a>节点存活问题</h5><p>心跳检测</p><ul><li>周期心跳检测机制</li><li>累计失效检测机制</li></ul><h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><ul><li>主备</li><li>互备</li><li>集群</li></ul><h5 id="容错处理"><a href="#容错处理" class="headerlink" title="容错处理"></a>容错处理</h5><ul><li>缓存穿透</li></ul><h5 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h5><h3 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h3><ol><li>异步</li><li>削峰</li><li>解耦</li><li>分布式事务</li></ol><h3 id="三、缓存"><a href="#三、缓存" class="headerlink" title="三、缓存"></a>三、缓存</h3><p>缓存分类</p><ol><li>客户端<ul><li>浏览器缓存：非实时数据</li><li>APP 客户端： 素材 + 数据 ，网络不好的情况也可以给用户展示</li></ul></li><li>网络<ul><li>CDN：静态资源，用户无需访问系统通过最近的节点获取资源</li></ul></li><li>接入层<ul><li>Nginx</li></ul></li><li>应用层<ul><li>进程缓存</li><li>独立缓存服务<ul><li>redis<ul><li>cache aside：更新数据时不更新缓存，删除缓存的数据。减少数据不一致问题，但是不保证数据一致性<ul><li><img src="http://lion-heart.online/blog/2020-11-08-152055.png" alt="先更新DB后更新cache1"></li><li><img src="http://lion-heart.online/blog/2020-11-08-152050.png" alt="先更新cache后更新DB1"></li><li><img src="http://lion-heart.online/blog/2020-11-08-152046.png" alt="解决方案1"></li></ul></li><li>read/write through ：用户只与缓存打交道，由缓存和数据库打交道</li></ul></li></ul></li></ul></li></ol><h4 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h4><ol><li><p>雪崩：缓存服务故障 /大量数据同时失效 -》db 压力大</p><ul><li>解决方案<ul><li>有效期 + 随机值</li><li>高可用 分布式缓存</li><li>热点数据 永远不过期</li><li>缓存失效后，通过加锁或队列控制访问 db 的线程数量</li></ul></li></ul></li><li><p>穿透：缓存未命中</p><ul><li><p>DB 命中：控制并发量</p></li><li><p>DB 未命中解决方案</p><ul><li><p>缓存空值</p></li><li><p>布隆过滤器：二进制数组 +  hash算法。判断一个元素是否在集合中</p><ul><li><p><img src="http://lion-heart.online/blog/2020-11-08-152034.png" alt="流程"></p></li><li><p>不足</p><ul><li>hash冲突，可以使用多个hash函数一起计算，提高精度</li><li>不能删除。可以使用int数组，计数</li></ul></li></ul></li></ul></li></ul></li></ol><h3 id="四、降级"><a href="#四、降级" class="headerlink" title="四、降级"></a>四、降级</h3><p><img src="http://lion-heart.online/blog/2020-11-08-152519.png" alt="降级"></p><p>降级方式</p><ol><li>人工</li><li>自动：Hystrix</li></ol><h3 id="五、限流：对请求进行限制，保证可用性"><a href="#五、限流：对请求进行限制，保证可用性" class="headerlink" title="五、限流：对请求进行限制，保证可用性"></a>五、限流：对请求进行限制，保证可用性</h3><p>限流算法</p><ol><li>固定时间窗口</li><li>滑动时间窗口</li><li>令牌桶</li><li>漏桶</li></ol><p>限流形式</p><ol><li>单机限流</li><li>分布式限流</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>思考</title>
      <link href="/2020/11/08/%E6%80%9D%E8%80%83/"/>
      <url>/2020/11/08/%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="效率软件"><a href="#效率软件" class="headerlink" title="效率软件"></a>效率软件</h2><p><a href="https://www.bilibili.com/video/BV1xJ411h7fz/?spm_id_from=333.788.videocard.7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xJ411h7fz/?spm_id_from=333.788.videocard.7</a></p><p><img src="http://lion-heart.online/blog/2020-11-06-160257.png" alt="多场景-多品类高效"></p><p><img src="http://lion-heart.online/blog/2020-11-06-160315.png" alt="redis"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程调度模型</title>
      <link href="/2020/11/08/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/11/08/%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>线程调度模型</p><ol><li>分时调度模型</li><li>抢占式调度模型：默认实现，线程优先级决定抢占CPU机率高（1～10）</li></ol><p>生命周期</p><ol><li>新建</li><li>就绪</li><li>运行</li><li>阻塞</li><li>等待</li><li>死亡</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>容器服务</title>
      <link href="/2020/11/08/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/"/>
      <url>/2020/11/08/%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="弹性服务"><a href="#弹性服务" class="headerlink" title="弹性服务"></a>弹性服务</h1><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>os虚拟化 -》 内核轻量级虚拟化  -》资源隔离机制（Docker）</p><h2 id="Docker：构建、管理、保护应用程序"><a href="#Docker：构建、管理、保护应用程序" class="headerlink" title="Docker：构建、管理、保护应用程序"></a>Docker：构建、管理、保护应用程序</h2><h2 id="Kubernetes：容器治理"><a href="#Kubernetes：容器治理" class="headerlink" title="Kubernetes：容器治理"></a>Kubernetes：容器治理</h2><h2 id="容器弹性云平台设计与实践"><a href="#容器弹性云平台设计与实践" class="headerlink" title="容器弹性云平台设计与实践"></a>容器弹性云平台设计与实践</h2><h2 id="微服务架构痛点"><a href="#微服务架构痛点" class="headerlink" title="微服务架构痛点"></a>微服务架构痛点</h2><h2 id="微服务发展方向"><a href="#微服务发展方向" class="headerlink" title="微服务发展方向"></a>微服务发展方向</h2><h2 id="服务网格架构设计与实践"><a href="#服务网格架构设计与实践" class="headerlink" title="服务网格架构设计与实践"></a>服务网格架构设计与实践</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目发布</title>
      <link href="/2020/11/08/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83/"/>
      <url>/2020/11/08/%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<h2 id="项目发布"><a href="#项目发布" class="headerlink" title="项目发布"></a>项目发布</h2><p>设计、开发、测试、部署，流程都讲过了，微服务技术栈，服务注册中心，nacos，RPC框架，dubbo，设计就要把各个服务拆分完毕，包括你的业务逻辑，需求，接口，数据库，类，功能的时序图</p><h2 id="滚动发布（J-one）"><a href="#滚动发布（J-one）" class="headerlink" title="滚动发布（J-one）"></a>滚动发布（J-one）</h2><p>这是最常见的部署模式，一般就是说你一个服务/系统都会部署在多台机器上，部署的时候，要不然是手动依次部署</p><p>中小型公司现在稍微好点的话，都会做自动化部署，自动化部署用的比较多的是jenkins，因为jenkins是支持持续集成和持续交付的，之前说过持续集成，那么持续交付就是比持续集成更进一步，简单来说，就是你每天都提交代码，他每天都自动跑测试确保代码集成没问题，然后可能每隔几天，就把一个生产可用的小版本交付到线上</p><p>这个时候，就需要一个自动化部署，jenkins可以自动在多台机器上部署你的服务/系统，过程其实也是类似的，只不过把手动改成自动罢了，你自己部署tomcat/基于spring boot内嵌容器，其实都行</p><p>中大型公司，一般发布系统都是自己研发的，你在上面指定对一个服务，指定一个git仓库的代码分支，然后指定一个环境，指定一批机器，发布系统自动到git仓库拉取代码到本地，编译打包，然后在你指定环境的机器上，依次停止当前运行的进程，然后依次重启你新代码的服务进程</p><p>这都是典型的滚动发布</p><p>但凡发布，都要考虑两个问题，一个是验证，一个是回滚</p><p>验证就是说，你怎么确定你这次部署成功了？一般来说，要观察每台机器启动后处理请求时的日志，日志是否正常，是否有报错，一般日志正常、没有报错，那么就算是启动成功了，有时候也会让QA/PM做一个线上验证</p><p>那么万一发布失败了呢？此时就得回滚，因为不同的上线是不一样的，有时候你仅仅是对代码做一些微调，大多数时候是针对新需求有上线，加了新的代码/接口，有时候是架构重构，实现机制和技术架构都变了</p><p>所以回滚的话，也不太一样，比如你如果是加了一些新的接口，结果上线失败了，此时心接口没人访问，直接代码回滚到旧版本重新部署就行了；如果你是做技术架构升级，此时失败了，可能很多请求已经处理失败，数据丢失，严重的时候会导致公司丢失订单，或者是数据写入了但是都错了</p><p>此时可能会采用回滚代码，或者清洗错乱数据的方式来回滚，总之，针对你的发布，你要考虑到失败之后的回滚方案，回滚代码，就得用旧版本的代码，然后重新在各个机器依次部署，就算是一次回滚了，至于丢失了数据没有，要不要清洗数据，这个看情况来定</p><p>滚动发布的话，风险还是比较大的，因为一旦你用了自动化的滚动发布，那么发布系统会自动把你的所有机器都部署新版本的代码，这个时候中间很有可能会出现问题，导致大规模的异常和损失</p><p>所以现在一般中大型公司，都不会贸然用滚动发布模式了</p><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>灰度发布，指的就是说，不要上线就滚动全部发布到所有机器，一般就是会部署在比如1台机器上，采用新版本，然后切比如10%的流量过去，观察那10%的流量在1台机器上运行一段时间，比如运行个几天时间，观察日志、异常、数据，是否一切正常，如果验证发现全部正常，那么此时就可以全量发布了</p><p>全量发布的时候，就是采用滚动发布那种模式</p><p>这个好处就是说，你先用10%以内的小流量放到灰度新版本的那台机器上验证一段时间，感觉没问题了，才会全量部署，这么操作，即使有问题，也就10%以内的请求出现问题，损失不会太大的，如果你公司体量特别大，灰度也可以是1%，甚至0.1%的流量</p><p>因为体量太大的公司，1%的流量就很大了</p><p>如果灰度的时候有问题，那么立刻把10%以内的小流量切去请求老版本代码部署的机器，灰度版本的机器立马就没流量请求了，这个回滚速度是极快的</p><p>通常灰度验证过后，全量发布，都不会有太大的问题，基本上再出问题概率就很小了，所以现在中大型互联网公司，一般都是灰度发布模式的</p><h3 id="蓝绿部署"><a href="#蓝绿部署" class="headerlink" title="蓝绿部署"></a>蓝绿部署</h3><p>蓝绿部署的意思是说，你得同时准备两个集群，一个集群放新版本代码，一个集群放老版本代码，然后新版本代码的集群准备好了过后，直接线上流量切到新版本集群上去，跑一段时间来验证，如果发现有问题，回滚就是立马把流量切回老版本集群，回滚是很快速的</p><p>如果新版本集群运行一段时间感觉没问题了，此时就可以把老版本集群给下线了</p><p>那么为什么有灰度发布了还要用蓝绿部署呢？</p><p>是这样的，灰度发布过后，还是要全量部署的，但是有时候，如果涉及到一些新的架构方案，或者是新的接口，10%以内的小流量可能没办法暴露出线上的高并发问题，所以灰度验证没问题，结果全量部署还是有一个小概率会失败</p><p>此时全量发布用滚动发布的方式，逐步部署过去，很快会引发大规模的失败，此时回滚，是很慢的，因为要一台一台逐步回滚</p><p>所以说，一般针对那种改动不太大的小版本，比如加个接口，修改一些代码，修复几个bug，类似这种整体变动不大的情况，建议用灰度发布，因为这种一般灰度验证没问题，全量部署也不会有问题</p><p>但是如果涉及到那种很大规模的架构重构或者架构升级，比如数据存储架构升级，或者是技术架构整体改造，或者是代码大规模重构，类似这种场景，最好是用蓝绿部署，也就是说，完全部署一个新的集群，然后把较大的流量切过去，比如先切10%，再切50%，最后切到100%，让新集群承载100%的流量跑一段时间</p><p>过程中一旦有问题，立马流量全部切回老集群，这个回滚速度就比灰度发布的全量部署回滚要快多了，因为仅仅是切流量而已，不需要重新部署</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>事务相关</title>
      <link href="/2020/11/07/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/11/07/%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="本地事务：关系型数据库的事务"><a href="#本地事务：关系型数据库的事务" class="headerlink" title="本地事务：关系型数据库的事务"></a>本地事务：关系型数据库的事务</h2><h3 id="事务（ACID、隔离级别）"><a href="#事务（ACID、隔离级别）" class="headerlink" title="事务（ACID、隔离级别）"></a>事务（ACID、隔离级别）</h3><h3 id="存储引擎（MySQL-》innodb、myism、memory）"><a href="#存储引擎（MySQL-》innodb、myism、memory）" class="headerlink" title="存储引擎（MySQL -》innodb、myism、memory）"></a>存储引擎（MySQL -》innodb、myism、memory）</h3><h3 id="索引（结构、原理、实现）"><a href="#索引（结构、原理、实现）" class="headerlink" title="索引（结构、原理、实现）"></a>索引（结构、原理、实现）</h3><h3 id="Spring-对事物支持的原理和实现方式"><a href="#Spring-对事物支持的原理和实现方式" class="headerlink" title="Spring 对事物支持的原理和实现方式"></a>Spring 对事物支持的原理和实现方式</h3><h2 id="分布式事务：分布式系统中多个服务通过网络远程协作完成的事务"><a href="#分布式事务：分布式系统中多个服务通过网络远程协作完成的事务" class="headerlink" title="分布式事务：分布式系统中多个服务通过网络远程协作完成的事务"></a>分布式事务：分布式系统中多个服务通过网络远程协作完成的事务</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>系统操作多个数据库，肯定是有跨多个库的分布式事务的一个问题，定义了一整套的解决方案来处理分布式事务的问题</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ol><li>单体系统访问多数据库实例</li><li>多服务访问同一数据库实例</li><li>多服务访问多数据库实例</li></ol><p>本质：跨 JVM 进程级别的<code>数据库事务管理</code></p><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a>基础理论</h3><ol><li><p>CAP</p><ul><li><p>C：一致性(强一致性)，任何时刻请求得到的数据一致</p></li><li><p>A：可用性，任何时刻请求都会返回正确的响应</p></li><li><p>P：分区容忍性，分布式系统具备的基本能力</p></li><li><p>AP：互联网项目基本使用 AP</p></li><li><p>CP：zk</p></li></ul></li><li><p>BASE：基本满足CAP三个状态，柔性事务</p><ul><li>BA：基本可用，适当情况，可以进行降级</li><li>S：软状态，各个节点数据存在不一致，正在同步的过程中，这个就是软状态</li><li>E：最终一致性，虽然存在软状态，但是最终还是会一致的</li></ul></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>单块系统里的事务<ul><li>数据库层面控制</li></ul></li><li>分布式系统里的事务<ul><li>解决方案<ul><li>2PC、3PC：数据库层面</li><li>优点：强一致性，业务侵入小<ul><li>缺点：同步阻塞协议，RM 执行分支事务后需要 TM 进行协调，此时服务阻塞、锁定资源。导致吞吐量、性能低下。无法应用于高并发场景或事物生命周期长的业务流程或系统中</li></ul></li><li>TCC：应用层面<ul><li>优点：强一致性</li><li>缺点：业务侵入非常强，一个接口变为三个接口，实现复杂</li></ul></li><li>可靠消息最终一致性方案：应用层面<ul><li>优点：业务侵入小，吞吐量高，需要依赖外部中间件实现，实现简单</li><li>缺点：最终一致性</li></ul></li><li>最大努力通知方案：应用层面<ul><li>优点：业务侵入小，吞吐量高，实现简单</li><li>缺点：最终一致性、弱一致性</li></ul></li></ul></li></ul></li></ol><h3 id="XA规范和2PC协议"><a href="#XA规范和2PC协议" class="headerlink" title="XA规范和2PC协议"></a>XA规范和2PC协议</h3><h4 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h4><h5 id="事务模型：X-Open的组织定义了分布式事务的模型"><a href="#事务模型：X-Open的组织定义了分布式事务的模型" class="headerlink" title="事务模型：X/Open的组织定义了分布式事务的模型"></a>事务模型：X/Open的组织定义了分布式事务的模型</h5><p>​    AP（Application，应用程序）</p><p>​    TM（Transaction Manager，事务管理器）</p><p>​    RM（Resource Manager，资源管理器）</p><pre><code> CRM（Communication Resource Manager，通信资源管理器） </code></pre><p>然后这里定义了一个很重要的概念，就是全局事务，这个玩意儿说白了就是一个横跨多个数据库的事务，就是一个事务里，涉及了多个数据库的操作，然后要保证多个数据库中，任何一个操作失败了，其他所有库的操作全部回滚，这就是所谓的分布式事务</p><h5 id="XA是什么？"><a href="#XA是什么？" class="headerlink" title="XA是什么？"></a>XA是什么？</h5><p>​    XA仅仅是个规范，定义好的TM与RM之间的接口规范，就是管理分布式事务的那个组件跟各个数据库之间通信的一个接口，具体的实现是数据库产商来提供的，比如说MySQL就会提供XA规范的接口函数和类库实现</p><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>X/Open组织定义的一套分布式事务的模型，还是比较虚的，还没办法落地，而且XA接口规范也是一个比较务虚的一个东西，光靠我说的这些东西还是没法落地的</p><p>基本上来说，你搞明白了XA也就明白了2PC了，2PC就是基于XA规范搞的一套分布式事务的理论，也可以叫做一套规范，或者是协议，都ok。Two-Phase-Commitment-Protocol，两阶段提交协议</p><p>2PC，其实就是基于XA规范，来让分布式事务可以落地，定义了很多实现分布式事务过程中的一些细节</p><p>（1）准备阶段：prepare消息</p><p>​    就是TM先发送个prepare消息给各个数据库，让各个库先把分布式事务里要执行的各种操作，先执行，未提交 。然后各个数据库都返回一个响应消息给事务管理器，如果成功了就发送一个成功的消息，如果失败了就发送一个失败的消息</p><p>（2）提交阶段：commit消息</p><p>第一种情况，要是TM哥儿们发现某个数据库告诉他说，不好意思啊，我这儿失败了，那就尴尬了。或者是TM等了半天，某个数据库楞是死活不返回消息，跟失踪了一样，不知道在干嘛，也就麻烦了</p><p>这个时候TM直接判定这个分布式事务失败，毕竟某个数据库那里报了个错么，对不对，然后TM通知所有的数据库，全部回滚回滚回滚，赶紧的，做了啥操作都回滚，其实这里你可以认为是通知每个数据库，把自己本地的那个事务回滚不就得了，然后各个库都回滚好了以后就通知TM，TM就认为整个分布式事务都回滚了</p><p>但是呢，要是TM接收到所有的数据库返回的消息都是成功，那就happy了，直接发送个消息通知各个数据库说提交，兄弟们，然后各个数据库都在自己本地提交事务呗，就这么回事儿，提交好了通知下TM，TM要是发现所有数据库的事务都提交成功了，就认为整个分布式事务成功了</p><p> <img src="http://lion-heart.online/blog/2020-11-07-204058.png" alt="05_XA规范与2PC协议"></p><h4 id="2PC问题"><a href="#2PC问题" class="headerlink" title="2PC问题"></a>2PC问题</h4><p>1、单点故障：TM、RM是个单点，一旦挂掉就完蛋了</p><p>2、事务状态丢失：即使把TM做成一个双机热备的，一个TM挂了自动选举其他的TM出来，但是如果TM挂掉的同时，接收到commit消息的某个库也挂了，此时即使重新选举了其他的TM，压根儿不知道这个分布式事务当前的状态，因为不知道哪个库接收过commit消息，那个接收过commit消息的库也挂了</p><p>3、脑裂问题：在阶段二中，如果发生了脑裂问题，那么就会导致某些数据库没有接收到commit消息，那就完蛋了，有些库收到了commit消息，结果有些库没有收到，这咋整呢，那肯定完蛋了</p><p>4、同步阻塞：在阶段一里执行prepare操作会占用资源，一直到整个分布式事务完成，才会释放资源，这个过程中，如果有其他人要访问这个资源，就会被阻塞住</p><p><img src="http://lion-heart.online/blog/2020-11-07-204322.png" alt="06_2PC的缺陷"></p><h4 id="3PC理论"><a href="#3PC理论" class="headerlink" title="3PC理论"></a>3PC理论</h4><p>3PC，说白了，就是three-phase-commitment-protocol，三阶段提交协议，这个是针对2PC做的一个改进，主要就是为了解决2PC协议的一些问题 </p><p>3PC的话改成了下面的过程：</p><p>（1）CanCommit阶段：这个就是TM发送一个CanCommit消息给各个数据库，然后各个库返回个结果，注意一下，这里的话呢，是不会执行实际的SQL语句的，其实说白了，就是各个库看看自己网络环境啊，各方面是否readly </p><p>（2）PreCommit阶段：如果各个库对CanCommit消息返回的都是成功，那么就进入PreCommit阶段，TM发送PreCommit消息给各个库，这个时候就相当于2PC里的阶段一，其实就会执行各个SQL语句，只是不提交罢了；如果有个库对CanCommit消息返回了失败，那么就尴尬了，TM发送abort消息给各个库，大家别玩儿了，结束这个分布式事务</p><p>（3）DoCommit阶段：如果各个库对PreCommit阶段都返回了成功，那么发送DoCommit消息给各个库，就说提交事务吧，兄弟们，各个库如果都返回提交成功给TM，那么分布式事务成功；如果有个库对PreCommit返回的是失败，或者超时一直没返回，那么TM认为分布式事务失败，直接发abort消息给各个库，说兄弟们回滚吧，各个库回滚成功之后通知TM，分布式事务回滚</p><p>说白了大概就是这样子，但是这里的话，跟2PC相比，主要做了下面两个改进点：</p><p>（1）引入了CanCommit阶段</p><p>（2）在DoCommit阶段，各个库自己也有超时机制，也就是说，如果一个库收到了PreCommit自己还返回成功了，等了一会儿，如果超时时间到了，还没收到TM发送的DoCommit消息或者是abort消息，直接判定为TM可能出故障了，人家库自己颠儿颠儿的就执行DoCommit操作，提交事务了。</p><p>因为这里就是说，如果这个库接收到了PreCommit消息，说明第一阶段各个库对CanCommit都返回成功了啊，这样TM才会发送PreCommit来，那么就默认为基本上各个库的PreCommit都会成功，所以大家没接收到DoCommit，直接自己执行提交操作了</p><p>所以这个超时的机制是基于CanCommit的引入来实现的，有了一个CanCommit多了一个阶段，大家才能自己执行超时commit机制，这不就解决了TM挂掉的单点问题么，大家想想是不是这样子</p><p>另外资源阻塞问题也能减轻一下，因为一个库如果一直接收不到DoCommit消息，不会一直锁着资源，人家自己会提交释放资源的，所有能减轻资源阻塞问题，比2PC稍微好一些吧而已</p><p><img src="http://lion-heart.online/blog/2020-11-07-204616.png" alt="07_3PC的过程和原理"> </p><h4 id="3PC的缺陷："><a href="#3PC的缺陷：" class="headerlink" title="3PC的缺陷："></a>3PC的缺陷：</h4><p>但是其实这种的话，也不是完全就一定好的，因为还是可能有问题啊，如果人家TM在DoCommit阶段发送了abort消息给各个库，结果因为脑裂问题，某个库没接收到abort消息，自己还颠儿颠儿的执行了commit操作，不是也不对么</p><p>所以啊，其实2PC也好，3PC也好，都没法完全保证分布式事务的ok的，要明白这一点，总有一些特殊情况下会出问题的</p><h4 id="TCC方案：Try、Confirm、Cancel-最复杂的方案，三阶段都需要大量耦合业务，适用于核心业务场景对一致性要求非常高-金融-，必须保证各个业务执行的时间都比较短"><a href="#TCC方案：Try、Confirm、Cancel-最复杂的方案，三阶段都需要大量耦合业务，适用于核心业务场景对一致性要求非常高-金融-，必须保证各个业务执行的时间都比较短" class="headerlink" title="TCC方案：Try、Confirm、Cancel 最复杂的方案，三阶段都需要大量耦合业务，适用于核心业务场景对一致性要求非常高(金融)，必须保证各个业务执行的时间都比较短"></a>TCC方案：Try、Confirm、Cancel 最复杂的方案，三阶段都需要大量耦合业务，适用于核心业务场景对一致性要求非常高(金融)，必须保证各个业务执行的时间都比较短</h4><p>1）Try阶段：这个阶段说的是对各个服务的资源做检测(连通性)以及对资源进行锁定(X锁)或者预占/预留(提前进行逻辑处理)</p><p>2）Confirm阶段：这个阶段说的是在各个服务中执行实际的操作</p><p>3）Cancel阶段：如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，就是执行已经执行成功的业务逻辑的回滚操作</p><p><img src="http://lion-heart.online/blog/2020-11-07-211334.png" alt="04_TCC方案"></p><h5 id="落地方案细节"><a href="#落地方案细节" class="headerlink" title="落地方案细节"></a>落地方案细节</h5><ol><li>接口拆分<ul><li>从业务接口从1变3 -》try、confirm、cancel<ul><li>try：数据库检查、资源锁定或预留，目的是保证 confirm 阶段的正确进行</li><li>confirm：正常业务逻辑</li><li>cancel：回归方法，就是把 try 、 confirm 内对数据库的操作进行回滚</li></ul></li></ul></li><li>接口特殊情况<ul><li>空回滚：try 阶段因为网络问题，没接到请求过来。但是 cancel 接收到请求情况</li><li>try 回滚以及 confirm 回滚</li><li>请求倒置：confirm 比 try 先行，cancel 比 confirm 先行以及 cancel 比 try 先行等情况</li></ul></li><li>接口midengxing</li><li>tcc 分布式事务框架</li></ol><h5 id="变种方案"><a href="#变种方案" class="headerlink" title="变种方案"></a>变种方案</h5><h6 id="异步确保模型：无侵入模型-》可靠消息服务"><a href="#异步确保模型：无侵入模型-》可靠消息服务" class="headerlink" title="异步确保模型：无侵入模型 -》可靠消息服务"></a>异步确保模型：无侵入模型 -》可靠消息服务</h6><p>补偿性模型：do、compensate，</p><h4 id="本地消息表方案：严重依赖于数据库的消息表来管理事务，无法应对高并发场景，扩展性差"><a href="#本地消息表方案：严重依赖于数据库的消息表来管理事务，无法应对高并发场景，扩展性差" class="headerlink" title="本地消息表方案：严重依赖于数据库的消息表来管理事务，无法应对高并发场景，扩展性差"></a>本地消息表方案：严重依赖于数据库的消息表来管理事务，无法应对高并发场景，扩展性差</h4><p>1）A系统在自己本地一个事务里操作同时，插入一条数据到消息表</p><p>2）接着A系统将这个消息发送到MQ中去</p><p>3）B系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样保证不会重复处理消息</p><p>4）B系统执行成功之后，就会更新自己本地消息表的状态以及A系统消息表的状态</p><p>5）如果B系统处理失败了，那么就不会更新消息表状态，那么此时A系统会定时扫描自己的消息表，如果有没处理的消息，会再次发送到MQ中去，让B再次处理</p><p>6）这个方案保证了最终一致性，哪怕B事务失败了，但是A会不断重发消息，直到B那边成功为止</p><p><img src="http://lion-heart.online/blog/2020-11-07-213938.png" alt="05_本地消息表方案"></p><h5 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h5><ol><li>本地事物与消息发送的原子性<ul><li>本地事物 -》发送消息</li><li>发送消息 -》本地事物 </li><li>本地事物 -》本地消息表事物 -》定时任务扫描消息表 -》发送消息</li></ul></li><li>消息可靠性 -》保证消费者一定能接收到</li><li>消费方的幂等性 -》保证不重复消费</li></ol><h4 id="可靠消息最终一致性方案：基于MQ的事务消息，实现简单，适合事务周期长的业务场景"><a href="#可靠消息最终一致性方案：基于MQ的事务消息，实现简单，适合事务周期长的业务场景" class="headerlink" title="可靠消息最终一致性方案：基于MQ的事务消息，实现简单，适合事务周期长的业务场景"></a>可靠消息最终一致性方案：基于MQ的事务消息，实现简单，适合事务周期长的业务场景</h4><p>1）A系统先发送一个prepared消息到mq，如果这个prepared消息发送失败那么就直接取消操作别执行了</p><p>2）如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉mq发送确认消息，如果失败就告诉mq回滚消息</p><p>3）如果发送了确认消息，那么此时B系统会接收到确认消息，然后执行本地的事务</p><p>4）mq会自动定时轮询所有prepared消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认消息？那是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，别确认消息发送失败了。</p><p>5）这个方案里，要是系统B的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如B系统本地回滚后，想办法通知系统A也回滚；或者是发送报警由人工来手工回滚和补偿 </p><p>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用RocketMQ支持的，要不你就自己基于类似ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的</p><p><img src="http://lion-heart.online/blog/2020-11-07-213922.png" alt="05_本地消息表方案"></p><h4 id="最大努力通知方案：非核心服务，发起通知方通过一定的机制最大努力将业务处理结果通知接收方"><a href="#最大努力通知方案：非核心服务，发起通知方通过一定的机制最大努力将业务处理结果通知接收方" class="headerlink" title="最大努力通知方案：非核心服务，发起通知方通过一定的机制最大努力将业务处理结果通知接收方"></a>最大努力通知方案：非核心服务，发起通知方通过一定的机制最大努力将业务处理结果通知接收方</h4><p>1）系统A本地事务执行完之后，发送个消息到MQ</p><p>2）这里会有个专门消费MQ的最大努力通知服务，这个服务会消费MQ然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统B的接口</p><p>3）要是系统B执行成功就ok了；要是系统B执行失败了，那么最大努力通知服务就定时尝试重新调用系统B，反复N次，最后还是不行就放弃</p><p><img src="http://lion-heart.online/blog/2020-11-07-215729.png" alt="07_最大努力通知方案"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>重试机制</li><li>消息校对机制</li></ol><p>可靠消息一致性 与 最大努力通知方案的不同</p><ol><li>思想不同<ul><li>可靠消息一致性：事务一致性由消息来保证，消息的可靠性由发起方保证</li><li>最大努力通知：事务一致性由接收方来保证</li></ul></li><li>业务场景不同<ul><li>可靠消息一致性：交易过程</li><li>最大努力通知一致性：交易成功后续流程</li></ul></li><li>技术解决方向不同<ul><li>消息发送方保证消息的可靠性</li><li>消息的接收方保证消息的可靠性 </li></ul></li></ol><h4 id="SAGA-方案：适用于长事物，N多个服务串联一起执行，补偿机制"><a href="#SAGA-方案：适用于长事物，N多个服务串联一起执行，补偿机制" class="headerlink" title="SAGA 方案：适用于长事物，N多个服务串联一起执行，补偿机制"></a>SAGA 方案：适用于长事物，N多个服务串联一起执行，补偿机制</h4><h4 id="Seata-方案：业务无侵入，全面、完善的分布式事务解决方案。支持多种分布式事务方案-TCC、AT、Saga"><a href="#Seata-方案：业务无侵入，全面、完善的分布式事务解决方案。支持多种分布式事务方案-TCC、AT、Saga" class="headerlink" title="Seata 方案：业务无侵入，全面、完善的分布式事务解决方案。支持多种分布式事务方案 TCC、AT、Saga"></a>Seata 方案：业务无侵入，全面、完善的分布式事务解决方案。支持多种分布式事务方案 TCC、AT、Saga</h4><p>概念：全局事务、分支事务</p><p>组件：</p><ol><li>TC</li><li>TM</li><li>RM</li></ol><h4 id="Seata-AT-的2PC-和-基于XA-实现的2PC-区别"><a href="#Seata-AT-的2PC-和-基于XA-实现的2PC-区别" class="headerlink" title="Seata AT 的2PC 和 基于XA 实现的2PC 区别"></a>Seata AT 的2PC 和 基于XA 实现的2PC 区别</h4><ol><li>架构方面，传统2PC方案的 RM 实际上指的的是数据库实例，通过 XA 协议实现。而 Seata 的 RM 是以 jar 包的形式作为中间件层部署在应用侧</li><li>两阶段方面，传统2PC 资源的锁定一直是同步锁定。而 Seata 在第一阶段就提交本地事务，释放锁定资源，提高整体效率</li></ol><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ol><li>RM 使用 DataSourceProxy 连接数据库，使用 ConnectionProxy 在第一阶段将undoLog和业务数据放在一个本地事务提交，保证只要有业务操作一定会有undo_log（回滚日志）</li><li>TM 开启全局事务，将 XID 存在事务上下文中，通过 RPC 传入下游事务，每个分支事务将自己的 BID 和 XID 关联</li><li>第二阶段提交 -》TC 删除分支事务的 undo_log。第二阶段回滚 -》TC 通知参与者通过 undo_log 进行回滚</li></ol><h4 id="国内开源的分布式事务框架对比"><a href="#国内开源的分布式事务框架对比" class="headerlink" title="国内开源的分布式事务框架对比"></a>国内开源的分布式事务框架对比</h4><h5 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h5><h5 id="ByteTCC"><a href="#ByteTCC" class="headerlink" title="ByteTCC"></a>ByteTCC</h5><h5 id="Hmiliy"><a href="#Hmiliy" class="headerlink" title="Hmiliy"></a>Hmiliy</h5><h5 id="LCN"><a href="#LCN" class="headerlink" title="LCN"></a>LCN</h5><h5 id="Atomikos"><a href="#Atomikos" class="headerlink" title="Atomikos"></a>Atomikos</h5><h5 id="总结：大厂开源，小厂开源需要吃透、理解源码。自己造轮子。业务不是金融级跟钱直接相关的系统，普通的互联网系统，哪怕是订单系统，都不会上分布式事务，如果想上，也不会选择-TCC-，太麻烦。"><a href="#总结：大厂开源，小厂开源需要吃透、理解源码。自己造轮子。业务不是金融级跟钱直接相关的系统，普通的互联网系统，哪怕是订单系统，都不会上分布式事务，如果想上，也不会选择-TCC-，太麻烦。" class="headerlink" title="总结：大厂开源，小厂开源需要吃透、理解源码。自己造轮子。业务不是金融级跟钱直接相关的系统，普通的互联网系统，哪怕是订单系统，都不会上分布式事务，如果想上，也不会选择 TCC ，太麻烦。"></a>总结：大厂开源，小厂开源需要吃透、理解源码。自己造轮子。业务不是金融级跟钱直接相关的系统，普通的互联网系统，哪怕是订单系统，都不会上分布式事务，如果想上，也不会选择 TCC ，太麻烦。</h5><h4 id="分布式事务框架方案"><a href="#分布式事务框架方案" class="headerlink" title="分布式事务框架方案"></a>分布式事务框架方案</h4><h5 id="XA框架：二阶段"><a href="#XA框架：二阶段" class="headerlink" title="XA框架：二阶段"></a>XA框架：二阶段</h5><h5 id="TCC框架：核心链路的接口都需要写三套接口"><a href="#TCC框架：核心链路的接口都需要写三套接口" class="headerlink" title="TCC框架：核心链路的接口都需要写三套接口"></a>TCC框架：核心链路的接口都需要写三套接口</h5><h5 id="Saga框架"><a href="#Saga框架" class="headerlink" title="Saga框架"></a>Saga框架</h5><h5 id="Seata框架"><a href="#Seata框架" class="headerlink" title="Seata框架"></a>Seata框架</h5><h4 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h4><p>2PC</p><p>​    seata</p><p>TCC</p><p>​    himliy</p><p>可靠消息一致性</p><p>​    rocketMQ</p><p>最大努力通知</p><p>​    rocketMQ</p><h4 id="你们公司是如何处理分布式事务的？"><a href="#你们公司是如何处理分布式事务的？" class="headerlink" title="你们公司是如何处理分布式事务的？"></a>你们公司是如何处理分布式事务的？</h4><h5 id="好处：100-不会出现数据一致性问题"><a href="#好处：100-不会出现数据一致性问题" class="headerlink" title="好处：100%不会出现数据一致性问题"></a>好处：100%不会出现数据一致性问题</h5><h5 id="坏处：代码复杂的高、吞吐量、性能降低"><a href="#坏处：代码复杂的高、吞吐量、性能降低" class="headerlink" title="坏处：代码复杂的高、吞吐量、性能降低"></a>坏处：代码复杂的高、吞吐量、性能降低</h5><h5 id="核心：1-、0-1-的流程需要分布式事务解决方案"><a href="#核心：1-、0-1-的流程需要分布式事务解决方案" class="headerlink" title="核心：1%、0.1% 的流程需要分布式事务解决方案"></a>核心：1%、0.1% 的流程需要分布式事务解决方案</h5><h5 id="非核心：99-接口调用根本不需要分布式事务解决方案，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据"><a href="#非核心：99-接口调用根本不需要分布式事务解决方案，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据" class="headerlink" title="非核心：99%接口调用根本不需要分布式事务解决方案，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据"></a>非核心：99%接口调用根本不需要分布式事务解决方案，直接就是监控（发邮件、发短信）、记录日志（一旦出错，完整的日志）、事后快速的定位、排查和出解决方案、修复数据</h5><p>你其实用任何一个分布式事务的这么一个方案，都会导致你那块儿代码会复杂10倍。很多情况下，系统A调用系统B、系统C、系统D，我们可能根本就不做分布式事务。如果调用报错会打印异常日志</p><p>每个月也就那么几个bug，很多bug是功能性的，体验性的，真的是涉及到数据层面的一些bug，一个月就几个，两三个？如果你为了确保系统自动保证数据100%不能错，上了几十个分布式事务，代码太复杂，性能太差，系统吞吐量、性能大幅度下跌</p><p>每个月，每隔几个月，都会对少量的因为代码bug，导致出错的数据，进行人工的修复数据，自己临时动手写个程序，可能要补一些数据，可能要删除一些数据，可能要修改一些字段的值。</p><p>比你做50个分布式事务，成本要来的低上百倍，低几十倍</p><p>trade off、balance，要用分布式事务的时候，一定是有成本，代码会很复杂，开发很长时间，性能和吞吐量下跌，系统更加复杂更加脆弱反而更加容易出bug；好处，如果做好了，TCC、可靠消息最终一致性方案，一定可以100%保证你那快数据不会出错。</p><p>1%，0.1%，0.01%的业务，资金、交易、订单，我们会用分布式事务方案来保证，会员积分、优惠券、商品信息，其实不要这么搞了</p><h3 id="一致性强度（由高到低）"><a href="#一致性强度（由高到低）" class="headerlink" title="一致性强度（由高到低）"></a>一致性强度（由高到低）</h3><ol><li>2PC（强一致性）</li><li>TCC（强一致性）</li><li>可靠消息最终一致性（最终一致性）</li><li>消息最大努力通知（弱一致性）</li></ol><h3 id="侵入性（由高到低）"><a href="#侵入性（由高到低）" class="headerlink" title="侵入性（由高到低）"></a>侵入性（由高到低）</h3><ol><li>TCC （接口需要改造为 try 、confirm 、cancel）</li><li>2PC（数据库 undo_log）</li><li>可靠消息最终一致性（MQ 中间件）</li><li>消息最大努力通知（MQ、Http、WebService）</li></ol><h3 id="事务流程长短（由高到低）、是否锁定资源、阻塞业务流程"><a href="#事务流程长短（由高到低）、是否锁定资源、阻塞业务流程" class="headerlink" title="事务流程长短（由高到低）、是否锁定资源、阻塞业务流程"></a>事务流程长短（由高到低）、是否锁定资源、阻塞业务流程</h3><ol><li>可靠消息一致性</li><li>消息最大努力通知</li><li>TCC</li><li>2PC</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>全链路测试</title>
      <link href="/2020/11/07/%E5%85%A8%E9%93%BE%E8%B7%AF%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/11/07/%E5%85%A8%E9%93%BE%E8%B7%AF%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="全链路测试"><a href="#全链路测试" class="headerlink" title="全链路测试"></a>全链路测试</h2><h3 id="系统设计（概要设计、详细设计）"><a href="#系统设计（概要设计、详细设计）" class="headerlink" title="系统设计（概要设计、详细设计）"></a>系统设计（概要设计、详细设计）</h3><h4 id="概要设计：针对产品、需求，系统的运行流程，方案需要哪些技术"><a href="#概要设计：针对产品、需求，系统的运行流程，方案需要哪些技术" class="headerlink" title="概要设计：针对产品、需求，系统的运行流程，方案需要哪些技术"></a>概要设计：针对产品、需求，系统的运行流程，方案需要哪些技术</h4><p>​    业务架构：需要哪些模块、子系统、服务。系统、服务、模块之间的业务关系和交互流程，各个服务主要职责。运行期的简要流程，如何支撑产品所需的功能</p><p>​    技术架构：微服务框架、哪些中间件，中间件之间的协作和系统的定位，如何使用</p><p>​    业务流程：业务架构 + 技术架构 组合后如何支撑业务，核心流程梳理</p><p>​    技术方案：多套方案，最优解</p><p>​    部署方案：多少台实例支撑产品，中间件需要什么配置、多少台实例</p><h4 id="详细设计：可以落地的设计方案"><a href="#详细设计：可以落地的设计方案" class="headerlink" title="详细设计：可以落地的设计方案"></a>详细设计：可以落地的设计方案</h4><p>​    接口定义：微服务的接口定义，各个接口被请求时的系统运行时序图</p><p>​    数据库表结构：存储层落地方案</p><p>​    核心类建模(领域驱动)</p><p>​    技术方案细化：集群或主从等技术落地</p><h4 id="简化设计-已有系统迭代需求"><a href="#简化设计-已有系统迭代需求" class="headerlink" title="简化设计(已有系统迭代需求)"></a>简化设计(已有系统迭代需求)</h4><p>​    画一些系统运行流程图</p><p>​    技术方案</p><p>​    接口</p><p>​    表</p><p>​    时序图</p><h4 id="设计完毕之后，会有一个设计评审的过程，会找相关的其他同学过来评审，比如说给人家确认一下你设计的接口，是否满足你的调用方的需求"><a href="#设计完毕之后，会有一个设计评审的过程，会找相关的其他同学过来评审，比如说给人家确认一下你设计的接口，是否满足你的调用方的需求" class="headerlink" title="设计完毕之后，会有一个设计评审的过程，会找相关的其他同学过来评审，比如说给人家确认一下你设计的接口，是否满足你的调用方的需求"></a>设计完毕之后，会有一个设计评审的过程，会找相关的其他同学过来评审，比如说给人家确认一下你设计的接口，是否满足你的调用方的需求</h4><h4 id="开发代码"><a href="#开发代码" class="headerlink" title="开发代码"></a>开发代码</h4><p>每个人可能都是维护自己负责的子系统、服务，微服务框架，spring cloud alibaba里面的nacos + dubbo，用dubbo定义各种你需要对外提供的接口，按照你自己的设计文档以及技术方案去进行代码的开发 </p><p>如果仅仅是一些crud的话，此时基于数据库就可以搞定了 </p><p>但是如果说涉及到一些复杂的技术方案，使用中间件系统，es、redis、mongodb、hbase、rocketmq，等等 </p><h4 id="本地自测"><a href="#本地自测" class="headerlink" title="本地自测"></a>本地自测</h4><p>服务本地跑起来自己测试各个功能，直接通过dubbo服务调用，浏览器的http请求，直接请求你的接口，测试一下自己的各个功能，你自己一个人维护一个java web系统，不依赖别人的接口  </p><p>或者是在公司内网环境里，提供几台机器，作为dev环境，部署了数据库、缓存、MQ等中间件，服务可以部署，一台机器可以多部署几个服务，然后当你笔记本电脑在公司内网的时候，就可以访问到那几台机器，那么你本地启动，就可以直接访问到测试环境里的其他服务了。maven profile，spring boot profile，百度搜一下，非常的简单，都是很对不同的环境可以去放一套不同的配置资源文件</p><h4 id="持续集成：可选"><a href="#持续集成：可选" class="headerlink" title="持续集成：可选"></a>持续集成：可选</h4><p>jenkins持续集成的工具，如果发现你有提交代码以及合并的操作，此时jenkins会触发一个任务，拉取你的代码到本地，自动运行所有的单元测试，用你的单元测试自动运行和检查，来确保你现在最新的集成后的代码都是可以运行的</p><p>有的时候还会专门写特定的自动化集成测试代码，就是说你代码提交之后，然后可能会把你完整代码跑起来，此时所有代码是一个集成在一起的状态，接着就是运行集成测试的代码，把你集成在一起的代码都跑一下，检查是否正常 </p><p>但是这个比较麻烦，搞持续集成，在工具上要求git、jenkins之类的整合，你要做很多配置，同时要求你每天的代码都有对应的自动化测试代码，所以真的把持续集成做好，做的很标准的公司，其实不多</p><h4 id="联调测试-功能测试"><a href="#联调测试-功能测试" class="headerlink" title="联调测试/功能测试"></a>联调测试/功能测试</h4><p>比较正常的，就是你写好了代码，自己简单自测完毕了，然后部署到一个测试环境，是可能团队内部各个服务之间联调，或者甚至和其他团队的系统进行联调的地方</p><p>Test 环境最好是独立的一套环境，部署好之后，QA会进行大量的手工测试，各种点击系统，也可能会有自动化测试，不过说实话，能玩儿自动化测试的公司不多，最后在这个环境，会有一个PM功能验收测试的过程</p><p>这个环境重在联调，把各个系统和服务跑通，确保功能运行没问题，一般机器都是低配置的，而且一个服务就一台机器，甚至是一台机器几个服务都有可能</p><h4 id="预发布测试"><a href="#预发布测试" class="headerlink" title="预发布测试"></a>预发布测试</h4><p>预发布环境一般是模拟线上环境，可能会在这里做压力测试、全链路压测、性能测试、可用性测试、稳定性测试，都可能会在这里做，一般机器配置跟线上一样，每个服务都是独立机器，甚至每个服务给多台机器</p><p>比如说线上高峰QPS是1w+，线上机器是4核8G的，部署20台，那么预发布环境可能就是模拟每秒QPS是1000+，每个服务部署2台机器，做一个低压力测试，把全链路都压一下，测试性能，QPS，机器负载</p><p>在这个环境，通常流量是从线上获取回放过来的，有一个线上流量回放的过程，很多公司其实没这个环节，此时可能也就是走个过场，但是正经来说，是要做流量回放的，不是靠人力来测试，而是回放线上流量，看系统的功能是否正常，压力是否ok，性能是否还行，机器负载如何，全链路表现如何</p><h4 id="线上部署"><a href="#线上部署" class="headerlink" title="线上部署"></a>线上部署</h4><p>生产环境必须是一套独立的机器，直接进行部署即可，上线之后要通过各个机器的重要日志、请求是否正常、机器负载等是否正常、然后PM线上验收，一切正常，上线成功</p><p><img src="http://lion-heart.online/blog/2020-11-07-090332.png" alt="开发测试流程"></p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>RD：研发人员 - 自测</p><p>QA：测试人员 - test 测试</p><p>P/D：人/天</p><p>PM：产品经理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 面试集锦</title>
      <link href="/2020/10/25/mybatis/"/>
      <url>/2020/10/25/mybatis/</url>
      
        <content type="html"><![CDATA[<h2 id="一、架构分层"><a href="#一、架构分层" class="headerlink" title="一、架构分层"></a>一、架构分层</h2><h3 id="1、API-层"><a href="#1、API-层" class="headerlink" title="1、API 层"></a>1、API 层</h3><h3 id="2、数据处理层"><a href="#2、数据处理层" class="headerlink" title="2、数据处理层"></a>2、数据处理层</h3><h3 id="3、基础支撑层"><a href="#3、基础支撑层" class="headerlink" title="3、基础支撑层"></a>3、基础支撑层</h3><p><img src="http://lion-heart.online/blog/2020-11-18-131359.png" alt="截屏2020-11-15 下午9.34.54"></p><h2 id="二、自定义持久层框架"><a href="#二、自定义持久层框架" class="headerlink" title="二、自定义持久层框架"></a>二、自定义持久层框架</h2><h3 id="JDBC-实现版本"><a href="#JDBC-实现版本" class="headerlink" title="JDBC 实现版本"></a>JDBC 实现版本</h3><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol><li>引入依赖</li><li>配置核心配置文件<ul><li>mybatis.xml 核心配置文件</li><li>mapper.xml 映射配置文件</li></ul></li></ol><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ol><li><h5 id="读取核心配置，字节流加载到内存"><a href="#读取核心配置，字节流加载到内存" class="headerlink" title="读取核心配置，字节流加载到内存"></a>读取核心配置，字节流加载到内存</h5></li><li><h5 id="解析配置文件，构建容器-Configuration-对象，构建-SqlSessionFactory-对象"><a href="#解析配置文件，构建容器-Configuration-对象，构建-SqlSessionFactory-对象" class="headerlink" title="解析配置文件，构建容器 Configuration 对象，构建 SqlSessionFactory 对象"></a>解析配置文件，构建容器 Configuration 对象，构建 SqlSessionFactory 对象</h5><ol><li>解析配置文件 parse.parse()</li><li>创建 DefaultSqlSessionFactory 对象 build()</li></ol></li><li><h5 id="SqlSessionFactoryBuilder-对象"><a href="#SqlSessionFactoryBuilder-对象" class="headerlink" title="SqlSessionFactoryBuilder 对象"></a>SqlSessionFactoryBuilder 对象</h5><ul><li>创建DefaultSqlSessionFactory</li></ul></li><li><h5 id="创建-SqlSesion-对象"><a href="#创建-SqlSesion-对象" class="headerlink" title="创建 SqlSesion 对象"></a>创建 SqlSesion 对象</h5><ul><li>CRUD 方法定义</li></ul></li><li><h5 id="Excutor对象"><a href="#Excutor对象" class="headerlink" title="Excutor对象"></a>Excutor对象</h5><ul><li>封装 query 方法</li></ul></li></ol><h3 id="动态代理实现"><a href="#动态代理实现" class="headerlink" title="动态代理实现"></a>动态代理实现</h3><h3 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><h5 id="作用域：sqlSession-级别"><a href="#作用域：sqlSession-级别" class="headerlink" title="作用域：sqlSession 级别"></a>作用域：sqlSession 级别</h5><h5 id="底层数据：Perpetual-类内-HashMap"><a href="#底层数据：Perpetual-类内-HashMap" class="headerlink" title="底层数据：Perpetual 类内 HashMap"></a>底层数据：Perpetual 类内 HashMap</h5><h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><h5 id="作用域：namespace"><a href="#作用域：namespace" class="headerlink" title="作用域：namespace"></a>作用域：namespace</h5><h5 id="底层结构：hashMap"><a href="#底层结构：hashMap" class="headerlink" title="底层结构：hashMap"></a>底层结构：hashMap</h5><h5 id="问题：多表-gt-脏读"><a href="#问题：多表-gt-脏读" class="headerlink" title="问题：多表 -&gt; 脏读"></a>问题：多表 -&gt; 脏读</h5><h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><h2 id="完整会话流程？"><a href="#完整会话流程？" class="headerlink" title="完整会话流程？"></a>完整会话流程？</h2><p><img src="http://lion-heart.online/blog/2020-10-25-113714.png" alt="会话工厂流程"></p><p><img src="http://lion-heart.online/blog/2020-10-25-113813.png" alt="会话流程"></p><p><img src="http://lion-heart.online/blog/2020-10-25-114058.png" alt="代理对象"></p><p><img src="http://lion-heart.online/blog/2020-10-25-114213.png" alt="执行SQL"></p><h1 id="面试题集锦"><a href="#面试题集锦" class="headerlink" title="面试题集锦"></a>面试题集锦</h1><h2 id="mybatis解决什么问题？"><a href="#mybatis解决什么问题？" class="headerlink" title="mybatis解决什么问题？"></a>mybatis解决什么问题？</h2><p>资源管理</p><p>SQL与业务代码分离，动态SQL</p><p>结果集自动映射</p><p>参数自动转换和绑定</p><p>缓存机制</p><p>拦截器扩展点</p><h2 id="核心对象和作用？"><a href="#核心对象和作用？" class="headerlink" title="核心对象和作用？"></a>核心对象和作用？</h2><p>SqlSession API</p><p>MapperProxy 对接口进行代理，找到sql交给执行器执行</p><h2 id="Java类型和数据库类型如何映射？"><a href="#Java类型和数据库类型如何映射？" class="headerlink" title="Java类型和数据库类型如何映射？"></a>Java类型和数据库类型如何映射？</h2><p>TypeHandler 实现</p><h2 id="resultType-和-resultMap-区别？"><a href="#resultType-和-resultMap-区别？" class="headerlink" title="resultType 和 resultMap 区别？"></a>resultType 和 resultMap 区别？</h2><h2 id="一二级缓存区别？"><a href="#一二级缓存区别？" class="headerlink" title="一二级缓存区别？"></a>一二级缓存区别？</h2><h2 id="mybatis支持哪些数据源类型？"><a href="#mybatis支持哪些数据源类型？" class="headerlink" title="mybatis支持哪些数据源类型？"></a>mybatis支持哪些数据源类型？</h2><p>POOLED： pooledDataSource</p><p>UNPOOLED：Connection</p><p>JNDI：</p><h2 id="延迟加载如何实现？"><a href="#延迟加载如何实现？" class="headerlink" title="延迟加载如何实现？"></a>延迟加载如何实现？</h2><p>JDK代理方式 和 CGLIB代理方式</p><h2 id="分页方式和区别？"><a href="#分页方式和区别？" class="headerlink" title="分页方式和区别？"></a>分页方式和区别？</h2><p>逻辑：数据 load 内存，进行分页，RowBundls</p><p>物理：动态替换SQL语句实现，limit x，x</p><h2 id="PrepareStatementHandler-和-StatementHandler-区别？"><a href="#PrepareStatementHandler-和-StatementHandler-区别？" class="headerlink" title="PrepareStatementHandler 和 StatementHandler 区别？"></a>PrepareStatementHandler 和 StatementHandler 区别？</h2><h2 id="解析全局配置文件流程？解析Mapper流程？"><a href="#解析全局配置文件流程？解析Mapper流程？" class="headerlink" title="解析全局配置文件流程？解析Mapper流程？"></a>解析全局配置文件流程？解析Mapper流程？</h2><p>Configuration：SqlSession + Executor</p><p>MappedStatement：一个SQL的入参、结果、完整语句信息</p><h2 id="没有实现类，MyBatis-方法如何执行？"><a href="#没有实现类，MyBatis-方法如何执行？" class="headerlink" title="没有实现类，MyBatis 方法如何执行？"></a>没有实现类，MyBatis 方法如何执行？</h2><p>动态代理 MapperProxy 实现，构造器传入SqlSession</p><h2 id="怎么根据接口方法获取SQL语句？"><a href="#怎么根据接口方法获取SQL语句？" class="headerlink" title="怎么根据接口方法获取SQL语句？"></a>怎么根据接口方法获取SQL语句？</h2><p>MappedStatement 实现</p><h2 id="四大对象创建？"><a href="#四大对象创建？" class="headerlink" title="四大对象创建？"></a>四大对象创建？</h2><p>Executor  -&gt; openSession</p><p>其他三个对象是在执行SQL时创建</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>单例 - Configuration</p><p>工厂 - SqlSessionFactory</p><p>责任链 - interceptorChain  </p><p>建造者 - SqlSessionFactoryBuilder</p><p>装饰器 - CacheingExecutor</p><p>模板方法 - BaseExecutor - Simple、Reuse、Batch</p><p>动态代理 - MapperProxy、DefaultSqlSessionProxy</p><h2 id="执行流程？"><a href="#执行流程？" class="headerlink" title="执行流程？"></a>执行流程？</h2><p>解析配置 - mybatis-config.xml 、mapper.xml</p><ul><li>Configuration</li><li>MappedStatement</li></ul><p>创建工厂 - SqlSessionFactory</p><p>创建会话 - SqlSession</p><p>操作数据库 - Executor、StatementHandler、ParameterHandler、ResultSetHandler</p><h2 id="插件流程？原理？"><a href="#插件流程？原理？" class="headerlink" title="插件流程？原理？"></a>插件流程？原理？</h2><p><img src="http://lion-heart.online/blog/2020-10-25-111158.png" alt="plugins"></p><h2 id="集成Spring原理？"><a href="#集成Spring原理？" class="headerlink" title="集成Spring原理？"></a>集成Spring原理？</h2><p>利用了spring扩展机制，BeanDefinition初始化前后进行自定义FactoryBean的注入实现，把一些复杂的对象通过spring去管理</p><p>SqlSessionTemplate</p><p>MapperFactoyBean </p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 面试集锦</title>
      <link href="/2020/10/05/JVM/"/>
      <url>/2020/10/05/JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM-面试集锦"><a href="#JVM-面试集锦" class="headerlink" title="JVM 面试集锦"></a>JVM 面试集锦</h1><h2 id="垃圾回收优化目的"><a href="#垃圾回收优化目的" class="headerlink" title="垃圾回收优化目的"></a>垃圾回收优化目的</h2><p><strong>合理的对线程系统优化内存分配和垃圾回收，尽可能减少垃圾回收的频率，降低垃圾回收的时间，减少垃圾回收对系统运行的影响.尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响</strong></p><h2 id="JVM有哪些部分组成？"><a href="#JVM有哪些部分组成？" class="headerlink" title="JVM有哪些部分组成？"></a>JVM有哪些部分组成？</h2><ul><li>类加载器</li><li>运行时数据区<ul><li>堆：JVM 规范 分代模型</li><li>方法区</li><li>JVM 栈</li><li>本地方法栈</li><li>程序计数器</li></ul></li><li>执行引擎</li><li>本地库接口</li></ul><h2 id="怎么样通过Java程序来判断JVM是32位还是64位？"><a href="#怎么样通过Java程序来判断JVM是32位还是64位？" class="headerlink" title="怎么样通过Java程序来判断JVM是32位还是64位？"></a>怎么样通过Java程序来判断JVM是32位还是64位？</h2><p>通过Java程序来判断: System.out.println(System.clearProperty(“sun.arch.data.model”));</p><h2 id="JVM的类加载机制"><a href="#JVM的类加载机制" class="headerlink" title="JVM的类加载机制"></a>JVM的类加载机制</h2><h2 id="JVM的核心运行流程"><a href="#JVM的核心运行流程" class="headerlink" title="JVM的核心运行流程"></a>JVM的核心运行流程</h2><h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><h2 id="JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？"><a href="#JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？" class="headerlink" title="JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？"></a>JVM的垃圾回收机制是用来干嘛的？为什么要垃圾回收？</h2><p>我们在Java堆内存里创建的对象，都是占用内存资源的，而且内存资源有限。对于不需要使用的对象，我们要清理掉，从内存里清除掉，让他不再占用任何内存资源。</p><h2 id="我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？"><a href="#我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？" class="headerlink" title="我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？"></a>我们创建的那些对象，到底在Java堆内存里会占用多少内存空间呢？</h2><ul><li>对象头<ul><li>64 位 linux os 上，16 byte</li></ul></li><li>类型指针<ul><li>普通对象 16 byte</li><li>数组</li></ul></li><li>实例数据<ul><li>int 4 byte</li><li>long 8 byte</li></ul></li><li>JVM 优化<ul><li>补齐机制</li><li>指针压缩</li></ul></li></ul><h2 id="JVM-运行时数据区内的堆空间为什么要分代？如何划分？"><a href="#JVM-运行时数据区内的堆空间为什么要分代？如何划分？" class="headerlink" title="JVM 运行时数据区内的堆空间为什么要分代？如何划分？"></a>JVM 运行时数据区内的堆空间为什么要分代？如何划分？</h2><p>对象生命周期的不同，导致有的对象存活的很久，由的对象存活的很短。又由于有限的资源空间不可能存储无限的对象。这就需要垃圾回收机制帮我们清理垃圾对象，如果所有对象都在一块内存区域，gc 就需要扫描一整块区域，如果我们将一整块区域拆分开，分别清理(不同的 gc 算法)，那将大大提高 gc 效率。</p><ul><li>年轻代</li><li>年老代</li></ul><h2 id="对象到底什么时候进入新生代？然后什么情况下会进入老年代？"><a href="#对象到底什么时候进入新生代？然后什么情况下会进入老年代？" class="headerlink" title="对象到底什么时候进入新生代？然后什么情况下会进入老年代？"></a>对象到底什么时候进入新生代？然后什么情况下会进入老年代？</h2><p>大部分正常对象都优先在新生代分配内存</p><h2 id="什么情况下会触发新生代的垃圾回收？"><a href="#什么情况下会触发新生代的垃圾回收？" class="headerlink" title="什么情况下会触发新生代的垃圾回收？"></a>什么情况下会触发新生代的垃圾回收？</h2><p>eden 区无法为新对象分配内存空间 。这个时候，就会触发一次新生代内存空间的垃圾回收，新生代内存空间的垃圾回收，也称之为“Minor GC”，有的时候我们也叫“Young GC”，他会尝试把新生代里那些没有引用的垃圾对象，都给回收掉。</p><h2 id="方法区的类、废弃的常量会被垃圾回收吗？什么时候被回收？为什么呢？"><a href="#方法区的类、废弃的常量会被垃圾回收吗？什么时候被回收？为什么呢？" class="headerlink" title="方法区的类、废弃的常量会被垃圾回收吗？什么时候被回收？为什么呢？"></a>方法区的类、废弃的常量会被垃圾回收吗？什么时候被回收？为什么呢？</h2><ol><li>会回收</li><li>满足三个条件<ul><li>该类的所有实例对象都已经从Java堆内存里被回收</li><li>加载这个类的ClassLoader已经被回收</li><li>对该类的Class对象没有任何引用</li></ul></li></ol><h2 id="JVM-的gc为什么要分代？"><a href="#JVM-的gc为什么要分代？" class="headerlink" title="JVM 的gc为什么要分代？"></a>JVM 的gc为什么要分代？</h2><p>对传统的GC的实现，在整个GC过程中都要”stop -the -world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分。</p><p>所以可以通过分代思路来解决，分代思路基于：大部分对象的声明周期很短，没有死亡的对象则可能会存活很长时间。所以基于这种情况，如果让新创建的对象都在young gen 里创建，然后频繁收集young gen，则大部分垃圾都能在young GC 中被收集掉。由于young gen 的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率(或者说较低的对象存活率)让其非常适合使用copying算法来收集，这样就能降低单次GC的时间长度，还可以提高GC的工作效率。</p><h2 id="每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？"><a href="#每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？" class="headerlink" title="每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？"></a>每个线程都有Java虚拟机栈，里面也有方法的局部变量等数据，这个Java虚拟机栈需要进行垃圾回收吗？为什么？</h2><ul><li><p>不会</p></li><li><p>JVM GC针对的是新生代，老年代，还有方法区（永久代），不会针对方法的栈帧。</p></li></ul><h2 id="JVM-参数相关"><a href="#JVM-参数相关" class="headerlink" title="JVM 参数相关"></a>JVM 参数相关</h2><ul><li>-Xmn：新生代大小</li><li>-Xms：堆大小</li><li>-Xmx：最大堆空间</li><li>-Xss：栈内存大小</li><li>-XX:PermSize：永久代大小</li><li>-XX:MaxPermSize：最大永久代大小</li></ul><h2 id="二周目：短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor-GC，然后长生存周期的对象如何转移到老年代里去。"><a href="#二周目：短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor-GC，然后长生存周期的对象如何转移到老年代里去。" class="headerlink" title="二周目：短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor GC，然后长生存周期的对象如何转移到老年代里去。"></a>二周目：短生存周期的对象和长生存周期的对象分别是什么，他们是如何在新生代里分配的，新生代什么时候触发Minor GC，然后长生存周期的对象如何转移到老年代里去。</h2><h2 id="如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。"><a href="#如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。" class="headerlink" title="如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。"></a>如何根据这个系统未来预估的业务量，访问量，去推算这个系统每秒种的并发量，然后推算每秒钟的请求对内存空间的占用，进而推算出整个系统运行期间的JVM内存运转模型。</h2><h3 id="系统需要部署多少台机器？每台机器需要多大的内存空间？每台机器上启动的JVM需要分配多大的堆内存空间？"><a href="#系统需要部署多少台机器？每台机器需要多大的内存空间？每台机器上启动的JVM需要分配多大的堆内存空间？" class="headerlink" title="系统需要部署多少台机器？每台机器需要多大的内存空间？每台机器上启动的JVM需要分配多大的堆内存空间？"></a>系统需要部署多少台机器？每台机器需要多大的内存空间？每台机器上启动的JVM需要分配多大的堆内存空间？</h3><h3 id="JVM多大的内存空间才能保证可以支撑百万请求在内存里的创建，而不会导致内存不够直接崩溃？"><a href="#JVM多大的内存空间才能保证可以支撑百万请求在内存里的创建，而不会导致内存不够直接崩溃？" class="headerlink" title="JVM多大的内存空间才能保证可以支撑百万请求在内存里的创建，而不会导致内存不够直接崩溃？"></a>JVM多大的内存空间才能保证可以支撑百万请求在内存里的创建，而不会导致内存不够直接崩溃？</h3><h3 id="每个对象需要多大内存空间？估算系统压力吗？估算系统的JVM内存压力吗？有针对性的合理设置JVM参数吗？之前是这么做的吗？为什么？"><a href="#每个对象需要多大内存空间？估算系统压力吗？估算系统的JVM内存压力吗？有针对性的合理设置JVM参数吗？之前是这么做的吗？为什么？" class="headerlink" title="每个对象需要多大内存空间？估算系统压力吗？估算系统的JVM内存压力吗？有针对性的合理设置JVM参数吗？之前是这么做的吗？为什么？"></a>每个对象需要多大内存空间？估算系统压力吗？估算系统的JVM内存压力吗？有针对性的合理设置JVM参数吗？之前是这么做的吗？为什么？</h3><h2 id="三周目"><a href="#三周目" class="headerlink" title="三周目"></a>三周目</h2><h2 id="什么情况下JVM内存中的一个对象会被垃圾回收？"><a href="#什么情况下JVM内存中的一个对象会被垃圾回收？" class="headerlink" title="什么情况下JVM内存中的一个对象会被垃圾回收？"></a>什么情况下JVM内存中的一个对象会被垃圾回收？</h2><h2 id="万一垃圾回收过后，存活下来的对象超过了10-的内存空间，在另外一块Survivor区域中放不下咋整？"><a href="#万一垃圾回收过后，存活下来的对象超过了10-的内存空间，在另外一块Survivor区域中放不下咋整？" class="headerlink" title="万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？"></a>万一垃圾回收过后，存活下来的对象超过了10%的内存空间，在另外一块Survivor区域中放不下咋整？</h2><h2 id="万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？"><a href="#万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？" class="headerlink" title="万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？"></a>万一我们突然分配了一个超级大的对象，大到啥程度？新生代找不到连续内存空间来存放，此时咋整？</h2><h2 id="到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？"><a href="#到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？" class="headerlink" title="到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？"></a>到底一个存活对象要在新生代里这么来回倒腾多少次之后才会被转移都老年代去？</h2><h2 id="到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？"><a href="#到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？" class="headerlink" title="到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？"></a>到底是单线程进行垃圾回收好呢？还是多线程进行垃圾回收好呢？在不同的场景下有各自的优缺点吗？</h2><h2 id="eden区和survivor区-对象是通过什么规则被分配到这两个区的呢？"><a href="#eden区和survivor区-对象是通过什么规则被分配到这两个区的呢？" class="headerlink" title="eden区和survivor区 对象是通过什么规则被分配到这两个区的呢？"></a>eden区和survivor区 对象是通过什么规则被分配到这两个区的呢？</h2><h2 id="如何不发生FullGC"><a href="#如何不发生FullGC" class="headerlink" title="如何不发生FullGC"></a>如何不发生FullGC</h2><p>首先上线系统之后，要借助一些工具（后面会讲）观察每秒钟会新增多少对象在新生代里，然后多长时间触发一次Minor GC，平均每次MInor GC之后会有多少对象存活，Survivor区是否可以放的下。</p><p>这里的关键点就是必须让Survivor区放下，而且不能因为动态年龄判定规则直接升入老年代。然后只要Survivor区可以放下，那么下次Minor GC后还是存活这么多对象，依然可以在另外一块Survivor区放下，基本就不会有对象升入老年代里去。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li>JVM 核心运行组成</li><li>JVM 运行原理</li><li>什么是垃圾</li><li>如何发现垃圾</li><li>GC 算法</li><li>GC 收集器</li><li>什么时候出发 Minor GC</li><li>触发Minor GC之前会如何检查老年代可用内存大小和新生代对象大小，如何检查老年代可用内存大小和历次Minor GC之后升入老年代的平均对象大小</li><li>什么情况下Minor GC之前会提前触发Full GC，什么情况下会直接触发Minor GC</li><li>Minor GC之后有哪几种情况对象会进入老年代</li></ol><h3 id="深入了解年轻代垃圾收集器-PerNew-原理"><a href="#深入了解年轻代垃圾收集器-PerNew-原理" class="headerlink" title="深入了解年轻代垃圾收集器 PerNew 原理"></a>深入了解年轻代垃圾收集器 PerNew 原理</h3><h3 id="如何使用-PerNew-GC"><a href="#如何使用-PerNew-GC" class="headerlink" title="如何使用 PerNew GC"></a>如何使用 PerNew GC</h3><p>-XX:+UseParNewGC</p><h3 id="ParNew垃圾回收器默认情况下的线程数量"><a href="#ParNew垃圾回收器默认情况下的线程数量" class="headerlink" title="ParNew垃圾回收器默认情况下的线程数量"></a><strong>ParNew垃圾回收器默认情况下的线程数量</strong></h3><p>默认设置的垃圾回收线程的数量就是跟CPU的核数是一样</p><p>可以通过 -XX:ParallelGCThreads 指定</p><p><img src="http://lion-heart.online/blog/2020-10-06-055241.png" alt="多线程方式"></p><h3 id="到底是用单线程垃圾回收好，还是多线程垃圾回收好？"><a href="#到底是用单线程垃圾回收好，还是多线程垃圾回收好？" class="headerlink" title="到底是用单线程垃圾回收好，还是多线程垃圾回收好？"></a>到底是用单线程垃圾回收好，还是多线程垃圾回收好？</h3><p>主要看场景和机器配置</p><p>单核的配置采用单线程好，多核的配置采用多线程好</p><h3 id="到底是Serial垃圾回收器好还是ParNew垃圾回收器好？"><a href="#到底是Serial垃圾回收器好还是ParNew垃圾回收器好？" class="headerlink" title="到底是Serial垃圾回收器好还是ParNew垃圾回收器好？"></a>到底是Serial垃圾回收器好还是ParNew垃圾回收器好？</h3><p>Serial 就是单线程</p><p>ParNew 就是多线程，参考上面的答案</p><h2 id="仅仅young-gc，而几乎没有full-gc？"><a href="#仅仅young-gc，而几乎没有full-gc？" class="headerlink" title="仅仅young gc，而几乎没有full gc？"></a>仅仅young gc，而几乎没有full gc？</h2><p>只要结合自己系统的运行，根据他的内存占用情况，GC后的对象存活情况，合理分配Eden、Survivor、老年代的内存大小，合理设置一些参数</p><h2 id="CMS-垃圾收集器原理"><a href="#CMS-垃圾收集器原理" class="headerlink" title="CMS 垃圾收集器原理"></a>CMS 垃圾收集器原理</h2><h3 id="如何使用-CMS"><a href="#如何使用-CMS" class="headerlink" title="如何使用 CMS"></a>如何使用 CMS</h3><h3 id="CMS垃圾回收器默认情况下的线程数量"><a href="#CMS垃圾回收器默认情况下的线程数量" class="headerlink" title="CMS垃圾回收器默认情况下的线程数量"></a>CMS垃圾回收器默认情况下的线程数量</h3><p>（CPU核数 + 3）/ 4</p><p>垃圾回收线程和系统工作线程尽量同时执行的模式来处理的。</p><ol><li><p>初始标记(STW)</p><ul><li>标记出来所有GC Roots直接引用的对象</li><li><img src="http://lion-heart.online/blog/2020-10-06-063232.png" alt="初始标记"></li></ul></li><li><p>并发标记</p><ul><li>是对老年代所有对象进行GC Roots追踪，从GC Roots追踪所有对象是否从根源上被GC Roots引用了，最耗时的阶段</li><li><img src="http://lion-heart.online/blog/2020-10-06-064036.png" alt="并发标记"></li></ul></li><li><p>重新标记(STW)</p><ul><li>对在第二阶段中被系统程序运行变动过的少数对象进行标记。标记存活、标记垃圾</li><li>被新建的对象，被变动的对象，有数据结构记录，所以这个阶段很快</li><li><img src="http://lion-heart.online/blog/2020-10-06-070138.png" alt="重新标记第二阶段新产生的对象"></li></ul></li><li><p>并发清理：并发执行</p><ul><li><p>来清理掉之前标记为垃圾的对象即可</p></li><li><p><img src="http://lion-heart.online/blog/2020-10-06-070538.png" alt="并发清理"></p></li></ul></li></ol><p>总结：简单来说，为了避免长时间“Stop the World”，CMS采用了4个阶段来垃圾回收，其中初始标记和重新标记，耗时很短，虽然会导致“Stop the World”，但是影响不大。</p><p>然后并发标记和并发清理，两个阶段耗时最长，但是是可以跟系统的工作线程并发运行的，所以对系统没太大影响。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ol><li>CPU 资源占用</li><li>Concurrent Mode Failure<ul><li>浮动垃圾：并发清理期间，进入到老年代，短时间内又没有引用的对象</li><li>-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。</li><li>自动用“Serial Old”垃圾回收器替代CMS</li></ul></li><li>内存碎片<ul><li>-XX:CMSFullGCsBeforeCompaction 碎片整理工作</li><li>-XX:+UseCMSCompactAtFullCollection 开启 标记-整理 GC 算法，默认 标记 - 清除 GC 算法</li></ul></li></ol><h3 id="为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？"><a href="#为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？" class="headerlink" title="为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？"></a>为什么老年代的垃圾回收速度会比新生代的垃圾回收速度慢很多倍？到底慢在哪里？</h3><p>算法本身的快慢原因</p><p>复制算法 - 遍历一次 GC Roots 即可完成 GC</p><p>标记清理 - 遍历两次，第一次从GC Roots 标记存活对象，第二次 遍历内存中所有对象找到标记垃圾对象，进行清理</p><p>分代特性原因</p><p>年轻代特性：空间小，存活对象少，迁移内存很快，让后一次性清理垃圾对象。</p><p>老年代特性：空间大，存活对象很多，漫长的对象移动（找到垃圾清理，存活对象空间整理）</p><p>CMS 本身会引发其他问题</p><p>总结：新生代执行速度其实很快，因为直接从GC Roots出发就追踪哪些对象是活的就行了，新生代存活对象是很少的，这个速度是极快的，不需要追踪多少对象。然后直接把存活对象放入Survivor中，就一次性直接回收Eden和之前使用的Survivor了。</p><p>但是CMS的Full GC呢？</p><p>在并发标记阶段，他需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；</p><p>其次并发清理阶段，他不是一次性回收一大片内存，而是找到零零散散在各个地方的垃圾对象，速度也很慢；最后完事儿了，还得执行一次内存碎片整理，把大量的存活对象给挪在一起，空出来连续内存空间，这个过程还得“Stop theWorld”，那就更慢了。</p><p>万一并发清理期间，剩余内存空间不足以存放要进入老年代的对象了，引发了“Concurrent Mode Failure”问题，那更是麻烦，还得立马用“Serial Old”垃圾回收器，“Stop the World”之后慢慢重新来一遍回收的过程，这更是耗时了。</p><h2 id="GC-Rtoos-是什么？"><a href="#GC-Rtoos-是什么？" class="headerlink" title="GC Rtoos 是什么？"></a>GC Rtoos 是什么？</h2><p>所谓“GC roots”，或者说tracing GC的“根集合”，就是<strong>一组必须活跃的引用</strong><br>例如说，这些引用可能包括：</p><ul><li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li><li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li><li>JNI handles，包括global handles和local handles</li><li>（看情况）所有当前被加载的Java类</li><li>（看情况）Java类的引用类型静态变量</li><li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li><li>（看情况）String常量池（StringTable）里的引用</li></ul><p>Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。<strong>注意再注意：tracing GC的本质是<code>通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间</code></strong><br>GC roots这组引用是tracing GC的<strong>起点</strong>。要实现语义正确的tracing GC，就必须要能完整枚举出<strong>所有的GC roots</strong>，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。</p><p>那么分代式GC对GC roots的定义有什么影响呢？<br>答案是：分代式GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。</p><p>具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC roots的一部分。<br>继续具体到HotSpot VM里的分两代式GC来说，除了old gen到young gen的引用之外，有些带有弱引用语义的结构，例如说记录所有当前被加载的类的SystemDictionary、记录字符串常量引用的StringTable等，在young GC时必须要作为strong GC roots，而在收集整堆的full GC时则不会被看作strong GC roots。</p><p>换句话说，young GC比full GC的GC roots还要更大一些。如果不能理解这个道理，那整个讨论也就无从谈起了</p><h2 id="ParNew-CMS的组合让我们有哪些痛点？"><a href="#ParNew-CMS的组合让我们有哪些痛点？" class="headerlink" title="ParNew + CMS的组合让我们有哪些痛点？"></a>ParNew + CMS的组合让我们有哪些痛点？</h2><p>STW 问题，无论是年轻代还是老年代都会产生。其次 CMS 的问题，浮动垃圾导致的 Concurrent Mode Failure、标记清理算法导致的碎片问题、并行标记和并行清理阶段的CPU占用问题，极端情况下老年代收集器变成 Serial Old </p><h2 id="G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配？"><a href="#G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配？" class="headerlink" title="G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配？"></a>G1垃圾回收器的设计思想，包括Region的划分，然后Region动态转移给新生代或者老年代，按需分配？</h2><p>思想：G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象</p><h2 id="G1是如何工作的？"><a href="#G1是如何工作的？" class="headerlink" title="G1是如何工作的？"></a>G1是如何工作的？</h2><h2 id="对象什么时候进入新生代的Region？"><a href="#对象什么时候进入新生代的Region？" class="headerlink" title="对象什么时候进入新生代的Region？"></a>对象什么时候进入新生代的Region？</h2><h2 id="什么时候触发Region-GC？"><a href="#什么时候触发Region-GC？" class="headerlink" title="什么时候触发Region GC？"></a>什么时候触发Region GC？</h2><h2 id="什么时候对象进入老年代的Region？"><a href="#什么时候对象进入老年代的Region？" class="headerlink" title="什么时候对象进入老年代的Region？"></a>什么时候对象进入老年代的Region？</h2><h2 id="什么时候触发老年代的Region-GC？"><a href="#什么时候触发老年代的Region-GC？" class="headerlink" title="什么时候触发老年代的Region GC？"></a>什么时候触发老年代的Region GC？</h2><h2 id="GC-实战"><a href="#GC-实战" class="headerlink" title="GC 实战"></a>GC 实战</h2><h3 id="GC-日志相关"><a href="#GC-日志相关" class="headerlink" title="GC 日志相关"></a>GC 日志相关</h3><h3 id="Jstat-命令：简单易用、高效实用的命令行jvm监控工具。实现查看-JVM-整体运行情况"><a href="#Jstat-命令：简单易用、高效实用的命令行jvm监控工具。实现查看-JVM-整体运行情况" class="headerlink" title="Jstat 命令：简单易用、高效实用的命令行jvm监控工具。实现查看 JVM 整体运行情况"></a>Jstat 命令：简单易用、高效实用的命令行jvm监控工具。实现查看 JVM 整体运行情况</h3><p>Eden、Survivor、老年代的内存使用情况，还有Young GC和Full gC的执行次数以及耗时</p><pre class=" language-html"><code class="language-html">S0C：这是From Survivor区的大小S1C：这是To Survivor区的大小S0U：这是From Survivor区当前使用的内存大小S1U：这是To Survivor区当前使用的内存大小EC：这是Eden区的大小EU：这是Eden区当前使用的内存大小OC：这是老年代的大小OU：这是老年代当前使用的内存大小MC：这是方法区（永久代、元数据区）的大小MU：这是方法区（永久代、元数据区）的当前使用的内存大小YGC：这是系统运行迄今为止的Young GC次数YGCT：这是Young GC的耗时FGC：这是系统运行迄今为止的Full GC次数FGCT：这是Full GC的耗时GCT：这是所有GC的总耗时</code></pre><p>其他 相关命令</p><pre class=" language-html"><code class="language-html">jstat -gccapacity PID：堆内存分析jstat -gcnew PID：年轻代GC分析，这里的TT和MTT可以看到对象在年轻代存活的年龄和存活的最大年龄jstat -gcnewcapacity PID：年轻代内存分析jstat -gcold PID：老年代GC分析jstat -gcoldcapacity PID：老年代内存分析jstat -gcmetacapacity PID：元数据区内存分析</code></pre><p>核心关注参数</p><p>新生代对象增长的速率，Young GC的触发频率，Young GC的耗时，每次Young GC后有多少对象是存活下来的，每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率，Full GC的触发频率，Full GC的耗时。</p><p><code>新生代对象增长的速率</code>：根据 jstat -gc pid 时间，来观察 EU 指标</p><p>1s  =  5M</p><p><img src="http://lion-heart.online/blog/2020-10-08-064231.png" alt="每秒E区使用内存率"></p><p><code>Young GC的触发频率</code>：很容易推算出来</p><p>17</p><p><code>Young GC的耗时</code>：YGC / YGCT</p><p>1ms</p><p><code>每次Young GC后有多少对象是存活下来的</code>：无法直接获取，根据GC触发的频率，观察EU、Suvivor、老年代对象变化</p><p>800kb</p><p><code>每次Young GC过后有多少对象进入了老年代，老年代对象增长的速率</code>：由上得出这两项指标</p><p>0</p><h3 id="jmap-命令：系统运行时的内存区域，到底什么对象占据了那么多内存"><a href="#jmap-命令：系统运行时的内存区域，到底什么对象占据了那么多内存" class="headerlink" title="jmap 命令：系统运行时的内存区域，到底什么对象占据了那么多内存"></a>jmap 命令：系统运行时的内存区域，到底什么对象占据了那么多内存</h3><p><strong>jmap -heap PID</strong></p><p><strong>jmap -histo PID</strong></p><p><strong>jmap -dump:live,format=b,file=dump.hprof PID</strong></p><h3 id="jhat-命令："><a href="#jhat-命令：" class="headerlink" title="jhat 命令："></a>jhat 命令：</h3><h2 id="频繁-Full-GC-原因？"><a href="#频繁-Full-GC-原因？" class="headerlink" title="频繁 Full GC 原因？"></a>频繁 Full GC 原因？</h2><ol><li>内存分配不合理，导致对象频繁进入老年代，进而引发频繁的Full GC<ul><li>通过 jstat -gc 分析各区内存使用情况</li></ul></li><li>存在内存泄漏等问题，就是内存里驻留了大量的对象塞满了老年代，导致稍微有一些对象进入老年代就会引发Full GC<ul><li>jmap -dump。。。。。配置 MAT 分析工具</li></ul></li><li>永久代里的类太多，触发了Full GC<ul><li>jstat -gc 查看永久代使用率</li></ul></li></ol><h2 id="CPU-负载高原因？"><a href="#CPU-负载高原因？" class="headerlink" title="CPU 负载高原因？"></a>CPU 负载高原因？</h2><ol><li>大量线程或任务并发执行，占用大量 cpu 资源</li><li>异常的Full GC 导致</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目完整的生命周期</title>
      <link href="/2020/10/04/%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%95%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/10/04/%E9%A1%B9%E7%9B%AE%E5%AE%8C%E6%95%B4%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><h2 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h2><p>可行性分析、立项</p><h2 id="需求评审"><a href="#需求评审" class="headerlink" title="需求评审"></a>需求评审</h2><h2 id="需求确认"><a href="#需求确认" class="headerlink" title="需求确认"></a>需求确认</h2><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><ul><li>微服务设计原则<ul><li>高内聚</li><li>低耦合</li><li>弹性设计：容错、降级、熔断、隔离</li><li>自动化：持续集成、持续交付</li><li>高度自治</li></ul></li><li>整体设计</li><li>UML</li><li>分层</li><li>服务拆分</li><li>AFK<ul><li>X：复制备份</li><li>Y：业务拆分</li><li>Z：数据分区</li></ul></li></ul><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h2 id="工程设计"><a href="#工程设计" class="headerlink" title="工程设计"></a>工程设计</h2><h2 id="DB设计"><a href="#DB设计" class="headerlink" title="DB设计"></a>DB设计</h2><h2 id="开发规范、开发编码"><a href="#开发规范、开发编码" class="headerlink" title="开发规范、开发编码"></a>开发规范、开发编码</h2><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><h2 id="三方技术"><a href="#三方技术" class="headerlink" title="三方技术"></a>三方技术</h2><h2 id="业务、流量、并发预估"><a href="#业务、流量、并发预估" class="headerlink" title="业务、流量、并发预估"></a>业务、流量、并发预估</h2><p>机器配置</p><p>qps</p><p>tps</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列总结和面试</title>
      <link href="/2020/09/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2020/09/26/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><h3 id="一、核心模型剖析-消息收发模型"><a href="#一、核心模型剖析-消息收发模型" class="headerlink" title="一、核心模型剖析 - 消息收发模型"></a>一、核心模型剖析 - 消息收发模型</h3><p><img src="http://lion-heart.online/blog/2020-09-28-083457.png" alt="核心模型-收发模型"></p><h4 id="1-生产者：同步发送模式、异步发送模式、批量发送"><a href="#1-生产者：同步发送模式、异步发送模式、批量发送" class="headerlink" title="1.生产者：同步发送模式、异步发送模式、批量发送"></a>1.生产者：同步发送模式、异步发送模式、批量发送</h4><h5 id="producer-通过-namespace-获取到当前-Topic-分配的所有分片-分区信息-所有-server-实例的ip"><a href="#producer-通过-namespace-获取到当前-Topic-分配的所有分片-分区信息-所有-server-实例的ip" class="headerlink" title="producer 通过 namespace 获取到当前 Topic 分配的所有分片\分区信息(所有 server 实例的ip)"></a>producer 通过 namespace 获取到当前 Topic 分配的所有分片\分区信息(所有 server 实例的ip)</h5><h5 id="producer-生产负载策略：根据不同策略选择-broker-发送，一条消息只会发送到一个-broker"><a href="#producer-生产负载策略：根据不同策略选择-broker-发送，一条消息只会发送到一个-broker" class="headerlink" title="producer 生产负载策略：根据不同策略选择 broker 发送，一条消息只会发送到一个 broker"></a>producer 生产负载策略：根据不同策略选择 broker 发送，一条消息只会发送到一个 broker</h5><ol><li>轮询(默认策略)</li><li>权重</li><li>就近发送<ol><li>优点：提高收发效率，避免网络丢包</li><li>缺点：生产不均，导致消费积压</li></ol></li></ol><h5 id="producer-ack-方式"><a href="#producer-ack-方式" class="headerlink" title="producer ack 方式"></a>producer ack 方式</h5><ol><li>刷盘后应答</li><li>接收到数据应答</li><li>不应答</li><li>写入后应答</li></ol><h5 id="producer-发送模型"><a href="#producer-发送模型" class="headerlink" title="producer 发送模型"></a>producer 发送模型</h5><ol><li>同步发送模型：消息发送中客户端线程进入阻塞状态，等待服务端返回结果。保证消息投递一定到达</li><li>异步发送模型：消息发送过程客户端无需阻塞，直接返回，后续结果会回调监听器逻辑</li><li>单向发送模型：只发送消息，不等待服务响应。优点是效率高，缺点是可靠性无法保证</li></ol><h4 id="2-消费者："><a href="#2-消费者：" class="headerlink" title="2.消费者："></a>2.消费者：</h4><h5 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h5><ol><li><p>集群：消息状态由 broker 维护</p><h5 id="消费模式：都是消费者机器主动发送请求到Broker机器去拉取一批消息下来"><a href="#消费模式：都是消费者机器主动发送请求到Broker机器去拉取一批消息下来" class="headerlink" title="消费模式：都是消费者机器主动发送请求到Broker机器去拉取一批消息下来"></a>消费模式：都是消费者机器主动发送请求到Broker机器去拉取一批消息下来</h5><ol><li>push：本质底层也是基于消费者主动拉取的模式来实现的，只不过他的名字叫做<code>Push</code>而已，意思是Broker会尽可能实时的把新消息交给消费者机器来进行处理，他的消息时效性会更好。另外Push模式下有一个请求挂起和长轮询的机制，当你的请求发送到Broker，结果他发现没有新的消息给你处理的时候，就会让请求线程挂起，默认是挂起15秒，然后这个期间他会有后台线程每隔一会儿就去检查一下是否有的新的消息给你，如果在这个挂起过程中，如果有新的消息到达了会主动唤醒挂起的线程，然后把消息返回给你，主动权在客户端，让客户端按需进行消费</li><li>pull：主动拉取</li></ol></li><li><p>广播：消费失败不会重投，消费状态由 consumer 自己维护 </p></li></ol><h5 id="Consumer-和-ConsumerGroup-区别"><a href="#Consumer-和-ConsumerGroup-区别" class="headerlink" title="Consumer 和 ConsumerGroup 区别"></a>Consumer 和 ConsumerGroup 区别</h5><ol><li><p>Consumer：连接一个或多个 broker，减少 mq 连接数，降低服务端压力。同时也做到了负载均衡</p></li><li><p>ConsumerGroup：一个 Group 内包含至少一个 Consumer 。不同 ConsumerGroup 独立使用 Topic 内容。ConsumerGroup 内，<strong>一个消费组内的多台机器是分别负责一部分MessageQueue的消费的，那么既然如此，每台机器都必须去连接到对应的Broker，尝试消费里面的MessageQueue对应的消息了</strong></p><p><img src="http://lion-heart.online/blog/2020-09-28-081628.png" alt="mq基本概念"></p></li></ol><h4 id="broker-将消息读取出来返回给-consumer-流程"><a href="#broker-将消息读取出来返回给-consumer-流程" class="headerlink" title="broker 将消息读取出来返回给 consumer 流程"></a>broker 将消息读取出来返回给 consumer 流程</h4><p>其实这里要涉及到两个概念，分别是<code>ConsumeQueue</code>和<code>CommitLog</code></p><p>假设一个消费者机器发送了拉取请求到Broker了，他说我这次要拉取MessageQueue0中的消息，然后我之前都没拉取过消息，所以就从这个MessageQueue0中的第一条消息开始拉取好了</p><p><img src="http://lion-heart.online/blog/2020-10-01-084844.png" alt="broker 找到 queue 对应的 consumerQueue"></p><p><img src="http://lion-heart.online/blog/2020-10-01-085102.png" alt="根据offset读取消息数据返回consumer"></p><p><img src="http://lion-heart.online/blog/2020-10-01-091330.png" alt="消费性能的核心"></p><p><strong>当你拉取消息的时候，可以轻松从os cache里读取少量的ConsumeQueue文件里的offset，这个性能是极高的，</strong></p><p><strong>但是当你去CommitLog文件里读取完整消息数据的时候，会有两种可能。</strong></p><p><strong>第一种可能，如果你读取的是那种刚刚写入CommitLog的数据，那么大概率他们还停留在os cache中，此时你可以顺利的直接从os cache里读取CommitLog中的数据，这个就是内存读取，性能是很高的。</strong></p><p><strong>第二种可能，你也许读取的是比较早之前写入CommitLog的数据，那些数据早就被刷入磁盘了，已经不在os cache里了，那么此时你就只能从磁盘上的文件里读取了，这个性能是比较差一些的。</strong></p><p><strong>所以其实消费消息的时候，本质就是根据你要消费的MessageQueue以及开始消费的位置，去找到对应的ConsumeQueue读取里面对应位置的消息在CommitLog中的物理offset偏移量，然后到CommitLog中根据offset读取消息数据，返回给消费者机器</strong></p><p>group -&gt; Topic -&gt; MessageQueue consumerQueue</p><h4 id="ACK-机制"><a href="#ACK-机制" class="headerlink" title="ACK 机制"></a>ACK 机制</h4><ol><li>自动 ack</li><li>手动 ack</li></ol><p><img src="http://lion-heart.online/blog/2020-10-01-085657.png" alt="确认消费位置"></p><h4 id="总结：producer-连接所有-broker，根据策略选择-broker-进行-send-消息。consumer-通过策略选择部分-broker-进行连接，接收消息"><a href="#总结：producer-连接所有-broker，根据策略选择-broker-进行-send-消息。consumer-通过策略选择部分-broker-进行连接，接收消息" class="headerlink" title="总结：producer 连接所有 broker，根据策略选择 broker 进行 send 消息。consumer 通过策略选择部分 broker 进行连接，接收消息"></a>总结：producer 连接所有 broker，根据策略选择 broker 进行 send 消息。consumer 通过策略选择部分 broker 进行连接，接收消息</h4><h4 id="3-消息类型"><a href="#3-消息类型" class="headerlink" title="3.消息类型"></a>3.消息类型</h4><h5 id="普通消息：生产者发送一条消息后，集群模式下，具有订阅关系的所有消费者的-某一实例-能够消费该消息。订阅发布模式下，具有订阅关系的所有消费者的所有实例都能够消费该消息。"><a href="#普通消息：生产者发送一条消息后，集群模式下，具有订阅关系的所有消费者的-某一实例-能够消费该消息。订阅发布模式下，具有订阅关系的所有消费者的所有实例都能够消费该消息。" class="headerlink" title="普通消息：生产者发送一条消息后，集群模式下，具有订阅关系的所有消费者的 某一实例 能够消费该消息。订阅发布模式下，具有订阅关系的所有消费者的所有实例都能够消费该消息。"></a>普通消息：生产者发送一条消息后，集群模式下，具有订阅关系的所有消费者的 <strong>某一实例</strong> 能够消费该消息。订阅发布模式下，具有订阅关系的所有消费者的所有实例都能够消费该消息。</h5><h5 id="普通顺序消息：按照业务-Id-进行顺序保证，先获取-hash-值，在对-Topic-下所有-broker-数量取模，获得-broker-后，再对-queue-取模"><a href="#普通顺序消息：按照业务-Id-进行顺序保证，先获取-hash-值，在对-Topic-下所有-broker-数量取模，获得-broker-后，再对-queue-取模" class="headerlink" title="普通顺序消息：按照业务 Id 进行顺序保证，先获取 hash 值，在对 Topic 下所有 broker 数量取模，获得 broker 后，再对 queue 取模"></a>普通顺序消息：按照业务 Id 进行顺序保证，先获取 <code>hash</code> 值，在对 <code>Topic</code> 下所有 <code>broker</code> 数量取模，获得 <code>broker</code> 后，再对 <code>queue</code> 取模</h5><p><code>businessId.hashCode() % broker.size() % queue.size()</code></p><h5 id="严格顺序消息"><a href="#严格顺序消息" class="headerlink" title="严格顺序消息"></a>严格顺序消息</h5><ol><li>生产者：保证只有一个服务实例可以接收消息</li><li>消费者：多实例接收消息，只有一个实例可以接收到消息</li></ol><h5 id="事物消息"><a href="#事物消息" class="headerlink" title="事物消息"></a>事物消息</h5><h5 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h5><p>大数据领域，数据清洗，数据挖掘</p><h4 id="4-消息队列架构"><a href="#4-消息队列架构" class="headerlink" title="4.消息队列架构"></a>4.消息队列架构</h4><p><img src="http://lion-heart.online/blog/2020-10-02-051208.png" alt="消息队列整体架构"></p><h3 id="二、核心模型剖析-消息处理流程"><a href="#二、核心模型剖析-消息处理流程" class="headerlink" title="二、核心模型剖析 - 消息处理流程"></a>二、核心模型剖析 - 消息处理流程</h3><p><img src="http://lion-heart.online/blog/2020-09-28-084929.png" alt="消息处理模型"></p><h4 id="2-1-存储方式"><a href="#2-1-存储方式" class="headerlink" title="2.1 存储方式"></a>2.1 存储方式</h4><p>Topic 逻辑存储结构</p><p>ConsumerQueue 物理存储结构，基于数组实现FIFO，理论上无限大</p><h4 id="2-2-存储文件与内存映射"><a href="#2-2-存储文件与内存映射" class="headerlink" title="2.2 存储文件与内存映射"></a>2.2 存储文件与内存映射</h4><h4 id="2-3-刷盘机制"><a href="#2-3-刷盘机制" class="headerlink" title="2.3 刷盘机制"></a>2.3 刷盘机制</h4><ul><li>同步刷</li><li>异步刷</li></ul><h4 id="2-4-索引"><a href="#2-4-索引" class="headerlink" title="2.4 索引"></a>2.4 索引</h4><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p><img src="http://lion-heart.online/blog/2020-09-28-082100.png" alt="分区概念"></p><h3 id="NameServer：是一个非常简单的Topic路由注册中心，支持Broker的动态注册与发现"><a href="#NameServer：是一个非常简单的Topic路由注册中心，支持Broker的动态注册与发现" class="headerlink" title="NameServer：是一个非常简单的Topic路由注册中心，支持Broker的动态注册与发现"></a>NameServer：是一个非常简单的Topic路由注册中心，支持Broker的动态注册与发现</h3><p><img src="http://lion-heart.online/blog/2020-09-28-082450.png" alt="namespace"></p><h4 id="nameserver特点"><a href="#nameserver特点" class="headerlink" title="nameserver特点"></a>nameserver特点</h4><ol><li>无状态：通过 broker 注册，保存完整的路由信息</li><li>高可用：集群方式部署，每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息</li><li>高性能：实例之间互不通信，不同NameServer之间数据不同步</li><li>数据不一致</li><li>Broker管理：NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据</li><li>路由管理：每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费 </li><li>心跳检测机制：检查Broker是否还存活，剔除不存活的 broker</li></ol><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><ol><li><p>Broker启动会跟每个NameServer都建立一个TCP长连接进行信息注册（包含集群里有哪些Broker，集群里有哪些Topic，每个Topic都存储在哪些Broker上）</p></li><li><p>每隔10s去检查一下各个Broker的最近一次心跳时间，如果某个Broker超过120s都没发送心跳了，那么就认为这个Broker已经挂掉了</p></li><li><p>每次收到一个Broker的心跳，就可以更新一下他的最近一次心跳的时间</p></li></ol><h4 id="消息路由-heartbeat收集、路由发现"><a href="#消息路由-heartbeat收集、路由发现" class="headerlink" title="消息路由 - heartbeat收集、路由发现"></a>消息路由 - heartbeat收集、路由发现</h4><p><img src="http://lion-heart.online/blog/2020-10-03-061914.png" alt="broker 注册信息以及消费、生产获取路由信息"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="region：不同机房、区域的概念"><a href="#region：不同机房、区域的概念" class="headerlink" title="region：不同机房、区域的概念"></a>region：不同机房、区域的概念</h3><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><img src="http://lion-heart.online/blog/2020-09-28-081708.png" alt="逻辑结构"></p><h2 id="服务通信结构"><a href="#服务通信结构" class="headerlink" title="服务通信结构"></a>服务通信结构</h2><p>长短连接：基于传输层协议 TCP 实现，每次是否都需要三次握手和四次挥手通信</p><p>长短轮询：基于应用层协议 HTTP 实现，由服务端代码实现</p><p><img src="http://lion-heart.online/blog/2020-09-28-081734.png" alt="调用结构"></p><h2 id="集群模式消息存储架构模型"><a href="#集群模式消息存储架构模型" class="headerlink" title="集群模式消息存储架构模型"></a>集群模式消息存储架构模型</h2><p><img src="http://lion-heart.online/blog/2020-10-03-073019.png" alt="集群模型"></p><p>单master</p><p>多master</p><p>单master - slave</p><p>多master - slave</p><p>同步备份</p><p>异步复制</p><p>version ： 4.5 以后</p><p><img src="http://lion-heart.online/blog/2020-10-03-073959.png" alt="高可用集群"></p><p>基于 CommitLog 实现 - 选举 + 数据复制</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>限流</li><li>异步</li><li>系统解耦</li><li>大数据分析数据通道</li><li>IOT 智能终端通信</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>​    高可用集群（每个Broker都是一主一备的热备模式，备用Broker与主用Broker采用异步方式同步数据。主用Broker宕机后，消费端会自动切换到备用Broker，备用Broker上拥有主用Broker上绝大部分消息。可能存在少量新消息没来得及同步到备用Broker上，这部分消息暂时无法消费，但可以在主用Broker恢复后继续消费，不会丢失），每个主题下的队列分布在多个Broker上。当Broker宕机时，分布在该Broker上的队列将处于不可写状态。</p><pre class=" language-java"><code class="language-java">在生产者端，客户端会自动将发送失败的消息重发给同主题处于可读写状态Broker的队列，切换过程中有可能短时出现发送时延升高，极小概率会出现发送失败的情况，切换完成后上述问题都会自动恢复在消费者端，Broker宕机后，仍然可以在备用Broker上继续消费，切换过程中有可能短时间出现消费性能下降，消息被重复消费，消息乱序，切换完成后上述问题都会自动恢复</code></pre><h3 id="事物消息机制"><a href="#事物消息机制" class="headerlink" title="事物消息机制"></a>事物消息机制</h3><h4 id="分布式事务提交算法"><a href="#分布式事务提交算法" class="headerlink" title="分布式事务提交算法"></a>分布式事务提交算法</h4><ol><li>2pc(二阶段提交)：实现简单，需要双方支持XA协议。典型实现：数据库、RocketMq</li><li>tcc(三阶段提交 try -&gt; confirm -&gt; cancel)：相对复杂，侵入性强</li></ol><h4 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h4><p>发送half消息到MQ，试探MQ是否正常。后续二次发送 commit or rollback 进行确认</p><p>half 消息未成功，事物操作同步失败</p><p>half 消息发送成功，事物正常执行，后续 二阶段提交，mq 提供了补偿机制</p><p><img src="http://lion-heart.online/blog/2020-10-02-022427.png" alt="事物消息正向流程"></p><p><img src="http://lion-heart.online/blog/2020-10-02-022943.png" alt="事物消息 异步回调"></p><p><img src="http://lion-heart.online/blog/2020-10-02-023446.png" alt="补偿机制"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>本质还是基于 CommitLog 和 ConsumeQueue 来解决消息的读写</p><p>把half消息写入 CommitLog，同时 offset 同步到自己内部的Topic -&gt;<code>RMQ_SYS_TRANS_HALF_TOPIC</code>对应的一个ConsumeQueue里，之后返回响应。后续的 commit 、rollback 写入内部另一个代表 half 状态的 ConsumerQueue(OP_TOPIC)里，如果当前消息是 commit，先更新 OP_TOPIC 对应的 ConsumerQueue，再把在RMQ_SYS_TRANS_HALF_TOPIC 对应的 ConsumerQueue 中的 half offset 写入真正的ConsumerQueue</p><p><img src="http://lion-heart.online/blog/2020-10-02-030055.png" alt="事物消息原理"></p><h4 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h4><p>同步消息 + 重试机制</p><p>结论：可以落地，但是存在一些问题。比如：数据一致性问题、响应时延问题等</p><h3 id="全链路消息零丢失方案总结（保证了消息的高可靠，同时也牺牲了-MQ-的高性能和高吞吐量）"><a href="#全链路消息零丢失方案总结（保证了消息的高可靠，同时也牺牲了-MQ-的高性能和高吞吐量）" class="headerlink" title="全链路消息零丢失方案总结（保证了消息的高可靠，同时也牺牲了 MQ 的高性能和高吞吐量）"></a>全链路消息零丢失方案总结（保证了消息的高可靠，同时也牺牲了 MQ 的高性能和高吞吐量）</h3><h4 id="producer-消息零丢失、高可靠方案"><a href="#producer-消息零丢失、高可靠方案" class="headerlink" title="producer 消息零丢失、高可靠方案"></a>producer 消息零丢失、高可靠方案</h4><ol><li>同步 ack + 重试机制</li><li>事物消息机制</li></ol><p>两者都有保证消息发送零丢失的效果，但是经过分析，事务消息方案整体会更好一些</p><p><img src="http://lion-heart.online/blog/2020-10-02-043058.png" alt="发送消息保证高可靠"></p><p>从单次网络通信 send(Message) 到两次网络通信 half(Message),commit()\rollback()</p><h4 id="broker-消息高可靠、零丢失"><a href="#broker-消息高可靠、零丢失" class="headerlink" title="broker 消息高可靠、零丢失"></a>broker 消息高可靠、零丢失</h4><p>开启同步刷盘策略 + 主从架构同步机制，只要让<code>Master Broker</code>收到消息之后同步写入磁盘，同时同步复制给其他<code>Slave Broker</code>，然后再返回响应给生产者说写入成功，此时就可以保证<code>MQ</code>自己不会弄丢消息</p><p><img src="http://lion-heart.online/blog/2020-10-02-043202.png" alt="broker保证消息高可靠"></p><p>内存操作：纳秒级别</p><p>磁盘操作：毫秒级别</p><p>单从介质级别来看，就相差很多。同时还会多副本同步，同样浪费性能。</p><h4 id="consumer-消息零丢失、高可靠"><a href="#consumer-消息零丢失、高可靠" class="headerlink" title="consumer 消息零丢失、高可靠"></a>consumer 消息零丢失、高可靠</h4><p>保证 consumer 消费完毕后，提交 ack 给 broker</p><p><img src="http://lion-heart.online/blog/2020-10-02-043809.png" alt="consumer 消息高可靠"></p><p>consumer 收到信息直接返回 ack，继续从 broker 获取消息进行消费</p><h3 id="重试原理"><a href="#重试原理" class="headerlink" title="重试原理"></a>重试原理</h3><p>producer：故障转移机制，支持同步和异步消息的重试</p><p>consumerGroup 内维护一个 <code>retry 队列</code>，默认 16 次。连续 16次还是无法处理的消息，放入另一个队列 <code>DLQ队列</code></p><p><img src="http://lion-heart.online/blog/2020-10-02-051923.png" alt="重试队列、死信队列"></p><h3 id="重复消息"><a href="#重复消息" class="headerlink" title="重复消息"></a>重复消息</h3><p>​    和大多数现代消息队列一样，JMQ提供 至少一次（At-least-once） 的消息投递保证。通俗的说就是保证消息不丢，但不保证不重复。正常情况下，消费者不会收到重复的消息，但是，在Broker宕机、网络丢包等等各种异常情况时，消费者有可能会收到重复消息，发生重复消费的情况。所以，消费业务逻辑必须具备幂等性</p><h5 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h5><p>幂等机制：来避免对同一个请求或者同一条消息进行重复处理的机制</p><p>业务判断：mq 查询，可靠，性能不高</p><p>状态判断：redis，不可靠</p><h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>producer ：根据具体算法指定 MessageQueue 进行定向投递</p><ol><li>hash</li><li>random</li><li>machineRoom</li></ol><p>consumer : 根据监听实现并行消费或顺序消费</p><ol><li>concurrently：一个queue开启多个线程</li><li>orderly：一个queue开启一个线程</li></ol><p><img src="http://lion-heart.online/blog/2020-10-02-052715.png" alt="消息乱序原因"></p><p>保证相同业务类型的消息进入同一个 messageQueue，同时针对有序消息无可进入重试队列</p><p><img src="http://lion-heart.online/blog/2020-10-02-053301.png" alt="避免重试引起乱序"></p><p>总结</p><ol><li>消息丢失：全链路消息零丢失架构</li><li>消息重复：幂等机制</li><li>处理失败：重试原理</li><li>消息乱序：有序消息 -&gt; 普通有序 -&gt; 严格有序</li><li>消息积压：批量、并行、加队列、加分片、修改消费逻辑，重新推送到新队列</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><ol><li>启动环节<ul><li>加载配置</li><li>验证配置</li></ul></li><li>注册环节</li><li>拉取消息环节<ul><li>PullRequest<ul><li>MessageQueue：元数据信息</li><li>ProcessQueue：消息体 </li></ul></li><li>PutMessage：初始化 <code>ProcessQueue</code><ul><li>msgTreeMap：消费位置 + 消息</li><li>queueOffsetMax：当前 consumer 最大消费位置</li><li>msgSize ： 消息大小</li><li></li></ul></li></ul></li></ol><h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="整体架构：高可用、高并发、海量消息、可伸缩"><a href="#整体架构：高可用、高并发、海量消息、可伸缩" class="headerlink" title="整体架构：高可用、高并发、海量消息、可伸缩"></a>整体架构：高可用、高并发、海量消息、可伸缩</h3><h3 id="核心关注点：CPU、IO、磁盘、内存"><a href="#核心关注点：CPU、IO、磁盘、内存" class="headerlink" title="核心关注点：CPU、IO、磁盘、内存"></a>核心关注点：CPU、IO、磁盘、内存</h3><h3 id="核心链路流程长、节点多、业务复杂"><a href="#核心链路流程长、节点多、业务复杂" class="headerlink" title="核心链路流程长、节点多、业务复杂"></a>核心链路流程长、节点多、业务复杂</h3><h3 id="因此我们不能仅仅依赖于最简单粗暴的堆机器的策略，而是要仔细的分析业务的核心请求链路，然后精心设计架构，优雅的抗下越来越高的并发量。"><a href="#因此我们不能仅仅依赖于最简单粗暴的堆机器的策略，而是要仔细的分析业务的核心请求链路，然后精心设计架构，优雅的抗下越来越高的并发量。" class="headerlink" title="因此我们不能仅仅依赖于最简单粗暴的堆机器的策略，而是要仔细的分析业务的核心请求链路，然后精心设计架构，优雅的抗下越来越高的并发量。"></a>因此我们不能仅仅依赖于最简单粗暴的堆机器的策略，而是要仔细的分析业务的核心请求链路，然后精心设计架构，优雅的抗下越来越高的并发量。</h3><p>（1）了解数据分片机制吗？如何把一个逻辑上的数据集合概念（比如一个Topic）给在物理上拆分为多个数据分片的？然后拆分后的多个数据分片又是如何在物理的多台机器上分布式存储的？</p><p> 一个数据集合拆分成多个小的数据结合，独立存储，合并后是一个完整的数据集。</p><p> 每一个 broker 实例都存储一个 CommitLog，全量的数据信息。</p><p> 不同的数据集合通过 Topic/MessageQueue/ConsumerQueue 来表示各自数据集合的数据信息，存储的是CommitLog的文件地址 offset，每个文件尽可能的小，方便后续 consumer 快速的读取数据</p><p>（2）为什么一定要让MQ实现数据分片的机制？如果不实现数据分片机制，让你来设计MQ中一个数据集合的分布式存储，你觉得好设计吗？</p><p> 数据分片的主要目的是突破单点的资源（网络带宽，CPU，内存或文件存储）限制从而实现水平扩展</p><p>（3）同步刷盘和异步刷盘两种策略，分别适用于什么不同的场景呢？<br>异步刷盘可以提供超高的写入吞吐量，但是有丢失数据的风险，这个适用于什么业务场景？在你所知道的业务场景，或者工作接触过的业务场景中，有哪些场景需要超高的写入吞吐量，但是可以适度接受数据丢失？</p><p>同步刷盘会大幅度降低写入吞吐量，但是可以让你的数据不丢失，你接触哪些场景，是严格要求数据务必不能丢失任何一条，但是吞吐量并没有那么高的呢？</p><p>（6）Kafka、RabbitMQ他们的broker收到消息之后是如何写入磁盘的？采用的是同步刷盘还是异步刷盘的策略？为什么？<br>（7）每次写入都必须有超过半数的Follower Broker都写入消息才可以算做一次写入成功，那么大家思考一个问题，这样做是不是会对Leader Broker的写入性能产生影响？是不是会降低TPS？是不是必须要在所有的场景都这么做？为什么呢？<br>（8）一般我们获取到一批消息之后，什么时候才可以认为是处理完这批消息了？是刚拿到这批消息就算处理完吗？还是说要对这批消息执行完一大堆的数据库之类的操作，才算是处理完了？<br>（9）如果获取到了一批消息，还没处理完呢，结果机器就宕机了，此时会怎么样？这些消息会丢失，再也无法处理了吗？如果获取到了一批消息，已经处理完了，还买来得及提交消费进度，此时机器宕机了，会怎么样呢？<br>（10）消费者机器到底是跟少数几台Broker建立连接，还是跟所有Broker都建立连接？这是不少朋友之前在评论区提出的问题，但是<br>我想这里大家肯定都有自己的答案了。<br>（11）RocketMQ是支持主从架构下的读写分离的，而且什么时候找Slave Broker读取大家也都了解的很清楚了，那么大家思考一下，<br>Kafka、RabbitMQ他们支持主从架构下的读写分离吗？支持Slave Broker的读取吗？为什么呢？<br>（12）如果支持读写分离的话，有没有一种可能，就是出现主从数据不一致的问题？比如有的数据刚刚到Master Broker和部分Slave Broker，但是你刚好是从那个没有写入数据的Slave Broker去读取了？<br>（13）消费吞吐量似乎是跟你的处理速度有很大关系，如果你消费到一批数据，处理太慢了，会导致你严重跟不上数据写入的速度，这会导致你后续几乎每次拉取数据都会从磁盘上读取，而不是os cache里读取</p><p>如何集群化部署抗高并发的？ </p><p>海量消息是如何分布式存储的？ </p><p>如何实现主从多备份的高可用架构的？ </p><p>如何实现集群路由让别人找到对应的机器发送消息和接收消息的？</p><p>为什么不用 zookeeper 来实现消息路由？</p><p>1.NameServer 用来保存活跃的 broker 列表，包括 Master 和 Slave 。 </p><p>2.NameServer 用来保存所有 topic 和该 topic 所有队列的列表。</p><p>3.NameServer 用来保存所有 broker 的 Filter 列表。</p><p>A：对于RocketMQ 来说，topic 的数据在每个 Master 上是对等的，没有哪个 Master 上有 topic 上的全部数据，所以对于zookeeper的Master 选举功能在Rocket中使用不到。 Broker与slave配对是通过指定相同的brokerName参数来配对，master的brokerId必须为0，slave的brokerId必须大于0，此外一个master下可以挂多个slave，同一个master下的多个slave通过指定不同的brokerId来区分</p><p>NameServer集群整体都故障了，失去了这个NameServer集群之后：</p><p>RocketMQ还能正常运行吗？</p><p>生产者还能发送消息到Broker吗？</p><p>消费者还能从Broker拉取消息吗？</p><p>那么在Master崩溃一直到新的Master被选举出来的这个过程中，你觉得对于使用MQ的系统而言，会处于一个什么样的状态呢？</p><p>有没有主从数据不一致的问题？</p><p>不一致有没有什么问题？</p><p>有办法保证主从数据强制一致吗？</p><p>这样做又会有什么缺点呢？</p><p>Broker跟NameServer之间的通信是基于什么协议来进行的？</p><p>tcp 长连接</p><p>Topic是什么意思？</p><p>Topic其实就是一个数据集合的意思，不同类型的数据你得放不同的Topic里去。</p><p>你们的MQ在生产环境的部署架构是怎么做的？</p><p>路由中心、MQ集群、生产者和消费者分别是怎么部署的？为什么要那样部署？</p><p>那样部署可以实现高并发、海量消息、高可用和线性可伸缩吗？</p><p>他们对MQ集群做过压测吗？</p><p>使用什么样的机器配置做的压测？</p><p>使用多大规模的集群做的压测？如何压测的？</p><p>在压测的过程中发现单Broker的TPS最高有多少？</p><p>在压测过程中，cpu负载、内存使用率、jvm gc频率、磁盘io负载、网卡流量负载，这些值都是如何变化的？</p><p>在压测过后，是如何规划生产集群的？</p><p>目前公司线上MQ集群的TPS多高？机器资源的负载情况如何？能否抗住？</p><p>你们的系统中是否存在核心链路环节过多导致性能较差的问题？如果有的话，是否可以引入MQ进行适当异步化提升链路性能？</p><p>你们的系统是否存在核心链路耦合了第三方系统，进而导致链路性能不稳定的问题？如果有，是否可以引入MQ进行第三方系统的解耦，避免核心链路的性能受到影响？</p><p>你们的系统是否存在有其他团队直接耦合访问你们数据库的情况，进而导致你们的数据库性能不稳定？如果有的话，是否可以引入MQ来推送你们的核心数据出去，跟其他团队进行解耦？</p><p>对生产者往Broker集群发送消息的底层原理做一个研究 看看Broker对于接收到的消息，到底是如何存储到磁盘上去的？</p><p>基于DLedger技术部署的Broker高可用集群，到底如何进行数据同步的？</p><p>消费者到底是基于什么策略选择Master或Slave拉取数据的？</p><p>消费者是如何从Broker拉取消息回来，进行处理以及ACK的？如果消费者故障了会如何处理？</p><p>异步刷盘可以提供超高的写入吞吐量，但是有丢失数据的风险，这个适用于什么业务场景？在你所知道的业务场景，或者工作接触过的业务场景中，有哪些场景需要超高的写入吞吐量，但是可以适度接受数据丢失？</p><p>同步刷盘会大幅度降低写入吞吐量，但是可以让你的数据不丢失，你接触哪些场景，是严格要求数据务必不能丢失任何一条，但是吞吐量并没有那么高的呢？</p><p>丢消息？</p><p>​    网络传输丢包<br>​    Broker宕机<br>​    生产者实例宕机<br>​    消费者实例宕机<br>​    消费处理失败</p><p>​    同时满足下面所有条件的情况下会丢消息：<br>​            主用Broker磁盘损坏，无法读取数据<br>​            数据没有来得及将消息复制到备用Broker<br>​            消费者没有来得及消费这些消息</p><p>如果遇到过，你们是怎么解决的？</p><p>​    producer 网络丢包、发送失败，重试机制</p><p>​    broker问题，考虑使用同步刷盘，异步复制</p><p>​    consumer 消费问题，修改业务逻辑</p><h1 id="RocketMQ-面试FAQ"><a href="#RocketMQ-面试FAQ" class="headerlink" title="RocketMQ 面试FAQ"></a>RocketMQ 面试FAQ</h1><h2 id="说说你们公司线上生产环境用的是什么消息中间件"><a href="#说说你们公司线上生产环境用的是什么消息中间件" class="headerlink" title="说说你们公司线上生产环境用的是什么消息中间件?"></a>说说你们公司线上生产环境用的是什么消息中间件?</h2><h2 id="为什么要使用MQ？"><a href="#为什么要使用MQ？" class="headerlink" title="为什么要使用MQ？"></a>为什么要使用MQ？</h2><p>因为项目比较大，做了分布式系统，所有远程服务调用请求都是<strong>同步执行</strong>经常出问题，所以引入了mq</p><p><strong>解耦</strong></p><p>系统耦合度降低，没有强依赖关系</p><p><strong>异步</strong></p><p>不需要同步执行的远程调用可以有效提高响应时间</p><p><strong>削峰</strong></p><p>请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮</p><h3 id="多个mq如何选型？"><a href="#多个mq如何选型？" class="headerlink" title="多个mq如何选型？"></a>多个mq如何选型？</h3><p><strong>RabbitMQ</strong></p><p>erlang开发，延迟比较低</p><p><strong>RocketMQ</strong></p><p>java开发，面向互联网集群化功能丰富</p><p><strong>kafka</strong></p><p>Scala开发，面向日志功能丰富</p><p><strong>ActiveMQ</strong></p><p>java开发，简单，稳定</p><p>小项目：ActiveMQ</p><p>大项目：RocketMQ或kafka、RabbitMq</p><h2 id="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"><a href="#RocketMQ由哪些角色组成，每个角色作用和特点是什么？" class="headerlink" title="RocketMQ由哪些角色组成，每个角色作用和特点是什么？"></a>RocketMQ由哪些角色组成，每个角色作用和特点是什么？</h2><p>nameserver 无状态 动态列表</p><p>producer</p><p>broker</p><p>consumer</p><h2 id="RocketMQ中的Topic和ActiveMQ有什么区别？"><a href="#RocketMQ中的Topic和ActiveMQ有什么区别？" class="headerlink" title="RocketMQ中的Topic和ActiveMQ有什么区别？"></a>RocketMQ中的Topic和ActiveMQ有什么区别？</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><p>有destination的概念，即消息目的地</p><p>destination分为两类：</p><ul><li>topic<ul><li>广播消息</li></ul></li><li>queue<ul><li>队列消息</li></ul></li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>RocketMQ的Topic是一组Message Queue的集合 ConsumeQueue</p><p>一条消息是广播消息还是队列消息由客户端消费决定</p><h2 id="RocketMQ-Broker中的消息被消费后会立即删除吗？"><a href="#RocketMQ-Broker中的消息被消费后会立即删除吗？" class="headerlink" title="RocketMQ Broker中的消息被消费后会立即删除吗？"></a>RocketMQ Broker中的消息被消费后会立即删除吗？</h2><p>不会，每条消息都会持久化到CommitLog中，每个consumer连接到broker后会维持消费进度信息，当有消息消费后只是当前consumer的消费进度（CommitLog的offset）更新了。</p><h3 id="那么消息会堆积吗？什么时候清理过期消息？"><a href="#那么消息会堆积吗？什么时候清理过期消息？" class="headerlink" title="那么消息会堆积吗？什么时候清理过期消息？"></a>那么消息会堆积吗？什么时候清理过期消息？</h3><p>4.6版本默认48小时后会删除不再使用的CommitLog文件</p><ul><li>检查这个文件最后访问时间</li><li>判断是否大于过期时间</li><li>指定时间删除，默认凌晨4点</li></ul><h2 id="RocketMQ消费模式有几种？"><a href="#RocketMQ消费模式有几种？" class="headerlink" title="RocketMQ消费模式有几种？"></a>RocketMQ消费模式有几种？</h2><p>消费模型由consumer决定，消费维度为Topic</p><h3 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h3><p>一组consumer同时消费一个topic，可以分配消费负载均衡策略分配consumer对应消费topic下的哪些queue</p><p>多个group同时消费一个topic时，每个group都会消费到数据</p><p>一条消息只会被一个group中的consumer消费，</p><h3 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h3><p>消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。即即使这些 Consumer 属于同一个Consumer Group ，消息也会被 Consumer Group 中的每个 Consumer 都消费一次。</p><h2 id="消费消息时使用的是push还是pull？"><a href="#消费消息时使用的是push还是pull？" class="headerlink" title="消费消息时使用的是push还是pull？"></a>消费消息时使用的是push还是pull？</h2><p>在刚开始的时候就要决定使用哪种方式消费</p><p>两种：</p><p><code>DefaultLitePullConsumerImpl</code> 拉</p><p><code>DefaultMQPushConsumerImpl</code>推</p><p>两个实现 <code>DefaultLitePullConsumerImpl</code> <code>DefaultMQPushConsumerImpl</code>都实现了MQConsumerInner接口接口</p><p>名称上看起来是一个推，一个拉，但实际底层实现都是采用的<strong>长轮询机制</strong>，即拉取方式</p><p>broker端属性 longPollingEnable 标记是否开启长轮询。默认开启</p><h3 id="为什么要主动拉取消息而不使用事件监听方式？"><a href="#为什么要主动拉取消息而不使用事件监听方式？" class="headerlink" title="为什么要主动拉取消息而不使用事件监听方式？"></a>为什么要主动拉取消息而不使用事件监听方式？</h3><p>事件驱动方式是建立好长连接，由事件（发送数据）的方式来实时推送。</p><p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p><h4 id="说一说几种常见的消息同步机制？"><a href="#说一说几种常见的消息同步机制？" class="headerlink" title="说一说几种常见的消息同步机制？"></a>说一说几种常见的消息同步机制？</h4><p>push：</p><p>如果broker主动推送消息的话有可能push速度快，消费速度慢的情况，那么就会造成消息在consumer端堆积过多，同时又不能被其他consumer消费的情况</p><p>pull：</p><p>轮训时间间隔，固定值的话会造成资源浪费</p><p>长轮询：</p><p>上连接 短连接（每秒） 长轮询</p><h3 id="broker如何处理拉取请求的？"><a href="#broker如何处理拉取请求的？" class="headerlink" title="broker如何处理拉取请求的？"></a>broker如何处理拉取请求的？</h3><p>consumer首次请求broker</p><ul><li>broker中是否有符合条件的消息</li><li>有<ul><li>响应consumer</li><li>等待下次consumer的请求</li></ul></li><li>没有<ul><li>挂起consumer的请求，即不断开连接，也不返回数据</li><li>挂起时间长短，写死在代码里的吗？长轮询写死，短轮询可以配</li><li>使用consumer的 offset <ul><li>DefaultMessageStore#ReputMessageService#run方法<ul><li>每隔1ms检查commitLog中是否有新消息，有的话写入到pullRequestTable</li><li>当有新消息的时候返回请求</li></ul></li><li>PullRequestHoldService 来Hold连接，每个5s执行一次检查pullRequestTable有没有消息，有的话立即推送</li></ul></li></ul></li></ul><h2 id="RocketMQ如何做负载均衡？"><a href="#RocketMQ如何做负载均衡？" class="headerlink" title="RocketMQ如何做负载均衡？"></a>RocketMQ如何做负载均衡？</h2><p>通过Topic在多broker种分布式存储实现</p><h3 id="producer端"><a href="#producer端" class="headerlink" title="producer端"></a>producer端</h3><p>发送端指定Target message queue发送消息到相应的broker，来达到写入时的负载均衡</p><ul><li>提升写入吞吐量，当多个producer同时向一个broker写入数据的时候，性能会下降</li><li>消息分布在多broker种，为负载消费做准备</li></ul><h4 id="默认策略是轮循选择："><a href="#默认策略是轮循选择：" class="headerlink" title="默认策略是轮循选择："></a><strong>默认策略是轮循选择：</strong></h4><ul><li>producer维护一个index</li><li>每次取节点会自增</li><li>index向所有broker个数取余</li><li>自带容错策略</li></ul><h4 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h4><ul><li>哈希</li><li>机房轮循</li><li>随机</li></ul><h4 id="如何知道mqs的，mqs的数据从哪儿来？"><a href="#如何知道mqs的，mqs的数据从哪儿来？" class="headerlink" title="如何知道mqs的，mqs的数据从哪儿来？"></a>如何知道mqs的，mqs的数据从哪儿来？</h4><p>producer.start()方法</p><p>参考源码</p><ul><li>启动producer的时候会向nameserver获取publishInfoTable，以后每 30 秒从 nameserver获取 Topic 跟 Broker 的映射关系，近实时获取最新数据存储单元，queue落地在哪个broker中</li><li>获取nameserver中的topic列表</li><li>使用topic向nameserver获取topicRouteData：表示与某一个topic有关系的broker节点信息，内部包含多个QueueData对象（当前集群、当前brokerName、队列集合）和多个BrokerData信息（多个集群的多个节点信息都在该列表中）</li></ul><h3 id="consumer端完成负载均衡"><a href="#consumer端完成负载均衡" class="headerlink" title="consumer端完成负载均衡"></a>consumer端完成负载均衡</h3><p>consumer启动流程</p><ul><li>连接 nameserver 获取集群信息，负载粒度直到Topic 下指定 Message Queue</li><li>每个consumer 通过 balanced 维护 <code>processQueueTable</code><ul><li>processQueueTable 为当前 consumer 的消费 queue<ul><li>ProcessQueue ：维护消费进度，从broker中拉取回来的消息缓冲</li><li>MessageQueue ： 用来定位查找queue</li></ul></li></ul></li></ul><h3 id="当消费负载均衡consumer和queue不对等的时候会发生什么？"><a href="#当消费负载均衡consumer和queue不对等的时候会发生什么？" class="headerlink" title="当消费负载均衡consumer和queue不对等的时候会发生什么？"></a>当消费负载均衡consumer和queue不对等的时候会发生什么？</h3><h4 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h4><p>平均分配策略</p><p>环形分配策略</p><p>手动配置分配策略</p><p>机房分配策略</p><p>一致性哈希分配策略</p><p>靠近机房策略</p><h2 id="如何让RocketMQ保证消息的顺序消费"><a href="#如何让RocketMQ保证消息的顺序消费" class="headerlink" title="如何让RocketMQ保证消息的顺序消费"></a>如何让RocketMQ保证消息的顺序消费</h2><p><strong>你们线上业务用消息中间件的时候，是否需要保证消息的顺序性?</strong></p><p><strong>如果不需要保证消息顺序，为什么不需要?假如我有一个场景要保证消息的顺序，你们应该如何保证?</strong></p><ul><li>同一topic</li><li>同一个QUEUE</li><li>发消息的时候一个线程去发送消息</li><li>消费的时候 一个线程 消费一个queue里的消息或者使用MessageListenerOrderly</li><li>多个queue 只能保证单个queue里的顺序</li></ul><h3 id="应用场景是啥？"><a href="#应用场景是啥？" class="headerlink" title="应用场景是啥？"></a>应用场景是啥？</h3><p>应用系统和现实的生产业务绑定，避免在分布式系统中多端消费业务消息造成顺序混乱</p><p>比如需要严格按照顺序处理的数据或业务</p><h2 id="RocketMQ如何保证消息不丢失"><a href="#RocketMQ如何保证消息不丢失" class="headerlink" title="RocketMQ如何保证消息不丢失"></a>RocketMQ如何保证消息不丢失</h2><ol><li>生产端如何保证投递出去的消息不丢失：消息在半路丢失，或者在MQ内存中宕机导致丢失，此时你如何基于MQ的功能保证消息不要丢失？</li><li>MQ自身如何保证消息不丢失？</li><li>消费端如何保证消费到的消息不丢失：如果你处理到一半消费端宕机，导致消息丢失，此时怎么办？</li></ol><h3 id="解耦的思路"><a href="#解耦的思路" class="headerlink" title="解耦的思路"></a>解耦的思路</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>发送消息时做消息备份（记日志或同步到数据库），判断sendResult是否正常返回</p><h4 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h4><p><strong>节点保证</strong></p><ul><li>master接受到消息后同步刷盘，保证了数据持久化到了本机磁盘中</li><li>同步写入slave</li><li>写入完成后返回SendResult</li></ul><h4 id="consumer-1"><a href="#consumer-1" class="headerlink" title="consumer"></a>consumer</h4><ul><li>记日志</li><li>同步执行业务逻辑，最后返回ack</li><li>异常控制 </li></ul><p><strong>磁盘保证</strong></p><p>使用Raid磁盘阵列保证数据磁盘安全</p><p><strong>网络数据篡改</strong></p><p>内置TLS可以开启，默认使用crc32校验数据</p><h3 id="消息刷盘机制底层实现"><a href="#消息刷盘机制底层实现" class="headerlink" title="消息刷盘机制底层实现"></a>消息刷盘机制底层实现</h3><p>每间隔10ms，执行一次数据持久化操作</p><p>两种， 同步刷、异步刷</p><pre><code>   public void run() {            CommitLog.log.info(this.getServiceName() + &quot; service started&quot;);            while (!this.isStopped()) {                try {                    this.waitForRunning(10);                    this.doCommit();                } catch (Exception e) {                    CommitLog.log.warn(this.getServiceName() + &quot; service has exception. &quot;, e);                }            }</code></pre><h2 id="rocketMq的消息堆积如何处理"><a href="#rocketMq的消息堆积如何处理" class="headerlink" title="rocketMq的消息堆积如何处理"></a>rocketMq的消息堆积如何处理</h2><p><strong>下游消费系统如果宕机了，导致几百万条消息在消息中间件里积压，此时怎么处理?</strong></p><p><strong>你们线上是否遇到过消息积压的生产故障?如果没遇到过，你考虑一下如何应对?</strong></p><p>具体表现为 ui中转圈圈</p><p>对于大规模消息发送接收可以使用pull模式，手动处理消息拉取速度,消费的时候统计消费时间以供参考</p><p>保证消息消费速度固定，即可通过上线更多consumer临时解决消息堆积问题</p><h3 id="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"><a href="#如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？" class="headerlink" title="如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？"></a>如果consumer和queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？</h3><ul><li>准备一个临时的topic</li><li>queue的数量是堆积的几倍</li><li>queue分不到多broker种</li><li>上线一台consumer做消息的搬运工，把原来topic中的消息挪到新的topic里，不做业务逻辑处理，只是挪过去</li><li>上线N台consumer同时消费临时topic中的数据</li><li>改bug</li><li>恢复原来的consumer，继续消费之前的topic</li></ul><h3 id="堆积时间过长消息超时了？"><a href="#堆积时间过长消息超时了？" class="headerlink" title="堆积时间过长消息超时了？"></a>堆积时间过长消息超时了？</h3><p>RocketMQ中的消息只会在commitLog被删除的时候才会消失，不会超时</p><h3 id="堆积的消息会不会进死信队列？"><a href="#堆积的消息会不会进死信队列？" class="headerlink" title="堆积的消息会不会进死信队列？"></a>堆积的消息会不会进死信队列？</h3><p>不会，消息在消费失败后会进入重试队列（%RETRY%+consumergroup），多次（默认16）才会进入死信队列（%DLQ%+consumergroup）</p><h2 id="你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的"><a href="#你们用的是RocketMQ-那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的" class="headerlink" title="你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?"></a>你们用的是RocketMQ?那你说说RocketMQ的底层架构原理，磁盘上数据如何存储的，整体分布式架构是如何实现的?</h2><h2 id="零拷贝等技术是如何运用的"><a href="#零拷贝等技术是如何运用的" class="headerlink" title="零拷贝等技术是如何运用的?"></a>零拷贝等技术是如何运用的?</h2><p>使用nio的MappedByteBuffer调起数据输出</p><h2 id="你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理"><a href="#你们用的是RocketMQ-RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理" class="headerlink" title="你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?"></a>你们用的是RocketMQ?RocketMQ很大的一个特点是对分布式事务的支持，你说说他在分布式事务支持这块机制的底层原理?</h2><p>分布式系统中的事务可以使用TCC（Try、Confirm、Cancel）、2pc来解决分布式系统中的消息原子性</p><p>RocketMQ 4.3+提供分布事务功能，通过 RocketMQ 事务消息能达到分布式事务的最终一致</p><h4 id="RocketMQ实现方式"><a href="#RocketMQ实现方式" class="headerlink" title="RocketMQ实现方式"></a>RocketMQ实现方式</h4><p><strong>Half Message：</strong>预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中</p><p><strong>检查事务状态：</strong>Broker会开启一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态（提交、回滚、未知），如果是未知，等待下一次回调。</p><p><strong>超时：</strong>如果超过回查次数，默认回滚消息</p><h4 id="TransactionListener的两个方法"><a href="#TransactionListener的两个方法" class="headerlink" title="TransactionListener的两个方法"></a>TransactionListener的两个方法</h4><h5 id="executeLocalTransaction"><a href="#executeLocalTransaction" class="headerlink" title="executeLocalTransaction"></a>executeLocalTransaction</h5><p>半消息发送成功触发此方法来执行本地事务</p><h5 id="checkLocalTransaction"><a href="#checkLocalTransaction" class="headerlink" title="checkLocalTransaction"></a>checkLocalTransaction</h5><p>broker将发送检查消息来检查事务状态，并将调用此方法来获取本地事务状态</p><h5 id="本地事务执行状态"><a href="#本地事务执行状态" class="headerlink" title="本地事务执行状态"></a>本地事务执行状态</h5><p><strong>LocalTransactionState.COMMIT_MESSAGE</strong></p><p>执行事务成功，确认提交</p><p><strong>LocalTransactionState.ROLLBACK_MESSAGE</strong></p><p>回滚消息，broker端会删除半消息</p><p><strong>LocalTransactionState.UNKNOW</strong></p><p>暂时为未知状态，等待broker回查</p><h2 id="高吞吐量下如何优化生产者和消费者的性能"><a href="#高吞吐量下如何优化生产者和消费者的性能" class="headerlink" title="高吞吐量下如何优化生产者和消费者的性能?"></a>高吞吐量下如何优化生产者和消费者的性能?</h2><h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><ul><li>分片</li><li>加队列</li></ul><h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ul><li>批量消费</li><li>并行消费</li><li>加队列</li><li>分片</li><li>多实例</li></ul><h3 id="调优点"><a href="#调优点" class="headerlink" title="调优点"></a>调优点</h3><ul><li>网卡调优</li><li>jvm调优</li><li>多线程与cpu调优</li><li>Page Cache</li></ul><h2 id="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现"><a href="#如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现" class="headerlink" title="如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?"></a>如果让你来动手实现一个分布式消息中间件，整体架构你会如何设计实现?</h2><p>功能</p><ol><li>数据存储：如何提升磁盘的IO效率？CommitLog 顺序写（mmap） + OS pageCache + OS 异步刷盘，读写效率接近内存操作</li><li>数据收发：如何提升网络IO效率？NIO + Reactor + Work</li></ol><p>特点</p><p>读写场景拆分、分析。写入频繁，主动推送不是很频繁，通过基于长链接的长轮询</p><p>异步与同步模型最大的区别是<br>同步模型会阻塞线程等待资源，一般采用的都是一个线程对应多个Channel接收数据少量线程情况下不会有问题，大量的连接数就会需要相同数量的数据接收线程，会有大量的线程来抢占CPU时间，造成频繁的CPU上下文切换，导致CPU的负载升高，整个系统的性能就会比较慢.</p><p>异步模型不会阻塞线程，它是等资源准备好后，再通知业务代码来完成后续的资源处理逻辑</p><p>如果要实现通过网络来传输数据，需要用到开发语言提供的网络通信类库。大部分语言提供的网络通信基础类库都是同步的,一个TCP连接建立后，业务代码会获得一个用于收发数据的通道,每个通道会在内存中开辟两个区域用于收发数据的缓存。</p><p>发数据流程：发送数据的过程比较简单，我们直接往这个通道里面来写入数据就可以了。业务代码在发送时写入的数据会暂存在缓存中，然后操作系统会通过⽹卡，把发送缓存中的数据传输到对端的服务器上,只要这个缓存不满,或者说,我们发送数据的速度没有超过网卡传输速度的上限，那这个发送数据的操作耗时，只不过是一次内存写入的时间<br>收数据流程：比较麻烦的是接收数据。对于数据的接收方来说，它并不知道什么时候会收到数据。那我们能直接想到的是，用一个线程阻塞在那等着数据，当有数据到来的时候，操作系统会先把数据写⼊接收缓存，然后给接收数据的线程发⼀个通知，线程收到通知后结束等待，开始读取数据。处理完这⼀批数据后，继续阻塞 等待下⼀批数据到来，这样周⽽复始地处理收到的数据。</p><p>NIO中，它提供了一个Selector对象，来解决一个线程在多个网络连接上的多路复用问题<br>在NIO中，每个已经建立好的连接用一个Channel对象来表示。我们希望能实现，在⼀个线程⾥，接收来⾃多个Channel的数据。也就是说，这些Channel中，任何⼀个Channel收到数据后，第⼀时间能在同⼀个线程⾥⾯来处理。<br>⼀个线程对应多个Channel，有可能会出现这两种情况：<br>\1. 线程在忙着处理收到的数据，这时候Channel中⼜收到了新数据；<br>\2. 线程闲着没事⼉⼲，所有的Channel中都没收到数据，也不能确定哪个Channel会在什么时候收到数据。</p><p>Selecor通过⼀种类似于事件的机制来解决这个问题。⾸先你需要把你的连接，也就是Channel绑定到 Selector上，然后你可以在接收数据的线程来调⽤Selector.select()⽅法来等待数据到来。这个select⽅法是⼀个阻塞⽅法，这个线程会⼀直卡在这⼉，直到这些Channel中的任意⼀个有数据到来，就会结束等待返回数据。它的返回值是⼀个迭代器，你可以从这个迭代器⾥⾯获取所有Channel收到的数据，然后来执⾏你的 数据接收的业务逻辑。你可以选择直接在这个线程⾥⾯来执⾏接收数据的业务逻辑，也可以将任务分发给其他的线程来执⾏，如何 选择完全可以由你的代码来控制。 </p><p>Netty服务端会存在两个线程池NioEventLoopGroup<br>客户端连接线程池,一个线程NioEventLoop对应一个端口的多个channel通道,通道里会有收发缓存,服务端会定时监控channel通道是否断开,在⼀定时间没有收到客⼾端的⼼跳包,把客⼾端的Channel从服务端移除,还可以设置服务端接收连接的队列</p><p>处理线程池NioEventLoopGroup,⾥⾯会有多个NioEventLoop线程,每个NioEventLoop都会有⼀个Selector，然后可以多个channel绑定到NioEventLoop的Selector中,即收到Channel数据，NioEventLoop执⾏Handler，包括解码、拆包等Handler，服务端返回响应消息对Channel进⾏编码等Handler。</p><p>接收数据是⼀个NioEventLoop会有⼀个Selector,原先的Nio是只有⼀个Selector进⾏处理所有的连接收发事件,NioEventLoopGroup中有10个NioEventLoop,这样的话就有10个Selector，⽐如有10000读写请求，每个Selector就可以维持1000</p><p>有一个养鸡的农场，里面养着来自各个农户（Thread）的鸡（Socket），每家农户都在农场中建立了自己的鸡舍（SocketChannel） </p><p>1、BIO：Block IO，每个农户盯着自己的鸡舍，一旦有鸡下蛋，就去做捡蛋处理； </p><p>2、NIO：No-Block IO-单Selector，农⼾们花钱请了⼀个饲养员（Selector），并告诉饲养员（register ）如果哪家的鸡有任何情况（下蛋）均要向这家农⼾报告（select keys）； </p><p>3、NIO：No-Block IO-多Selector，当农场中的鸡舍逐渐增多时，⼀个饲养员巡视（轮询）⼀次所需时间就会不断地加⻓，这样农⼾知道⾃⼰家的鸡有下蛋的情况就会发⽣较⼤的延迟。怎么解决呢？没错，多请⼏个饲养员（多Selector），每个饲养员分配管理鸡舍，这样就可以减轻⼀个饲养员的⼯作量，同时农⼾ 们可以更快的知晓⾃⼰家的鸡是否下蛋了； </p><p>4、Epoll模式：如果采⽤Epoll⽅式，农场问题应该如何改进呢？其实就是饲养员不需要再巡视鸡舍，⽽ 是听到哪间鸡舍的鸡打鸣了（活跃连接），就知道哪家农⼾的鸡下蛋了； </p><p>5、AIO：Asynchronous I/O,下蛋后，以前的NIO⽅式要求饲养员通知农⼾去取蛋，AIO模式出现以后，事情变得更加简单了，取蛋⼯作由饲养员⾃⼰负责，然后取完后，直接通知农⼾来拿即可，⽽不需要农 ⼾⾃⼰到鸡舍去取蛋。  </p><h2 id="看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解"><a href="#看过RocketMQ-的源码没有。如果看过，说说你对RocketMQ-源码的理解" class="headerlink" title="看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?"></a>看过RocketMQ 的源码没有。如果看过，说说你对RocketMQ 源码的理解?</h2><p>核心流程</p><ol><li>producer</li><li>consumer</li><li>broker</li><li>nameserver</li></ol><p>吐槽</p><ul><li>无注释</li><li>没啥设计模式</li><li>不太规范</li><li>通过大量的定时任务完成的整体业务流转</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>高并发场景下堆机器做法的弊端，通过合理的分析业务场景的核心请求链路，精心设计架构</p><p>扫码出入库流程：新流程引入 NFC 并发量剧增</p><p>运营报告 - 多维度统计sql</p><p>IOT 数据筛选 - 数据过滤</p>]]></content>
      
      
      <categories>
          
          <category> 消息中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 技术细节、核心思想</title>
      <link href="/2020/09/19/Spring%20%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/2020/09/19/Spring%20%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E3%80%81%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Spring-Framework"><a href="#一、Spring-Framework" class="headerlink" title="一、Spring Framework"></a>一、Spring Framework</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h3 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h3><h3 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h3><h3 id="企业级应用技术、整合第三方框架和类库，提供事务管理"><a href="#企业级应用技术、整合第三方框架和类库，提供事务管理" class="headerlink" title="企业级应用技术、整合第三方框架和类库，提供事务管理"></a>企业级应用技术、整合第三方框架和类库，提供事务管理</h3><h2 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h2><ul><li><h3 id="解耦，简化开发"><a href="#解耦，简化开发" class="headerlink" title="解耦，简化开发"></a>解耦，简化开发</h3></li><li><h3 id="AOP-支持"><a href="#AOP-支持" class="headerlink" title="AOP 支持"></a>AOP 支持</h3></li><li><h3 id="声明式事物"><a href="#声明式事物" class="headerlink" title="声明式事物"></a>声明式事物</h3></li><li><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3></li></ul><h2 id="三、核心结构"><a href="#三、核心结构" class="headerlink" title="三、核心结构"></a>三、核心结构</h2><h2 id="四、核心思想"><a href="#四、核心思想" class="headerlink" title="四、核心思想"></a>四、核心思想</h2><h3 id="IoC：对象创建、配置、组装。解决对象之间耦合问题"><a href="#IoC：对象创建、配置、组装。解决对象之间耦合问题" class="headerlink" title="IoC：对象创建、配置、组装。解决对象之间耦合问题"></a>IoC：对象创建、配置、组装。解决对象之间耦合问题</h3><p><img src="http://lion-heart.online/blog/2020-11-19-125526.png" alt="image-20201119205525856"></p><p>IoC：对象角度</p><p>DI：容器角度</p><h3 id="AOP：面向切面，对OOP进行补充"><a href="#AOP：面向切面，对OOP进行补充" class="headerlink" title="AOP：面向切面，对OOP进行补充"></a>AOP：面向切面，对OOP进行补充</h3><p><img src="http://lion-heart.online/blog/2020-11-19-131214.png" alt="image-20201119211214040"></p><p><img src="http://lion-heart.online/blog/2020-11-19-131419.png" alt="image-20201119211419374"></p><p><img src="http://lion-heart.online/blog/2020-11-19-131546.png" alt="image-20201119211546486"></p><h2 id="五、造轮子：IoC、AOP"><a href="#五、造轮子：IoC、AOP" class="headerlink" title="五、造轮子：IoC、AOP"></a>五、造轮子：IoC、AOP</h2><ol><li><h3 id="new-关键字导致的耦合问题"><a href="#new-关键字导致的耦合问题" class="headerlink" title="new 关键字导致的耦合问题"></a>new 关键字导致的耦合问题</h3><ul><li><h4 id="配置元信息"><a href="#配置元信息" class="headerlink" title="配置元信息"></a>配置元信息</h4></li><li><h4 id="容器通过元信息，创建、配置、构建-对象实例"><a href="#容器通过元信息，创建、配置、构建-对象实例" class="headerlink" title="容器通过元信息，创建、配置、构建 对象实例"></a>容器通过元信息，创建、配置、构建 对象实例</h4></li></ul></li><li><h3 id="事物控制问题"><a href="#事物控制问题" class="headerlink" title="事物控制问题"></a>事物控制问题</h3><ul><li><h4 id="一个线程内，多个-Method，多-SQL-使用一个-Connection"><a href="#一个线程内，多个-Method，多-SQL-使用一个-Connection" class="headerlink" title="一个线程内，多个 Method，多 SQL 使用一个 Connection"></a>一个线程内，多个 Method，多 SQL 使用一个 Connection</h4></li><li><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4></li><li><h4 id="动态代理：JDK、Cglib"><a href="#动态代理：JDK、Cglib" class="headerlink" title="动态代理：JDK、Cglib"></a>动态代理：JDK、Cglib</h4></li><li><p><img src="http://lion-heart.online/blog/2020-11-19-151414.png" alt="image-20201119231414387"> </p></li></ul></li></ol><h2 id="六、IoC-原理分析"><a href="#六、IoC-原理分析" class="headerlink" title="六、IoC 原理分析"></a>六、IoC 原理分析</h2><h3 id="Beans的创建、配置、组装相关"><a href="#Beans的创建、配置、组装相关" class="headerlink" title="Beans的创建、配置、组装相关"></a>Beans的创建、配置、组装相关</h3><h4 id="1-创建相关"><a href="#1-创建相关" class="headerlink" title="1. 创建相关"></a>1. 创建相关</h4><h5 id="Bean的生命周期、作用范围"><a href="#Bean的生命周期、作用范围" class="headerlink" title="Bean的生命周期、作用范围"></a>Bean的生命周期、作用范围</h5><h4 id="2-组装相关"><a href="#2-组装相关" class="headerlink" title="2. 组装相关"></a>2. 组装相关</h4><h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><h5 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h5><h5 id="FIeld"><a href="#FIeld" class="headerlink" title="FIeld"></a>FIeld</h5><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><h4 id="4-高级特性"><a href="#4-高级特性" class="headerlink" title="4.高级特性"></a>4.高级特性</h4><ol><li><h5 id="lazy-init：服务器性能差、不常使用的-bean"><a href="#lazy-init：服务器性能差、不常使用的-bean" class="headerlink" title="lazy-init：服务器性能差、不常使用的 bean"></a>lazy-init：服务器性能差、不常使用的 bean</h5></li><li><h5 id="FactoryBean：复杂-bean-创建"><a href="#FactoryBean：复杂-bean-创建" class="headerlink" title="FactoryBean：复杂 bean 创建"></a>FactoryBean：复杂 bean 创建</h5></li><li><h5 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h5></li></ol><h2 id="七、源码阅读"><a href="#七、源码阅读" class="headerlink" title="七、源码阅读"></a>七、源码阅读</h2><h4 id="1-IoC-初始化整体流程"><a href="#1-IoC-初始化整体流程" class="headerlink" title="1.IoC 初始化整体流程"></a>1.IoC 初始化整体流程</h4><p>spring应用上下文 - IoC容器：包含一组组件和协作过程集合，包括BeanFactory、单例池(Map)、BeanPostProcessors</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    配置文件信息</span>  <span class="token function">setConfigLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    容器初始化</span>  <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  第⼀步：刷新前的预处理</span>        <span class="token comment" spellcheck="true">//    设置容器启动时间、开启活跃状态、插销关闭状态、验证环境属性。部分逻辑使用模版方法</span>        <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>BeanFactory 核心流程<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>        <span class="token comment" spellcheck="true">/*        第⼆步：         核心流程1:获取BeanFactory；默认实现是DefaultListableBeanFactory        核心流程2:加载BeanDefition 并注册到 BeanDefitionRegistry        */</span>        ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token number">1</span><span class="token punctuation">.</span> <span class="token keyword">new</span> <span class="token class-name">DefaultListableBeanFactory</span>        <span class="token number">2</span><span class="token punctuation">.</span> 设置工厂相关属性（循环依赖、bean定义覆盖）        <span class="token number">3</span><span class="token punctuation">.</span> 加载应用中的 BeanDefinitions          <span class="token number">4</span><span class="token punctuation">.</span> 返回 工厂 实例                <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>        <span class="token comment" spellcheck="true">// 第三步：BeanFactory的预准备⼯作（BeanFactory进⾏⼀些设置，⽐如context的类加载器等）</span>        <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第四步：BeanFactory准备⼯作完成后进⾏的后置处理⼯作</span>        <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第五步：实例化并调⽤实现了BeanFactoryPostProcessor接⼝的Bean</span>        <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第六步：注册BeanPostProcessor（Bean的后置处理器），在创建bean的前后等执⾏</span>        <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第七步：初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；</span>        <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第⼋步：初始化事件派发器</span>        <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第九步：⼦类重写这个⽅法，在容器刷新的时候可以⾃定义逻辑</span>        <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第⼗步：注册应⽤的监听器。就是注册实现了ApplicationListener接⼝的监听器bean</span>        <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>Bean 创建核心流程<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>        <span class="token comment" spellcheck="true">/*        第⼗⼀步：        初始化所有剩下的⾮懒加载的单例bean        初始化创建⾮懒加载⽅式的单例Bean实例（未设置属性）        填充属性        初始化⽅法调⽤（⽐如调⽤afterPropertiesSet⽅法、init-method⽅法）        调⽤BeanPostProcessor（后置处理器）对实例bean进⾏后置处        */</span>        <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>        <span class="token comment" spellcheck="true">/*        第⼗⼆步：        完成context的刷新。主要是调⽤LifecycleProcessor的onRefresh()⽅法，并且发布事        件 （ContextRefreshedEvent）        */</span>        <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="BeanFactory-核心流程"><a href="#BeanFactory-核心流程" class="headerlink" title="BeanFactory 核心流程"></a>BeanFactory 核心流程</h5><p><img src="http://lion-heart.online/blog/2020-11-22-044034.png" alt="获取 BeanFactory 时序图"></p><h5 id="BeanDefinition-注册流程"><a href="#BeanDefinition-注册流程" class="headerlink" title="BeanDefinition 注册流程"></a>BeanDefinition 注册流程</h5><p><img src="http://lion-heart.online/blog/2020-11-22-050557.png" alt="加载 beanDefinition 注册 beanRegister 流程"></p><h5 id="Spring-Bean-核心流程"><a href="#Spring-Bean-核心流程" class="headerlink" title="Spring Bean 核心流程"></a>Spring Bean 核心流程</h5><p><img src="http://lion-heart.online/blog/2020-11-22-075159.png" alt="bean 创建流程"></p><h5 id="循环依赖问题解决：setter-方式注入"><a href="#循环依赖问题解决：setter-方式注入" class="headerlink" title="循环依赖问题解决：setter 方式注入"></a>循环依赖问题解决：setter 方式注入</h5><h3 id="八、Spring-事物管理"><a href="#八、Spring-事物管理" class="headerlink" title="八、Spring 事物管理"></a>八、Spring 事物管理</h3><h4 id="1-声明式事物：事物逻辑和业务逻辑分离，通过XML、注解方式实现"><a href="#1-声明式事物：事物逻辑和业务逻辑分离，通过XML、注解方式实现" class="headerlink" title="1. 声明式事物：事物逻辑和业务逻辑分离，通过XML、注解方式实现"></a>1. 声明式事物：事物逻辑和业务逻辑分离，通过XML、注解方式实现</h4><h4 id="2-编程式事物：业务逻辑通过代码控制事物"><a href="#2-编程式事物：业务逻辑通过代码控制事物" class="headerlink" title="2.编程式事物：业务逻辑通过代码控制事物"></a>2.编程式事物：业务逻辑通过代码控制事物</h4><h1 id="二、核心流程"><a href="#二、核心流程" class="headerlink" title="二、核心流程"></a>二、核心流程</h1><h2 id="配置阶段"><a href="#配置阶段" class="headerlink" title="配置阶段"></a>配置阶段</h2><p>​    基础配置</p><p>​            bean配置</p><p>​            spring相关配置</p><h2 id="初始化阶段-init方法-定位-加载-解析-实例化-注入"><a href="#初始化阶段-init方法-定位-加载-解析-实例化-注入" class="headerlink" title="初始化阶段    init方法 定位 加载 解析 实例化 注入"></a>初始化阶段    init方法 定位 加载 解析 实例化 注入</h2><ol><li>加载元配置信息</li><li>获取所有托管的bean信息</li><li>初始化IOC容器</li><li><ul><li>bean名称的定义 </li></ul></li><li>DI：反射获取所有属性，找到注解，判断是否有自定义类名，没有就按照类型</li><li>HandlerMapping -&gt; 封装了url、类、Method 、获取方法注解二维数组，构建参数位置信息Map&lt;参数名,index&gt;、参数类型数组</li></ol><h2 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h2><p>​        请求转发</p><p>​        请求参数动态处理</p><ol><li>从handlerMapping 获取参数类型数据</li><li>参数转换 - http协议过来的参数都是字符串类型</li></ol><h1 id="三、Spring-涉及到的技术细节、核心思想"><a href="#三、Spring-涉及到的技术细节、核心思想" class="headerlink" title="三、Spring 涉及到的技术细节、核心思想"></a>三、Spring 涉及到的技术细节、核心思想</h1><p>IoC：整体类图<img src="http://lion-heart.online/blog/2020-09-20-132357.png" alt="spring 类图"></p><p>AOP：</p><h3 id="设计模式、原则"><a href="#设计模式、原则" class="headerlink" title="设计模式、原则"></a>设计模式、原则</h3><ol><li>单一职责原则（SRP）：BeanFactory、ConfigurableBeanFactory 等很多类</li><li>接口最小化：BeanFactory 等很多类</li><li>模版方法：AbstractApplicationContext </li><li>开闭原则：</li><li>责任链：Aop chain</li><li>面向接口</li></ol><h3 id="技术点1-XML-解析"><a href="#技术点1-XML-解析" class="headerlink" title="技术点1. XML 解析"></a>技术点1. XML 解析</h3><ol><li>Dom4j<ol><li>BeanDefinition 描述 <bean> 标签内的 id、class</li><li>Property 描述 <property> 标签内的 ref、value</li><li>bean 实例化 resolve</li></ol></li><li>SAX</li></ol><h3 id="技术点2-测试用例相关"><a href="#技术点2-测试用例相关" class="headerlink" title="技术点2. 测试用例相关"></a>技术点2. 测试用例相关</h3><p>TDD</p><h3 id="技术点3-反射相关"><a href="#技术点3-反射相关" class="headerlink" title="技术点3. 反射相关"></a>技术点3. 反射相关</h3><ol><li>加载 Class<ol><li>CLassLoader 的设置和定义</li></ol></li><li>实例化 Class<ol><li>构造器：少依赖、强制依赖</li><li>setter：多依赖、非强制依赖</li><li>Filed：便利性，注解方式</li><li>Method：@Bean 声明类</li><li>CallBack</li></ol></li></ol><h3 id="技术点4-生命周期-Scope-相关"><a href="#技术点4-生命周期-Scope-相关" class="headerlink" title="技术点4. 生命周期 Scope 相关"></a>技术点4. 生命周期 Scope 相关</h3><ol><li>Singleton<ol><li>BeanDefinition 存储 bean 实例信息</li></ol></li><li>Prototype<ol><li>每次都去 createBean – doCreateBeanInstance  –  populateBean  –  DI（反射）–  类型转换    </li></ol></li></ol><h3 id="技术点5-实现Spring注解-Autowired、-Compoment"><a href="#技术点5-实现Spring注解-Autowired、-Compoment" class="headerlink" title="技术点5. 实现Spring注解(@Autowired、@Compoment)"></a>技术点5. 实现Spring注解(@Autowired、@Compoment)</h3><h4 id="注解含义"><a href="#注解含义" class="headerlink" title="注解含义"></a>注解含义</h4><p>@Target</p><ol><li>Type</li><li>METHOD</li><li>FILED</li></ol><p>@Retention</p><ol><li>RUNTIME</li></ol><p>思路</p><ol><li><p>解析XML  -  base-package = “xxxx” 为资源路径</p></li><li><p>对指定 package 扫描，找到注解类，创建 BeanDefinition</p><ol><li>package 类变成 Resource：PackageReousrceLoader 接口</li><li>通过 ASM 读取注解。获取注解类，以及相关类属性和值</li><li>创建 BeanDefinition</li></ol></li><li><p>通过 BeanDefinition 创建实例，根据注解注入</p></li><li><p>Processor 登场：读取 class 的 @Autowired 注解。通过AutowiredAnnotationProcessor 可以把一个 CLass 变成 InjectionMetadata<img src="http://lion-heart.online/blog/2020-09-20-131429.png" alt="InjectionDelement 类图"></p></li><li><p>Bean 生命周期<img src="http://lion-heart.online/blog/2020-09-20-132036.png" alt="Bean 生命周期"></p><p><img src="http://lion-heart.online/blog/2020-09-20-132252.png" alt="类图"></p></li></ol><ol start="6"><li><p>AspectJAutoProxyCreator implements BeanPostProceesor 进行代理类的创建</p></li><li><p>核心 chain 执行逻辑为 ReflectiveMethodInvocation</p></li></ol><h3 id="Spring-validator-实践"><a href="#Spring-validator-实践" class="headerlink" title="Spring.validator    实践"></a>Spring.validator    实践</h3><h3 id="ASM-（汇编）-asm-ow2-io-java-bytecode-manipulation-and-analysis-framework"><a href="#ASM-（汇编）-asm-ow2-io-java-bytecode-manipulation-and-analysis-framework" class="headerlink" title="ASM （汇编）(asm.ow2.io) : java bytecode manipulation and analysis framework"></a>ASM （汇编）(asm.ow2.io) : java bytecode manipulation and analysis framework</h3><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ol><li>Iterator</li><li>Visitor：解析类（java 虚拟机规范了解一下）</li><li>ChainOfResponsibility</li><li>Adaptor</li></ol><h4 id="Api-能力"><a href="#Api-能力" class="headerlink" title="Api 能力"></a>Api 能力</h4><p>ClassVisitor：访问 Class</p><p>ClassReader：解析 Class 信息 -》通过我们自定以类(ClassPrinter)的 visitXx 方法，输出具体类信息</p><p>读(ClassReader) Class 信息</p><p>写(ClassWriter) Class 信息</p><p>改变 Class 信息</p><h3 id="Cglib"><a href="#Cglib" class="headerlink" title="Cglib"></a>Cglib</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构师计划</title>
      <link href="/2020/09/11/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%A1%E5%88%92/"/>
      <url>/2020/09/11/%E6%9E%B6%E6%9E%84%E5%B8%88%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>title: 架构师<br>date: 2020年09月11日07:34:54<br>author: 靳宏财<br>top: true<br>cover: true<br>toc: true<br>mathjax: false<br>password: 2020jinhc<br>abstract: read.<br>message: Welcome to my blog, enter password to read.<br>summary: 架构师学习计划<br>categories: 计划<br>tags:</p><ul><li>计划</li></ul><h1 id="架构师计划"><a href="#架构师计划" class="headerlink" title="架构师计划"></a>架构师计划</h1><h2 id="编程思想和设计模式"><a href="#编程思想和设计模式" class="headerlink" title="编程思想和设计模式"></a>编程思想和设计模式</h2><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><code>Java</code>基础</h2><h3 id="语言特性JDK1-5-JDK1-8"><a href="#语言特性JDK1-5-JDK1-8" class="headerlink" title="语言特性JDK1.5~JDK1.8"></a>语言特性<code>JDK1.5~JDK1.8</code></h3><h4 id="面向对象编程OOP"><a href="#面向对象编程OOP" class="headerlink" title="面向对象编程OOP"></a>面向对象编程<code>OOP</code></h4><h4 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h4><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><h3 id="集合体系"><a href="#集合体系" class="headerlink" title="集合体系"></a><a href="https://orgjinhc.github.io/2020/09/05/Java集合体系">集合体系</a></h3><h2 id="Java高级"><a href="#Java高级" class="headerlink" title="Java高级"></a><code>Java</code>高级</h2><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h4><h4 id="锁-java层面时代、JVM层面实现、OS层面实现、硬件层面实现"><a href="#锁-java层面时代、JVM层面实现、OS层面实现、硬件层面实现" class="headerlink" title="锁(java层面时代、JVM层面实现、OS层面实现、硬件层面实现)"></a>锁(java层面时代、JVM层面实现、OS层面实现、硬件层面实现)</h4><p><a href="https://orgjinhc.github.io/2020/01/28/Synchronized">Synchroniz</a></p><p>ReentrantLock</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><h2 id="核心框架"><a href="#核心框架" class="headerlink" title="核心框架"></a>核心框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a><code>Spring</code></h3><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a><code>Mybatis</code></h3><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a><code>JVM</code></h3><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h4><h4 id="rabiitMq"><a href="#rabiitMq" class="headerlink" title="rabiitMq"></a>rabiitMq</h4><h4 id="rocketMq"><a href="#rocketMq" class="headerlink" title="rocketMq"></a>rocketMq</h4><h4 id="activeMq"><a href="#activeMq" class="headerlink" title="activeMq"></a>activeMq</h4><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><h4 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h4><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>技术体系</title>
      <link href="/2020/09/05/%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/"/>
      <url>/2020/09/05/%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="架构能力"><a href="#架构能力" class="headerlink" title="架构能力"></a>架构能力</h2><h1 id="Spring-套餐"><a href="#Spring-套餐" class="headerlink" title="Spring 套餐"></a>Spring 套餐</h1><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h3 id="消息相关"><a href="#消息相关" class="headerlink" title="消息相关"></a>消息相关</h3><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java集合体系</title>
      <link href="/2020/09/05/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB/"/>
      <url>/2020/09/05/Java%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p> 有序集合/序列，允许存在重复元素</p><h2 id="List：用户可以通过索引访问元素，知道索引通过索引访问，不知道通过迭代访问，这就对应了两种实现，数组ArrayList和链表LinedkList。共有特性允许存储重复元素"><a href="#List：用户可以通过索引访问元素，知道索引通过索引访问，不知道通过迭代访问，这就对应了两种实现，数组ArrayList和链表LinedkList。共有特性允许存储重复元素" class="headerlink" title="List：用户可以通过索引访问元素，知道索引通过索引访问，不知道通过迭代访问，这就对应了两种实现，数组ArrayList和链表LinedkList。共有特性允许存储重复元素"></a>List：用户可以通过索引访问元素，知道索引通过索引访问，不知道通过迭代访问，这就对应了两种实现，数组ArrayList和链表LinedkList。共有特性允许存储重复元素</h2><h3 id="ArrayList：数组实现的有序集合-有自己的迭代器"><a href="#ArrayList：数组实现的有序集合-有自己的迭代器" class="headerlink" title="ArrayList：数组实现的有序集合,有自己的迭代器"></a>ArrayList：数组实现的有序集合,有自己的迭代器</h3><p>   jdk 源码里对于ArrayList的操作，大部分使用 System.arraycopy进行数组copy操作 </p><h3 id="LinkedList：双向链表-Node-实现的有序集合-有自己的迭代器"><a href="#LinkedList：双向链表-Node-实现的有序集合-有自己的迭代器" class="headerlink" title="LinkedList：双向链表(Node)实现的有序集合,有自己的迭代器"></a>LinkedList：双向链表(Node)实现的有序集合,有自己的迭代器</h3><p>   jdk 源码里对于ArrayList的操作，大部分使用 System.arraycopy进行数组copy操作</p><h3 id="Vector-线程安全的ArrayList"><a href="#Vector-线程安全的ArrayList" class="headerlink" title="Vector:线程安全的ArrayList"></a>Vector:线程安全的ArrayList</h3><h2 id="Stack：基于数组的FILO机制"><a href="#Stack：基于数组的FILO机制" class="headerlink" title="Stack：基于数组的FILO机制"></a>Stack：基于数组的FILO机制</h2><p> 无需集合/序列，不包含重复元素的集合</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><h3 id="HashSet：通过-HashMap-实现，value-为-Object"><a href="#HashSet：通过-HashMap-实现，value-为-Object" class="headerlink" title="HashSet：通过 HashMap 实现，value 为 Object"></a>HashSet：通过 HashMap 实现，value 为 Object</h3><h3 id="TreeSet：通过-TreeMap-实现"><a href="#TreeSet：通过-TreeMap-实现" class="headerlink" title="TreeSet：通过 TreeMap 实现"></a>TreeSet：通过 TreeMap 实现</h3><p> 队列，基于FIFO机制,扩展了集合,并提供额外的插入、查询和检查操作，这些方法都以两种形式存在:一种是在操作失败时抛出异常，另一种是返回特殊值(  根据操作的不同，要么是null，要么是false。后一种插入操作是专门为容量受限的队列设计的实现 </p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="PriorityQueue：非FIFO，根据提供的比较器或元素的自然顺序对元素进行排序"><a href="#PriorityQueue：非FIFO，根据提供的比较器或元素的自然顺序对元素进行排序" class="headerlink" title="PriorityQueue：非FIFO，根据提供的比较器或元素的自然顺序对元素进行排序"></a>PriorityQueue：非FIFO，根据提供的比较器或元素的自然顺序对元素进行排序</h3><h3 id="BlockingQueue：它扩展queue，定义阻塞队列方法。等待元素出现或空间可用"><a href="#BlockingQueue：它扩展queue，定义阻塞队列方法。等待元素出现或空间可用" class="headerlink" title="BlockingQueue：它扩展queue，定义阻塞队列方法。等待元素出现或空间可用"></a>BlockingQueue：它扩展queue，定义阻塞队列方法。等待元素出现或空间可用</h3><p>   juc - ArrayBlockingQueue：基于数组实现的阻塞队列或叫有界缓冲区。尝试将一个元素放入一个完整的队列会导致操作阻塞;尝试从空队列获取元素同样会阻塞，这个类支持一个可选的公平性策略，用于等待的生产者和消费者线程。默认情况下，这种顺序是不保证的。公平性设置为{true}的队列按照FIFO顺序授予线程访问权。公平性通常会降低吞吐量，但减少可变性并避免饥饿（一把锁控制生产和消费）</p><p>   核心思想<br>    读写指针 –&gt; 生产、消费线程</p><p>   juc - LinkedBlockingQueue：基于链表实现的阻塞队列或叫无界缓冲区，链表队列通常比基于数组的队列具有更高的吞吐量(读写锁)<br>   juc - PriorityBlockingQueue<br>    put   同步阻塞方法<br>    take  同步阻塞方法</p><p>  add  Throws exception<br>  offer return spec value 固定容量的队列</p><p>  remove  Throws exception<br>  poll    return spec value</p><p>  element Throws exception<br>  peek    return spec value</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="HashMap-空间换时间"><a href="#HashMap-空间换时间" class="headerlink" title="HashMap    空间换时间"></a>HashMap    空间换时间</h3><h4 id="hash-函数"><a href="#hash-函数" class="headerlink" title="hash 函数"></a><code>hash</code> 函数</h4><ol><li>hash 函数（散列函数）<ul><li>根据key生成hash值(必须是整数)<ul><li>key必须实现 hashCode、equals 方法，也允许 key 为 null</li><li>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) ：充分利用所有素有信息计算hash值</li></ul></li><li>再让key的hash值跟数组大小进行模（使用 &amp; 位运算代替，前提 桶长度位2的幂）运算，生成bucket位置</li><li>bucket 分布均匀、减少hash冲突、提升hash结构性能</li></ul></li><li>利用index 操作数组（Bucket - 桶）元素</li></ol><h4 id="hash-冲突-碰撞"><a href="#hash-冲突-碰撞" class="headerlink" title="hash 冲突/碰撞"></a><code>hash</code> 冲突/碰撞</h4><ol><li>开放定址法：发生冲突后利用线性探测，直到遇到空桶</li><li>reHashing：设计多个hash函数</li><li>链地址法：JDK1.8的解决方案，默认单链表（比双链表少一个指针，节省内存空间且每次从头开始遍历链表），如果hash表容量 &gt;=64且bucket节点数据量大于8 ，链表 转换 红黑树</li></ol><h4 id="hashCode-equals-详解"><a href="#hashCode-equals-详解" class="headerlink" title="hashCode equals 详解"></a><code>hashCode equals</code> 详解</h4><p>java 基本类型和引用类型都有具体的<code>hashCode</code>算法</p><p>参考源码</p><p>自定义引用类型需要根据需要重写hashCode方法，如果不重写会使用基类<code>Object</code>的hashCode</p><p>相同<code>bucket</code>位置可能<code>hashCode</code>不同 </p><p>相同<code>key</code>如果不重写<code>hashCode</code>对应的<code>hashCode</code>也可能不同，<code>bucket</code>位置也能相同或不同。</p><p>不同<code>key</code>对应<code>hashCode</code>可能相同，也可能不同，如果相同就会存放到同一<code>bucket</code>。最终在发生<code>hash</code>冲突的时候，需要要通过<code>equals</code>方法比较<code>key</code></p><p><strong>总结：自定义引用类型 必须重写    业务确认什么样的对象为相同对象    相同对象的 <code>hashCode</code> 和 <code>equals</code>必定相同</strong></p><p><strong><code>equals</code>：判断2个<code>key</code>是否相同</strong></p><p><strong><code>hashCode</code>：必须保证<code>equals</code>为true的2个key的<code>hash</code>值一样</strong></p><h4 id="装填因子-负载因子：节点总数量-buckets。JDK-默认-0-75，超过就扩容2倍"><a href="#装填因子-负载因子：节点总数量-buckets。JDK-默认-0-75，超过就扩容2倍" class="headerlink" title="装填因子/负载因子：节点总数量/buckets。JDK 默认 0.75，超过就扩容2倍"></a>装填因子/负载因子：节点总数量/buckets。JDK 默认 0.75，超过就扩容2倍</h4><h4 id="扰动函数-hashCode"><a href="#扰动函数-hashCode" class="headerlink" title="扰动函数:hashCode"></a>扰动函数:hashCode</h4><h4 id="扩容-size-gt-threshould"><a href="#扩容-size-gt-threshould" class="headerlink" title="扩容:size &gt;= threshould"></a>扩容:size &gt;= threshould</h4><h3 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h3><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>时间复杂度平均：添加、删除、查询 O(long n)</p><p>特点</p><ul><li>key 必须具备比较性</li><li>元素的分布是有顺序的(红黑树)</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><a href="https://orgjinhc.github.io/2020/01/31/AQS/">AQS</a></h3><p>提供了一个框架，作为一个基础类，没有实现任何同步接口，对于大多数依赖于单个原子值来表示状态的同步器，用于实现阻塞锁和相关同步器(信号量、事件等)</p><h4 id="支持两种模式"><a href="#支持两种模式" class="headerlink" title="支持两种模式"></a>支持两种模式</h4><p> 共享：其他线程都可以获取锁<br> 独占：其他线程无法获取锁</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>使用依赖于先进先出(FIFO)等待队列</p><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>子类必须定义更改此状态的受保护方法，并定义该状态在获取或释放此对象时意味着什么。<br>子类应该被定义为非公共的内部助手类，用来实现其外部类的同步属性</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>给定这些，这个类中的其他方法执行所有排队和阻塞机制。</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>子类可以维护其他状态字段，但是只有使用方法{@link #getState}、{@link #setState}和{@link #compareAndSetState}对原子更新的{@code int}值进行同步跟踪</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试 TOP 100</title>
      <link href="/2020/08/30/%E9%9D%A2%E8%AF%95%20TOP%20100/"/>
      <url>/2020/08/30/%E9%9D%A2%E8%AF%95%20TOP%20100/</url>
      
        <content type="html"><![CDATA[<h2 id="面试-TOP-100"><a href="#面试-TOP-100" class="headerlink" title="面试 TOP 100"></a>面试 TOP 100</h2><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h2 id="JAVA-EE"><a href="#JAVA-EE" class="headerlink" title="JAVA EE"></a>JAVA EE</h2><h3 id="JAVA-引用类型"><a href="#JAVA-引用类型" class="headerlink" title="JAVA 引用类型"></a>JAVA 引用类型</h3><ol><li>强：普通的对象。只有发生GC 空间和地址才会被回收。</li><li>软：主动声明对象类型为SoftReference的对象为软引用对象。内存不够才回收</li><li><ul><li>适用场景：缓存</li></ul></li><li>弱：主动声明对象类型为WeakReference的对象为弱饮用对象。只要发生GC 就会回收。</li><li>虚：主动声明对象类型为PhantomReference的对象为虚引用对象，必须结合ReferenceQueue使用，要回收的对象会被加入队列，由GC线程检查队列内应用对象。</li><li><ul><li>使用场景：堆外内存 堆内应用指向堆外地址     nio - zero copy    </li></ul></li></ol><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>定义：线程本地变量副本。当前线程存在一个map容器，容器内以当前 threadLocal对象为key，存放value。</p><p>使用set / get 方法的含义是：通过当前对象去Map 容器里 设置或读取数据</p><p>用法：线程级别共享变量读写隔离 </p><p>原理：</p><p>Java 源码</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token annotation punctuation">@486</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> THREAD_LOCAL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            THREAD_LOCAL<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            THREAD_LOCAL<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">10001000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>THREAD_LOCAL<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">Thread 类 成员变量 threadLocals 非静态 说明 每个Thread 实例 都有一个MapThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span></code></pre><p>THREAD_LOCAL@486 = THREAD_LOCAL.set() / get()  -&gt; Thead【Thread(main,5,main)】 - ThreadLocalMap - Entry&lt;key : ThreadLocal@486 ,value : 目标值&gt;</p><p>THREAD_LOCAL@486 = THREAD_LOCAL.set() / get()  -&gt; Thead【Thread(main - 0 ,5,main)】- ThreadLoc alMap - Entry&lt;key : ThreadLocal@486 ,value : 目标值&gt;</p><p>THREAD_LOCAL@486 = THREAD_LOCAL.set() / get()  -&gt; Thead【Thread(main - 1, 5, main)】- ThreadLocalMap - Entry&lt;key : ThreadLocal@486 ,value : 目标值&gt;</p><p>集合set方法分析 ThreadLocal 结构</p><p>Set()方法源码：</p><pre class=" language-java"><code class="language-java">Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//    new Entry(key【this【@486地址】】, value【目标值】);</span>  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">else</span>  <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Get()方法源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    当前线程实例</span>Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    获取当前线程的ThreaLocalMap实例</span>ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    当前线程的ThreadLocalMap已经实例化</span><span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//    entry -> new Entry(firstKey【threadLocal实例】, firstValue【null】);</span>  <span class="token comment" spellcheck="true">//    this = threadLocal实例</span>  ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//    获取value</span>    T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    初始化线程内部实例ThreadLocalMap</span><span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Entry 扩展WeakReference  </p><pre class=" language-java"><code class="language-java"> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/** The value associated with this ThreadLocal. */</span>     Object value<span class="token punctuation">;</span>     <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//    Entry key 弱引用 ThreadLocal@486</span>       <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>       value <span class="token operator">=</span> v<span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>Entry    为什么这么设计？</p><p>解决内存泄漏问题</p><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h3 id="1-什么是线程-什么是进程"><a href="#1-什么是线程-什么是进程" class="headerlink" title="1.什么是线程/什么是进程"></a>1.什么是线程/什么是进程</h3><h3 id="2-启动线程有几种方式-创建线程有几种方式-那种好"><a href="#2-启动线程有几种方式-创建线程有几种方式-那种好" class="headerlink" title="2.启动线程有几种方式/创建线程有几种方式/那种好"></a>2.启动线程有几种方式/创建线程有几种方式/那种好</h3><h3 id="3-线程状态有几种，分别说一下"><a href="#3-线程状态有几种，分别说一下" class="headerlink" title="3.线程状态有几种，分别说一下"></a>3.线程状态有几种，分别说一下</h3><h3 id="4-sleep-yield-join区别"><a href="#4-sleep-yield-join区别" class="headerlink" title="4.sleep/yield/join区别"></a>4.sleep/yield/join区别</h3><h3 id="5-synchronized关键字，用法，锁对象-锁类-锁方法，锁对象不能使用String常量-Integer-Long"><a href="#5-synchronized关键字，用法，锁对象-锁类-锁方法，锁对象不能使用String常量-Integer-Long" class="headerlink" title="5.synchronized关键字，用法，锁对象/锁类/锁方法，锁对象不能使用String常量/Integer/Long"></a>5.synchronized关键字，用法，锁对象/锁类/锁方法，锁对象不能使用String常量/Integer/Long</h3><h3 id="6-markword相信信息"><a href="#6-markword相信信息" class="headerlink" title="6.markword相信信息"></a>6.markword相信信息</h3><h3 id="7-锁升级过程【无法降级】-无锁态–偏向锁–轻量级锁–自旋锁（10次）–重量级锁"><a href="#7-锁升级过程【无法降级】-无锁态–偏向锁–轻量级锁–自旋锁（10次）–重量级锁" class="headerlink" title="7.锁升级过程【无法降级】  无锁态–偏向锁–轻量级锁–自旋锁（10次）–重量级锁"></a>7.锁升级过程【无法降级】  无锁态–偏向锁–轻量级锁–自旋锁（10次）–重量级锁</h3><h3 id="8-自旋和重量级锁的选择，同步时间长-同步竞争激烈的情况下重量级锁比自旋锁效率更高，因为不占用cpu资源"><a href="#8-自旋和重量级锁的选择，同步时间长-同步竞争激烈的情况下重量级锁比自旋锁效率更高，因为不占用cpu资源" class="headerlink" title="8.自旋和重量级锁的选择，同步时间长/同步竞争激烈的情况下重量级锁比自旋锁效率更高，因为不占用cpu资源"></a>8.自旋和重量级锁的选择，同步时间长/同步竞争激烈的情况下重量级锁比自旋锁效率更高，因为不占用cpu资源</h3><h3 id="9-sync-atomic-longadder性能比较"><a href="#9-sync-atomic-longadder性能比较" class="headerlink" title="9.sync/atomic/longadder性能比较"></a>9.sync/atomic/longadder性能比较</h3><h3 id="10-生产者消费者模型，可见性和原子性问题，需要使用同步容器，volatile并不起作用"><a href="#10-生产者消费者模型，可见性和原子性问题，需要使用同步容器，volatile并不起作用" class="headerlink" title="10.生产者消费者模型，可见性和原子性问题，需要使用同步容器，volatile并不起作用"></a>10.生产者消费者模型，可见性和原子性问题，需要使用同步容器，volatile并不起作用</h3><h3 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h3><ol><li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来<br>是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问<br>题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成<br>了“1A－2B－3A”。<br>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。<br>compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将<br>引用值和标志的值设置为给定的更新值。</li><li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li><li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作<br>时，CAS是无法保证操作的原子性的。因为Unsafe类只对一个变量进行CAS操作</li><li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里<br> 来进行CAS操作。</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>命令</p><p>jinfo：JVM运行相关信息</p><p>jstack：线程栈信息，主要用于 排查 死锁 和 CPU飙高问题</p><p>jstate：</p><p>jmap：JVM 运行 堆内存信息。STW</p><p>dump：导出JVM 运行时堆内存信息。引发Full GC。STW</p><p>通过 JVM 参数，在发生OOM 导出 Dump文件</p><p>分析工具</p><p>​    Java 自带工具 1. jprofiler 2.jconsole 3.jvisulvm</p><pre><code> JHAT、MAT</code></pre><h3 id="1-对象创建过程"><a href="#1-对象创建过程" class="headerlink" title="1.对象创建过程"></a>1.对象创建过程</h3><p>   java：new Object()过程<br>       1.new指令<br>       2.dup指令<br>       3.invoke指令<br>       4.返回引用</p><p>   JVM：java运行时数据区<br>    堆内开辟空间，对象field赋初始值，执行构造方法，返回地址给引用</p><p>   标准答案<br>           1.class loading<br>           2.class linking<br>               2.1 verification：验证文件是否符合JVM规范<br>               2.2 preparation：半初始化，静态变量赋默认值<br>               2.3 resolution：将类/方法/属性的符号引用解析为直接饮用<br>        3.initializing：静态变量赋初始值<br>                前三步：method area内生成类对象，Class类对象 </p><p>​        4.申请对象内存<br>​        5.成员变量赋默认值<br>​        6.调用对象构造方法init<br>​            6.1成员变量顺序赋初始值<br>​            6.2执行构造方法语句，先super()</p><h3 id="2-对象在内存的存储布局"><a href="#2-对象在内存的存储布局" class="headerlink" title="2.对象在内存的存储布局"></a>2.对象在内存的存储布局</h3><p>​    两大类<br>​        普通对象<br>​        数组对象</p><p>对象实例有三部分组成<br>1.对象头<br>    markword<br>    class point<br>2.实例数据<br>3.对齐：占位符（没有其他作用），虚拟机内存管理系统要求对象起始位置必须是 8 的整数倍，实例数据部分没有对齐，则填充（1.是方便CPU进行计算，2.GC更高效的回收）</p><h3 id="3-对象头具体包括什么"><a href="#3-对象头具体包括什么" class="headerlink" title="3.对象头具体包括什么"></a>3.对象头具体包括什么</h3><p>​    markword：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等,它是实现轻量级锁和偏向锁的关</p><pre><code>klass point：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（数组无法制定大小，还需要存储数组长度）</code></pre><h3 id="4-对象怎么定位"><a href="#4-对象怎么定位" class="headerlink" title="4.对象怎么定位"></a>4.对象怎么定位</h3><h3 id="5-对象怎么分配"><a href="#5-对象怎么分配" class="headerlink" title="5.对象怎么分配"></a>5.对象怎么分配</h3><p>​    年轻代中的eden区，s1–s2，老年代</p><h3 id="6-new-Object-在内存中占用多少字节"><a href="#6-new-Object-在内存中占用多少字节" class="headerlink" title="6.new Object()在内存中占用多少字节"></a>6.new Object()在内存中占用多少字节</h3><p>​    markword 8字节<br>​    klass point 开启指针压缩 4字节，未开启指针压缩 8字节<br>​    实例数据 0字节<br>​    对齐 补齐8字节的整数倍     </p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redis-有哪些数据结构类型？"><a href="#redis-有哪些数据结构类型？" class="headerlink" title="redis 有哪些数据结构类型？"></a>redis 有哪些数据结构类型？</h3><ol><li>String<ul><li>字符串：append 、strlength 、 set 、 get 等等</li><li>数值：incr 、 decrby 等等</li><li>位图：setbit key index value(0\1) 、 setcount 、 setop and\or targetKey</li></ul></li><li>List：双向链表实现    </li><li>Hash：hset、hget、hincrby hkey key value、</li><li>Set：集合</li><li>ZSet：有序集合（默认排序），通过 跳表 实现</li></ol><h3 id="redis-底层的数据结构是什么？"><a href="#redis-底层的数据结构是什么？" class="headerlink" title="redis 底层的数据结构是什么？"></a>redis 底层的数据结构是什么？</h3><p>字节数组，对应的就是二进制安全，客户端传递的参数是字节数组，服务端无需加工字节数组。客户端自己保证编码集 </p><h3 id="各种数据类型的使用场景"><a href="#各种数据类型的使用场景" class="headerlink" title="各种数据类型的使用场景"></a>各种数据类型的使用场景</h3><p>String类型中如果是纯数值操作可以应用于 <strong>限流</strong>、<strong>秒杀</strong>、抢购等跟数字有关的场景</p><p>String类型中如果是字符串操作可以应用于 <strong>分布式锁</strong></p><p>String类型中如果是位操作可以应用于 <strong>二进制操作</strong></p><p>List 类型 实现 <strong>栈</strong> <strong>队列</strong> <strong>数组</strong>等操作，<strong>ltrim</strong> 指令的应用</p><p>Hash 类型 <strong>详情页</strong> 、 <strong>用户信息</strong> 、 <strong>聚合</strong></p><p>Set 类型 <strong>集合操作</strong> 、<strong>抽奖</strong> 、<strong>随机事件</strong> 、 <strong>推荐</strong></p><p>ZSet 类型 <strong>排行榜</strong> 、 <strong>Top Ten</strong> 、 <strong>动态分页</strong></p><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h3><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><h3 id="Redis-如何做持久化的？"><a href="#Redis-如何做持久化的？" class="headerlink" title="Redis 如何做持久化的？"></a>Redis 如何做持久化的？</h3><h3 id="Pipeline-有什么好处，为什么要用pipeline？"><a href="#Pipeline-有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline 有什么好处，为什么要用pipeline？"></a>Pipeline 有什么好处，为什么要用pipeline？</h3><h3 id="redis-的线程io模型是什么？"><a href="#redis-的线程io模型是什么？" class="headerlink" title="redis 的线程io模型是什么？"></a>redis 的线程io模型是什么？</h3><p>计算 worker thread：串行 计算</p><p>通信 io threads：通过epoll，实现高性能的 read / write 操作</p><h3 id="redis-过期键的删除策略有哪些？"><a href="#redis-过期键的删除策略有哪些？" class="headerlink" title="redis 过期键的删除策略有哪些？"></a>redis 过期键的删除策略有哪些？</h3><h3 id="redis-的序列化协议是什么？有什么优势"><a href="#redis-的序列化协议是什么？有什么优势" class="headerlink" title="redis 的序列化协议是什么？有什么优势"></a>redis 的序列化协议是什么？有什么优势</h3><h3 id="redis-有哪些内存淘汰策略？"><a href="#redis-有哪些内存淘汰策略？" class="headerlink" title="redis 有哪些内存淘汰策略？"></a>redis 有哪些内存淘汰策略？</h3><h3 id="redis-惰性删除的实现原理？"><a href="#redis-惰性删除的实现原理？" class="headerlink" title="redis 惰性删除的实现原理？"></a>redis 惰性删除的实现原理？</h3><h3 id="redis-定期删除的实现原理？"><a href="#redis-定期删除的实现原理？" class="headerlink" title="redis 定期删除的实现原理？"></a>redis 定期删除的实现原理？</h3><h3 id="redis-重启后如何加载持久化数据？"><a href="#redis-重启后如何加载持久化数据？" class="headerlink" title="redis 重启后如何加载持久化数据？"></a>redis 重启后如何加载持久化数据？</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring-internal-face</title>
      <link href="/2020/08/16/spring-internal-face/"/>
      <url>/2020/08/16/spring-internal-face/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是Spring-Framework？"><a href="#1-什么是Spring-Framework？" class="headerlink" title="1.什么是Spring Framework？"></a>1.什么是Spring Framework？</h3><p>​    Spring Framework是一个基于java语言开发的应用于java企业应用<br>​    同时Spring Framework提供一个可编程和配置的方式进行项目整合<br>​    最重要的是Spring Framework提供了非常多的特性和编程模型，模块化的技术让使用者可以按需使用。</p><h3 id="2-spring-Framework有哪些核心模块？"><a href="#2-spring-Framework有哪些核心模块？" class="headerlink" title="2.spring Framework有哪些核心模块？"></a>2.spring Framework有哪些核心模块？</h3><p>​    spring-core     Spring基础API模块，资源管理、范型处理<br>​    spring-context    事件驱动（ApplicationContextEvent）、注解驱动（@Componet、@ComponentScan）、模块驱动（@Enable*）<br>​    spring-beans    Spring Bean相关，依赖查找、依赖注入<br>​    spring-AOP        面向切面处理，动态代理、字节码提升<br>​    spirng-expression    spring表达式        </p><h3 id="3-Spring-Framework的优势和不足？"><a href="#3-Spring-Framework的优势和不足？" class="headerlink" title="3.Spring Framework的优势和不足？"></a>3.Spring Framework的优势和不足？</h3><p>​    优势：<br>​        1.项目构建：按需依赖所需技术，按约定进行xml或yml方式配置<br>​        2.核心特性：IOC、AOP、数据绑定、类型转换、数据校验、国际化、资源管理、国际化等等<br>​        3.模块化设计：将功能按模块划分，比如项目里需要事物的时候，可以引入spring-tx这个模块。<br>这样的目的是不需要将完整的spring框架依赖到项目里，达到一个最小依赖化原则，同时减少类冲突<br>​        4.技术整合：将Java规范相关的技术全部整合到spring内，例如：JMX、Email、Task、RMI等<br>​        5.编程模型：面向对象、面向切面、面向元数据、面向模块、面向函数<br>​        6.框架生态</p><h2 id="IoC-相关问题"><a href="#IoC-相关问题" class="headerlink" title="IoC 相关问题"></a>IoC 相关问题</h2><h3 id="什么是IoC？什么是Spring-IoC容器？"><a href="#什么是IoC？什么是Spring-IoC容器？" class="headerlink" title="什么是IoC？什么是Spring IoC容器？"></a>什么是IoC？什么是Spring IoC容器？</h3><p>​    IoC<br>​    简单来说，IoC就是反转控制，主要就是依赖处理，包含依赖查找和依赖注入的实现<br>​    轻量级实现包含Java SE的Java Beans、Java EE的Servlet、开源框架的Spring Framework都是Ioc的实现。</p><p>Spring IoC 实现了IoC原则，又称为DI<br>依赖查找<br>依赖注入<br>配置元信息<br>bean生命周期管理</p><h3 id="Spring-作为IoC容器有什么优势？列举IOC（传统IoC或Spring-IoC）的一些好处？"><a href="#Spring-作为IoC容器有什么优势？列举IOC（传统IoC或Spring-IoC）的一些好处？" class="headerlink" title="Spring 作为IoC容器有什么优势？列举IOC（传统IoC或Spring IoC）的一些好处？"></a>Spring 作为IoC容器有什么优势？列举IOC（传统IoC或Spring IoC）的一些好处？</h3><p>简单来说：依赖管理、Bean生命周期统一管理、容器相关配置（上下文信息）。并且最关键的是轻量级实现</p><ol><li>容器可以管理代码的运行，生命周期</li><li>快速启动</li><li>不需要特殊的配置</li><li>不过度依赖API</li></ol><p>系统复杂来说如下：</p><ol><li>典型的IoC管理，就是依赖管理，包含依赖查找和依赖注入。管理Bean及其关系和生命周期</li><li>降低耦合性</li><li>AOP抽象</li><li>事物抽象</li><li>事件机制</li><li>SPI扩展</li><li>第三方整合</li></ol><h3 id="Spring-IoC容器启动？"><a href="#Spring-IoC容器启动？" class="headerlink" title="Spring IoC容器启动？"></a>Spring IoC容器启动？</h3><p>​    1.创建BeanFactory并且进行初步初始化,加入一些内建bean对象或bean依赖以及一些内建非bean依赖<br>​    2.beanFactory扩展点<br>​    3.bean的扩展<br>​    4.其他特性</p><h3 id="SpringIoC启动做了哪些准备？"><a href="#SpringIoC启动做了哪些准备？" class="headerlink" title="SpringIoC启动做了哪些准备？"></a>SpringIoC启动做了哪些准备？</h3><ol><li>IoC配置元信息的读取和解析</li><li>IoC容器生命周期</li><li>Spring事件发布</li><li>国际化处理</li></ol><h3 id="SpringIOC的实现机制？"><a href="#SpringIOC的实现机制？" class="headerlink" title="SpringIOC的实现机制？"></a>SpringIOC的实现机制？</h3><p>依赖管理</p><ol><li>依赖注入</li><li>依赖查找</li></ol><p>想要完成依赖管理就需要各种底层类的支持，例如：容器类或上下文类。同时又需要给出Bean的元信息，也就是容器的配置信息才可以完成IoC的职责</p><h2 id="依赖注入和依赖查找相关"><a href="#依赖注入和依赖查找相关" class="headerlink" title="依赖注入和依赖查找相关"></a>依赖注入和依赖查找相关</h2><h3 id="请介绍下常用的BeanFactory容器？spring中有多少种（职责、个数-）ioc容器？"><a href="#请介绍下常用的BeanFactory容器？spring中有多少种（职责、个数-）ioc容器？" class="headerlink" title="请介绍下常用的BeanFactory容器？spring中有多少种（职责、个数 ）ioc容器？"></a>请介绍下常用的BeanFactory容器？spring中有多少种（职责、个数 ）ioc容器？</h3><h4 id="单一类型：BeanFactory"><a href="#单一类型：BeanFactory" class="headerlink" title="单一类型：BeanFactory"></a>单一类型：BeanFactory</h4><h4 id="集合类型：ListableBeanFactory"><a href="#集合类型：ListableBeanFactory" class="headerlink" title="集合类型：ListableBeanFactory"></a>集合类型：ListableBeanFactory</h4><h4 id="层级类型：HierarchicalBeanFactory"><a href="#层级类型：HierarchicalBeanFactory" class="headerlink" title="层级类型：HierarchicalBeanFactory"></a>层级类型：HierarchicalBeanFactory</h4><h4 id="扩展组合类型，除非启动Spring-容器指定具体的实现类，否则都是通过：ConfigurableListFactoryBean"><a href="#扩展组合类型，除非启动Spring-容器指定具体的实现类，否则都是通过：ConfigurableListFactoryBean" class="headerlink" title="扩展组合类型，除非启动Spring 容器指定具体的实现类，否则都是通过：ConfigurableListFactoryBean"></a>扩展组合类型，除非启动Spring 容器指定具体的实现类，否则都是通过：ConfigurableListFactoryBean</h4><h4 id="兜底方案：DefaultListableBeanFactory"><a href="#兜底方案：DefaultListableBeanFactory" class="headerlink" title="兜底方案：DefaultListableBeanFactory"></a>兜底方案：DefaultListableBeanFactory</h4><h3 id="依赖来源"><a href="#依赖来源" class="headerlink" title="依赖来源"></a>依赖来源</h3><ol><li>BeanDefinition</li><li>单例对象</li><li>ResolveDependency</li><li>外部化配置</li></ol><h3 id="依赖注入和依赖查找的来源是否相同"><a href="#依赖注入和依赖查找的来源是否相同" class="headerlink" title="依赖注入和依赖查找的来源是否相同"></a>依赖注入和依赖查找的来源是否相同</h3><p>依赖注入</p><ol><li>ResolveDependency</li><li>@Value</li></ol><p>依赖查找</p><ol><li>BeanDefinition</li><li>单例对象</li></ol><h3 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h3><p>手动或自动依赖绑定的方式，无需依赖特定的容器和API。但是依赖的来源需要我们进行配置或约定</p><h3 id="依赖查找和依赖注入的区别？"><a href="#依赖查找和依赖注入的区别？" class="headerlink" title="依赖查找和依赖注入的区别？"></a>依赖查找和依赖注入的区别？</h3><p>​    依赖查找（getBean）<br>​        主动或手动的依赖查找方式，通常需要依赖容器或API实现。</p><p>​    依赖注入（ResolverDependency）<br>​        手动或自动依赖绑定的方式，无需依赖特定的容器和API。但是依赖的来源需要我们进行配置或约定<br>​    数据的来源以及他的初始化相关的生命周期是怎么去管理的</p><h3 id="可以有多少种方式完成依赖注入？你偏好构造器还是Setter方式进行注入？"><a href="#可以有多少种方式完成依赖注入？你偏好构造器还是Setter方式进行注入？" class="headerlink" title="可以有多少种方式完成依赖注入？你偏好构造器还是Setter方式进行注入？"></a>可以有多少种方式完成依赖注入？你偏好构造器还是Setter方式进行注入？</h3><ol><li>构造器：少依赖、强制依赖</li><li>setter：多依赖、非强制依赖</li><li>Filed：便利性，注解方式</li><li>Method：@Bean 声明类</li><li>CallBack</li></ol><p>优劣点：</p><p>Set无法保证顺序，顺序是bean定义的顺序，构造器可以保证顺序</p><p>Set本身就是文档，构造器如果参数过多会导致不可读</p><p>线程安全角度或可变性的角度来说，构造器注入可以完成。set无法做到</p><h3 id="8-BeanFactory和FactoryBean的区别-或-ObjectFactory和BeanFactory的区别？"><a href="#8-BeanFactory和FactoryBean的区别-或-ObjectFactory和BeanFactory的区别？" class="headerlink" title="8.BeanFactory和FactoryBean的区别 或 ObjectFactory和BeanFactory的区别？"></a>8.BeanFactory和FactoryBean的区别 或 ObjectFactory和BeanFactory的区别？</h3><p>​    BeanFactory：IoC容器底层实现，提供了提供单一类型、集合类型、层次性等多种功能依赖查找能力。并存储了Bean的配置以及它的Bean的一个管理对象<br>​    FactoryBean：创建Bean的一种方式【不是一个简单的bean或不是一个我们系统内的bean】，帮助我们实现复杂的初始化逻辑。举例：getObject方法被容器调用，getObjectType方法决定那个对象去调用getObject</p><p>​    ObjectFactory 和 BeanFactory都具备依赖查找的能力</p><p>不过ObjectFactory仅关注一个或一种类型的Bean依赖查找，并且自身不具备依赖查找的能力，能力是由BeanFactory提供</p><p>ObjectFactory 需要 BeanFactory 能力去实现依赖查找的体现 源码分析：</p><p>ObjectFactoryCreatingFactoryBean实现类，他是一个factoryBean所以需要获取type    -&lt;    type就是一个ObjectFactory -&lt; createInstance就去获取BeanFactory 并 new TargetBeanObjectFactory 组合 BeanFactory 最终 getBean 方法通过组合BeanFactory的能力去获取Bean</p><h3 id="BeanFactory-getBean操作是否线程安全？"><a href="#BeanFactory-getBean操作是否线程安全？" class="headerlink" title="BeanFactory.getBean操作是否线程安全？"></a>BeanFactory.getBean操作是否线程安全？</h3><p>是线程安全的，操作过程中会增加互斥锁</p><h3 id="12-IOC和DI有什么区别？"><a href="#12-IOC和DI有什么区别？" class="headerlink" title="12.IOC和DI有什么区别？"></a>12.IOC和DI有什么区别？</h3><p>todo</p><h3 id="2-请介绍下常用的ApplicationContext容器？"><a href="#2-请介绍下常用的ApplicationContext容器？" class="headerlink" title="2.请介绍下常用的ApplicationContext容器？"></a>2.请介绍下常用的ApplicationContext容器？</h3><p>ClassPathXmlApplicationContext </p><p>FileSystemXmlApplicationContext</p><p> AnnotationConfigApplicationContext</p><p>GenericApplicationContext</p><p>以上各种实现类都各司其职</p><p>总结：BeanFactory:是底层IoC容器的实现，存储了Bean的元配置以及它的Bean的一个管理对象<br>ApplicationContext:是组合BeanFactory通过代理的方式来实现IoC功能,并提供更多企业级特性和功能</p><h3 id="什么是spring-bean？"><a href="#什么是spring-bean？" class="headerlink" title="什么是spring bean？"></a>什么是spring bean？</h3><ol><li>Bean Definition</li><li>Bean 行为，如：作用域、生命周期、自动绑定</li><li>Bean 合作，其他bean的依赖关系</li></ol><h3 id="什么是Java-Bean？"><a href="#什么是Java-Bean？" class="headerlink" title="什么是Java Bean？"></a>什么是Java Bean？</h3><p>​    可以简单的理解为POJO，如果POJO只有setter、getter操作那也可以称之为贫血模型。类里没有复杂的业务操作</p><pre class=" language-java"><code class="language-java">setter ： 可写方法 <span class="token operator">=</span> readablegetter ： 可读方法 <span class="token operator">=</span> writeableJava Bean包含类的元信息和类操作反射 ： Filed<span class="token operator">/</span>Method<span class="token operator">/</span>Construction                                                    Java Bean              和                      POJO  Filed            propertyDescriptor                                              name age                       String name                    propertyType          Integer                    Method                                             readMethod                     getName                                            writeMethod                    setName  PropertyEditor实现类型转换和配置          </code></pre><h3 id="spring-bean-有哪些配置方式？"><a href="#spring-bean-有哪些配置方式？" class="headerlink" title="spring bean 有哪些配置方式？"></a>spring bean 有哪些配置方式？</h3><ol><li>XMl</li><li>注解</li><li>Java API</li></ol><h3 id="spring支持几种Bean-Scope？"><a href="#spring支持几种Bean-Scope？" class="headerlink" title="spring支持几种Bean Scope？"></a>spring支持几种Bean Scope？</h3><h3 id="spring-bean-在容器的生命周期是什么样的？"><a href="#spring-bean-在容器的生命周期是什么样的？" class="headerlink" title="spring bean 在容器的生命周期是什么样的？"></a>spring bean 在容器的生命周期是什么样的？</h3><h3 id="什么是-Spring-的内部-bean？"><a href="#什么是-Spring-的内部-bean？" class="headerlink" title="什么是 Spring 的内部 bean？"></a>什么是 Spring 的内部 bean？</h3><p>依赖来源</p><ol><li><p>配置Bean或自定义Bean：我们自定义的一些配置文件或注解</p></li><li><p>容器内建Bean：environment对象</p></li><li><p>内建依赖：BeanFactory，我们一般启动应用后会使用ApplicationContext这个Spring上下文对象进行容器管理，因为它提供了一些我们需要的特性。但是IoC的实现是通过BeanFactory实现，所以Spring就在启动容器后帮我们把BeanFactory组合到Spring上下文中。这种内部调整方式称为内建依赖</p></li></ol><h3 id="什么是-Spring-装配"><a href="#什么是-Spring-装配" class="headerlink" title="什么是 Spring 装配"></a>什么是 Spring 装配</h3><h3 id="解释什么叫延迟加载？"><a href="#解释什么叫延迟加载？" class="headerlink" title="解释什么叫延迟加载？"></a>解释什么叫延迟加载？</h3><h3 id="Spring-框架中的单例-Bean-是线程安全的么？"><a href="#Spring-框架中的单例-Bean-是线程安全的么？" class="headerlink" title="Spring 框架中的单例 Bean 是线程安全的么？"></a>Spring 框架中的单例 Bean 是线程安全的么？</h3><h3 id="Spring-Bean-怎么解决循环依赖的问题？"><a href="#Spring-Bean-怎么解决循环依赖的问题？" class="headerlink" title="Spring Bean 怎么解决循环依赖的问题？"></a>Spring Bean 怎么解决循环依赖的问题？</h3><h3 id="Component-Controller-Repository-Service-有何区别？"><a href="#Component-Controller-Repository-Service-有何区别？" class="headerlink" title="@Component, @Controller, @Repository, @Service 有何区别？"></a>@Component, @Controller, @Repository, @Service 有何区别？</h3><h3 id="关于-JoinPoint-和-PointCut-的区别？"><a href="#关于-JoinPoint-和-PointCut-的区别？" class="headerlink" title="关于 JoinPoint 和 PointCut 的区别？"></a>关于 JoinPoint 和 PointCut 的区别？</h3><h3 id="Spring-AOP-and-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-and-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP and AspectJ AOP 有什么区别？"></a>Spring AOP and AspectJ AOP 有什么区别？</h3><h3 id="什么是事务的隔离级别？分成哪些隔离级别？"><a href="#什么是事务的隔离级别？分成哪些隔离级别？" class="headerlink" title="什么是事务的隔离级别？分成哪些隔离级别？"></a>什么是事务的隔离级别？分成哪些隔离级别？</h3><h3 id="什么是事务的传播级别？分成哪些传播级别？"><a href="#什么是事务的传播级别？分成哪些传播级别？" class="headerlink" title="什么是事务的传播级别？分成哪些传播级别？"></a>什么是事务的传播级别？分成哪些传播级别？</h3><h3 id="Bean初始化顺序"><a href="#Bean初始化顺序" class="headerlink" title="Bean初始化顺序"></a>Bean初始化顺序</h3><ol><li>@PostConstrcut</li><li>实现</li></ol><h3 id="BeansException异常"><a href="#BeansException异常" class="headerlink" title="BeansException异常"></a>BeansException异常</h3><ol><li>BeanNoSuchException</li><li>BeanUniqueException</li><li>BeanCreationException</li><li>BeanInstanceException</li><li>BeanDefinitionStoreException</li></ol><h3 id="依赖注入能否作用于静态属性或类？"><a href="#依赖注入能否作用于静态属性或类？" class="headerlink" title="依赖注入能否作用于静态属性或类？"></a>依赖注入能否作用于静态属性或类？</h3><p>@Autowired 会忽略static</p><h3 id="Spring-Bean初始化扩展点"><a href="#Spring-Bean初始化扩展点" class="headerlink" title="Spring Bean初始化扩展点"></a>Spring Bean初始化扩展点</h3><p>AutoWiredAnnotationBeanPostProcess类  处理 @AutoWired 和 @Value注解</p><ol><li>megerBeanDefinition  -&gt;  构建元数据</li><li>beanPostProcessProperties  -&gt;  完成注入</li></ol><p>先获取当前bean 反射获取 需要注入的 filed ，static filed 和 static method 不支持反射注入</p><p>先把元信息进行注入 执行 postProcessProperties -&gt; instance set 方法 完成注入</p><h4 id="Autowired-和-Value-【外部化配置作为注入来源】-区别？"><a href="#Autowired-和-Value-【外部化配置作为注入来源】-区别？" class="headerlink" title="@Autowired 和 @Value 【外部化配置作为注入来源】 区别？"></a>@Autowired 和 @Value 【外部化配置作为注入来源】 区别？</h4><p>autowire注解包含 value、qualifier两个注解</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES</title>
      <link href="/2020/08/11/ES/"/>
      <url>/2020/08/11/ES/</url>
      
        <content type="html"><![CDATA[<h1 id="从零开始搞ES"><a href="#从零开始搞ES" class="headerlink" title="从零开始搞ES"></a>从零开始搞ES</h1><h2 id="一、为什么要学ES？"><a href="#一、为什么要学ES？" class="headerlink" title="一、为什么要学ES？"></a>一、为什么要学ES？</h2><h3 id="1-工作中遇到的问题和解决办法"><a href="#1-工作中遇到的问题和解决办法" class="headerlink" title="1.工作中遇到的问题和解决办法"></a>1.工作中遇到的问题和解决办法</h3><h3 id="海量数据搜索"><a href="#海量数据搜索" class="headerlink" title="海量数据搜索"></a>海量数据搜索</h3><p>设备监控</p><p>植保</p><h2 id="二、如何学习ES？"><a href="#二、如何学习ES？" class="headerlink" title="二、如何学习ES？"></a>二、如何学习ES？</h2><h3 id="1-看书"><a href="#1-看书" class="headerlink" title="1.看书"></a>1.看书</h3><h3 id="2-看博客"><a href="#2-看博客" class="headerlink" title="2.看博客"></a>2.看博客</h3><h3 id="3-看视频"><a href="#3-看视频" class="headerlink" title="3.看视频"></a>3.看视频</h3><h2 id="二、ES是什么？"><a href="#二、ES是什么？" class="headerlink" title="二、ES是什么？"></a>二、ES是什么？</h2><h3 id="1-什么是搜索？"><a href="#1-什么是搜索？" class="headerlink" title="1.什么是搜索？"></a>1.什么是搜索？</h3><p>通过一个<strong>关键词</strong>或<strong>一段描述</strong>，得到<strong>你想要的</strong>（相关度高）结果</p><h3 id="2-如何实现搜索？"><a href="#2-如何实现搜索？" class="headerlink" title="2.如何实现搜索？"></a>2.如何实现搜索？</h3><p>关系型数据库：只要使用模糊查询，不走索引，结果不准确，性能低</p><p>问题：全表扫描、性能差、不可靠、结果相关度低</p><p>Tips：MySQL如何实现搜索</p><p>Reference：模糊查询</p><h4 id="3-Solar、Lucence、ES-诸多搜索解决方案如何选？"><a href="#3-Solar、Lucence、ES-诸多搜索解决方案如何选？" class="headerlink" title="3.Solar、Lucence、ES 诸多搜索解决方案如何选？"></a>3.Solar、Lucence、ES 诸多搜索解决方案如何选？</h4><ul><li><p>Lucence：jar包（帮我们创建倒排索引，提供了负载的API接口）存在单点问题</p><p>缺点：单点问题，节点一旦宕机，数据丢失，可用性差。自己维护索引和负载。</p></li><li><p>ES：基于Lucence，封装Lucence。提供集群管理</p></li></ul><p>Tips：单点和集群</p><p>Reference：单点的问题，集群的意义</p><h3 id="4-倒排索引、全文检索？"><a href="#4-倒排索引、全文检索？" class="headerlink" title="4.倒排索引、全文检索？"></a>4.倒排索引、全文检索？</h3><h4 id="a-倒排索引：基于document实现"><a href="#a-倒排索引：基于document实现" class="headerlink" title="a.倒排索引：基于document实现"></a>a.倒排索引：基于document实现</h4><ul><li>包含这个关键词的doc list</li><li>关键词在每个doc中出现的次数 TF term frequency 词频</li><li>关键词在整个索引中出现的次数 IDF</li></ul><h3 id="5-Elastic-search：分布式、高性能、高可用、可伸缩、易用性。但是-不等于-搜索引擎"><a href="#5-Elastic-search：分布式、高性能、高可用、可伸缩、易用性。但是-不等于-搜索引擎" class="headerlink" title="5.Elastic search：分布式、高性能、高可用、可伸缩、易用性。但是 不等于 搜索引擎"></a>5.Elastic search：分布式、高性能、高可用、可伸缩、易用性。但是 不等于 搜索引擎</h3><h4 id="a-分布式的-搜索、存储-和-数据分析-引擎"><a href="#a-分布式的-搜索、存储-和-数据分析-引擎" class="headerlink" title="a.分布式的 搜索、存储 和 数据分析 引擎"></a>a.分布式的 搜索、存储 和 数据分析 引擎</h4><h4 id="b-优点"><a href="#b-优点" class="headerlink" title="b.优点"></a>b.优点</h4><ul><li>面向开发者友好，屏蔽了 Lucene 的复杂特性</li><li>开箱即用，门槛低，上手简单</li><li>集群发现</li><li>自动维护数据在多个节点上的建立</li><li>请求的负载均衡</li><li>自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</li><li>ES 基于Lucene 提供了很多高级的功能：复合查询、聚合分析、基于地理位置</li><li>可以构建几百台服务器的大型分布式集群，处理PB级别数据</li></ul><h4 id="c-应用领域"><a href="#c-应用领域" class="headerlink" title="c.应用领域"></a>c.应用领域</h4><ul><li>百度全文搜索、高亮、搜索推荐</li><li>用户行为日志，点击、浏览、搜藏、评论</li><li>BI：数据分析、数据挖掘统计</li><li>GitHub：代码托管平台</li><li>ELK：Elasticsearch数据存储、Logstash日志采集、Kibana可视化</li></ul><h3 id="6-ES核心概念"><a href="#6-ES核心概念" class="headerlink" title="6.ES核心概念"></a>6.ES核心概念</h3><ul><li><p>Cluster（集群）：每个集群至少包含两个节点</p></li><li><p>Node（节点）：集群中的节点，一个节点不代表一台服务器</p><ul><li><p>Role(角色)</p><ul><li>Master：主节点</li><li>voting：投票</li><li>coordinating：协调</li></ul></li><li><p>Type(类型)</p><ul><li>Master - eligible node(候选节点)：参与容错选主</li><li>Data Node(数据节点)：存储数据</li></ul></li></ul></li><li><p>Shard（分片，官网推荐默认大小20GB）：是一个逻辑概念，就是将数据按照指定规则从一个存储设备分散到多个存储设备</p><ul><li>Primary Shard：主分片，提供高扩展，可伸缩特性</li><li>Replica Shard：副本分片，提供高可用、高性能、高吞吐</li><li>一个index包含多个Shard，默认5P，默认每个P分配一个R，P的数据在创建索引的时候设置，如果想修改，需要重建索引。P和S不能存在同一个机器上</li><li>每个Shard都是一个Lucene实例，有完整的创建索引的处理请求能力。</li><li>ES 会自动在 nodes 上为我们 Shard 做负载均衡</li></ul></li><li><p>Index（索引）：类比MySQL的库概念。一类相同或者类似的doc</p></li><li><p>Type（类型）：类比MySQL的表概念。逻辑上的数据分类。</p></li><li><p>Document（文档）：类比MySQL的行概念。ES 最小的数据单元，JSON格式</p></li><li><p>Field（列）：类比MySql里的列概念。与index和type一起，可以定位一个doc</p></li></ul><h3 id="7-ES的容错机制以及如何实现高可用"><a href="#7-ES的容错机制以及如何实现高可用" class="headerlink" title="7.ES的容错机制以及如何实现高可用"></a>7.ES的容错机制以及如何实现高可用</h3><h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><ol><li><p>Master 选举</p><p>当Master节点宕机，ES会在剩下的节点</p></li><li><p>Replica 容错</p></li><li><p>重启故障机</p></li><li><p>数据恢复</p></li></ol><h3 id="8-集群健康值检查"><a href="#8-集群健康值检查" class="headerlink" title="8.集群健康值检查"></a>8.集群健康值检查</h3><h2 id="三、上手开始搞"><a href="#三、上手开始搞" class="headerlink" title="三、上手开始搞"></a>三、上手开始搞</h2><h3 id="1-环境相关："><a href="#1-环境相关：" class="headerlink" title="1.环境相关："></a>1.环境相关：</h3><ul><li>JDK</li><li><a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">ES</a></li><li>Kibanna</li><li><a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">Elastic search - head</a></li></ul><h3 id="2-集群健康检查"><a href="#2-集群健康检查" class="headerlink" title="2.集群健康检查"></a>2.集群健康检查</h3><h4 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h4><ul><li>Green：所有 ps 和 rs 都是 active，集群很健康</li><li>Yellow：至少一个 rs 不是 active，但是数据仍然是完整的</li><li>Red：至少一个 ps 为不可用状态，数据不完整，集群不可用</li></ul><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li>_cat/health?v</li><li>GET /_cat/indices?v</li></ul><h3 id="3-CRUD开始搞"><a href="#3-CRUD开始搞" class="headerlink" title="3.CRUD开始搞"></a>3.CRUD开始搞</h3><ul><li><p>创建索引</p><p>PUT/索引?Pretty</p></li><li><p>创建数据</p><p>PUT /product/_doc/1<br>{<br>  “name”:”iphone12 Pro Max”,<br>  “price”: 10999<br>}</p></li><li><p>查询数据</p><p>GET /product/_doc/1</p></li><li><p>全量替换</p><p>PUT /product/_doc/1<br>{<br>  “name”:”iphone12 Pro Max”,<br>  “price”: 13999<br>}</p></li><li><p>部分更新</p><p>POST /product/_doc/1/_update<br>{<br>  “doc”:{</p><pre><code>&quot;price&quot;: 14999</code></pre><p>  }<br>}</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集群架构</title>
      <link href="/2020/08/08/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/"/>
      <url>/2020/08/08/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h2><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol><li>进程模型</li><li>Worker抢占机制</li><li>事件处理</li><li>conf配置结构</li><li>静态资源服务器</li><li>负载均衡<ul><li>轮询</li><li>加权轮询</li><li>ipHash</li><li>一致性hash</li><li>urlHash</li><li>least_connection</li></ul></li><li><ul><li>四层：ip+port</li><li><ul><li>F5硬件负载</li><li>LVS</li><li>Haproxy</li></ul></li><li>七层：应用层，http协议</li><li><ul><li>Nginx</li><li>Haproxy</li><li>apache</li></ul></li></ul></li><li></li></ol><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><h3 id="跨域问题【CORS】"><a href="#跨域问题【CORS】" class="headerlink" title="跨域问题【CORS】"></a>跨域问题【CORS】</h3><h3 id="静态资源防盗链"><a href="#静态资源防盗链" class="headerlink" title="静态资源防盗链"></a>静态资源防盗链</h3><h3 id="JMeter"><a href="#JMeter" class="headerlink" title="JMeter"></a>JMeter</h3><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><ol><li>分布式</li><li>前后端解耦</li><li>静态归nginx</li><li>接口服务化</li></ol><h3 id="Nginx-HA"><a href="#Nginx-HA" class="headerlink" title="Nginx HA"></a>Nginx HA</h3><p>主备</p><p>VRRP协议：虚拟路由冗余协议</p><p>VIP</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol><li>异步解耦</li><li>一致性</li><li>服务拆分</li><li>分布式中间件</li><li>容错高可用</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>架构师</title>
      <link href="/2020/08/08/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
      <url>/2020/08/08/%E6%9E%B6%E6%9E%84%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<p>时间4个月<br>目标：架构师 T型人才 先广度 在深度<br>步骤1:3高<br>步骤2:基础<br>资源：视频+输出</p><h2 id="1-单体应用开发"><a href="#1-单体应用开发" class="headerlink" title="1.单体应用开发"></a>1.单体应用开发</h2><p>Spring事物传播行为</p><pre><code>当前存在事物，使用当前事物。如果没事物区别如下required：自己新建一个事物supports：不使用事物mandatory：抛异常required_new：无论当前是否存在事物，自己都去新建事物not_supported：无论当前是否存在事物，自己都不使用事物never：存在事物，抛异常nested：父子事物互相影响，区别就是父事物可以捕获子事物异常，类似savepoint</code></pre><p>Result重新封装    </p><p>实体<br>    pojo<br>    BO - 从前端封装数据到业务逻辑层<br>    VO - 从数据访问层封装数据到展示层<br>    Condition - BO转换数据为condition，传递到事物层</p><p>Resutful - BO 用户信息脱敏，统一使用hibernate-validator做验证，<br>condition通过Aop继续做统一验证</p><p>日志级别 - 由高到低，只能看到低于自己的级别<br>    debug<br>    info<br>    warn<br>    error</p><p>AOP<br>    前置：方法调用前<br>    后置：方法正常调用后<br>    环绕：方法调用前和调用后，分别通知<br>    异常：方法调用过程发生异常<br>    最终：方法调用后</p><p>cron.qqe2.com    </p><p>控制层统一验证器<br>    hibernate-validator</p><p>注解原理<br>spring如何支持注解<br>各种注解原理</p><p>文件上传<br>    pathPrefix + path + fileName + suffix<br>    服务端进行文件格式过滤 - 漏洞攻击<br>    文件大小限制 - 系统优化</p><h3 id="2-部署"><a href="#2-部署" class="headerlink" title="2.部署"></a>2.部署</h3><h4 id="1-服务器-或-本地虚拟机"><a href="#1-服务器-或-本地虚拟机" class="headerlink" title="1.服务器 或 本地虚拟机"></a>1.服务器 或 本地虚拟机</h4><h5 id="服务器选择"><a href="#服务器选择" class="headerlink" title="服务器选择"></a>服务器选择</h5><p>公司共有或私有云，三方公有云</p><p>安全相关</p><p>​    端口号</p><p>​        22：SSH</p><p>​        80：http</p><p>​        443：https</p><p>​        3389：windows远程登录</p><h4 id="2-Linux系统基础"><a href="#2-Linux系统基础" class="headerlink" title="2.Linux系统基础"></a>2.Linux系统基础</h4><h5 id="3-多环境部署-profile"><a href="#3-多环境部署-profile" class="headerlink" title="3.多环境部署 - profile"></a>3.多环境部署 - profile</h5><ol><li>开发环境 dev</li><li>测试环境 test</li><li>语法环境 pre</li><li>生产环境 prod</li></ol><p>多环境配置梳理</p><p>Tomcat 部署门户</p><p>Tomcat 部署农场客户端</p><h4 id="打包方式"><a href="#打包方式" class="headerlink" title="打包方式"></a>打包方式</h4><ol><li>Jar：服务化，微服务</li><li>War：应用程序概念</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO模型</title>
      <link href="/2020/07/31/IO%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/07/31/IO%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><h3 id="一、单机最大连接能到多少？"><a href="#一、单机最大连接能到多少？" class="headerlink" title="一、单机最大连接能到多少？"></a>一、单机最大连接能到多少？</h3><p>环境、配置、模型、机器配置的不同连接不同，可以具体查看相应配置</p><p>Linux proc/sys/dfs/epoll/max_user_watches</p><hr><h3 id="二、多路复用器解决什么问题"><a href="#二、多路复用器解决什么问题" class="headerlink" title="二、多路复用器解决什么问题?"></a>二、多路复用器解决什么问题?</h3><p>1.一次系统调用，完成所有IO状态的遍历，减少了用户态-内核态的系统调用，减少cpu时间和资源的浪费，提供系统性能<br>2.解决IO状态问题，并没有解决IO读写问题，都是同步去r/w</p><hr><h3 id="三、select、poll、epoll都是多路复用器，区别是什么？为什么有了select和poll还需要epoll？"><a href="#三、select、poll、epoll都是多路复用器，区别是什么？为什么有了select和poll还需要epoll？" class="headerlink" title="三、select、poll、epoll都是多路复用器，区别是什么？为什么有了select和poll还需要epoll？"></a>三、select、poll、epoll都是多路复用器，区别是什么？为什么有了select和poll还需要epoll？</h3><p>1.select有fd限制默认1024</p><p>2.poll无fd限制</p><p>3.以上两种都是由用户空间一次传递所有fd，由内核空间去循环遍历所有的fd，判断IO状态。epoll无需传递fd，首先内核空间开辟一个存储fd的空间，每个通过epoll的fd都会注册到kernel开辟的空间里，由kernel接管，每次accept、recv系统调用都是查看是否有准备的fd，如果有就绪态的fd一次性拉回到用户空间</p><hr><h3 id="四、IO状态"><a href="#四、IO状态" class="headerlink" title="四、IO状态"></a>四、IO状态</h3><ol><li>LINSTEN</li><li>ESTABLISTED</li><li>FIN_WAIT2</li><li>TIME_WAIT：在结束前，kernel中的socket fd被占用，相同的对端不能使用这个资源建立新连接。主动发起四次分手的一方持有这个IO状态。持续时间2MSL</li><li>CLOSED</li></ol><hr><h3 id="五、常用的linux命令"><a href="#五、常用的linux命令" class="headerlink" title="五、常用的linux命令"></a>五、常用的linux命令</h3><ol><li>netstat -natp</li><li>nc </li><li>strace</li><li>lsof </li></ol><hr><h3 id="六、epoll-ctl触发时机"><a href="#六、epoll-ctl触发时机" class="headerlink" title="六、epoll_ctl触发时机"></a>六、epoll_ctl触发时机</h3><p>Java层通过Selector.select()调用的时候，触发epoll_ctl()</p><hr><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="同步阻塞IO模型：只要程序自己读写，IO模型就是同步"><a href="#同步阻塞IO模型：只要程序自己读写，IO模型就是同步" class="headerlink" title="同步阻塞IO模型：只要程序自己读写，IO模型就是同步"></a>同步阻塞IO模型：只要程序自己读写，IO模型就是同步</h4><p>首先几个概念要了解</p><p>1.四元组 == socket<br>2.fd数量限制<br>3.内存大小和fd关系<br>4.主关注IO<br>    同步：用户进程自己完成读写<br>    异步：kernel完成读写，类似用户空间没有访问IO，通过Buffer实现<br>    阻塞：Blocking<br>    非阻塞：nonBlocking</p><p>​        水壶和铃铛的故事</p><h2 id="IO的发展史-C10K问题"><a href="#IO的发展史-C10K问题" class="headerlink" title="IO的发展史 C10K问题"></a>IO的发展史 C10K问题</h2><h4 id="1-每连接，每线程【BIO：accept-fd、recv-fd-系统调用阻塞等待kernel返回】"><a href="#1-每连接，每线程【BIO：accept-fd、recv-fd-系统调用阻塞等待kernel返回】" class="headerlink" title="1.每连接，每线程【BIO：accept(fd、recv(fd 系统调用阻塞等待kernel返回】"></a>1.每连接，每线程【BIO：accept(fd、recv(fd 系统调用阻塞等待kernel返回】</h4><p>优点：接收很多连接，默认随机器性能提升<br>缺点：每连接，没线程，线程过多的问题都是BIO的缺点</p><p>根本原因：accept、recv都是阻塞方式<br>解决方案：非阻塞方式，内核提供新功能</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="http://lion-heart.online/blog/2020-07-31-131806.png" alt="网络IO"></p><h4 id="2-每线程，多连接【NIO：socketChannel、byteBuffer】"><a href="#2-每线程，多连接【NIO：socketChannel、byteBuffer】" class="headerlink" title="2.每线程，多连接【NIO：socketChannel、byteBuffer】"></a>2.每线程，多连接【NIO：socketChannel、byteBuffer】</h4><p>优点：避免多线程问题，无论是资源问题还是调度问题，C10K问题<br>缺点：用户空间向内核空间循环遍历，无效的系统调用【是否有连接以完成三次握手、是否有fd以准备好数据等等都需要用户空间的进程不断的去kernel询问过程】浪费时间和系统资源【cpu读取软中断，cpu保存上下文，切换内存，保护现场】<br>根本原因：accept、recv等系统调用需要用户空间传递fd给内核空间，无法批量传递<br>解决方案：一个系统调用传递所有fd</p><h3 id="总结：全量遍历所有fd，需要用户态切换内核态才能实现"><a href="#总结：全量遍历所有fd，需要用户态切换内核态才能实现" class="headerlink" title="总结：全量遍历所有fd，需要用户态切换内核态才能实现"></a>总结：全量遍历所有fd，需要用户态切换内核态才能实现</h3><p><img src="http://lion-heart.online/blog/2020-07-31-133915.png" alt=""></p><h4 id="3-每线程，多连接【NIO-多路【FD-IO】复用【一次系统调用】-select、poll-：】"><a href="#3-每线程，多连接【NIO-多路【FD-IO】复用【一次系统调用】-select、poll-：】" class="headerlink" title="3.每线程，多连接【NIO+多路【FD/IO】复用【一次系统调用】(select、poll)：】"></a>3.每线程，多连接【NIO+多路【FD/IO】复用【一次系统调用】(select、poll)：】</h4><p>**** select、poll一次系统调用传递所有fd，时间复杂度为O(n) –&gt; O(1).kernel会告诉你那些fd已经IO就绪，然后你才执行recv系统调用某些fd，这时候不是全量的fd，时间复杂度从O(n) –&gt;O(m)</p><p>优点：通过一次系统调用select(),传递所有fd，通过内核进行遍历，减少了系统调用次数<br>缺点：<br> 1.用户空间每次while都需要传递所有fd，每次都需要重复传递fd<br> 2.内核空间每次都需要遍历所有fd<br> 3.select、poll后还需要系统调用去recv数据<br>解决方案：内核空间存储所有需要传递的fd</p><p>其他：<br>    select linux源码实现<br>        int select(int nfds, fd_set *readfds, fd_set *writefds,………….)</p><p>select()检查在readfds、writefd和errorfd中传递其地址的I/O描述符集，分别查看它们的描述符是否用于读取、准备写入或具有异常状态等待。第一个nfd被检入集合;我。e时，检查描述符中从0到nfds-1的描述符。(例如:如果您设置了两个文件描述符“4”“17”，那么nfds不应该是“2”，而应该是“17 + 1”或“18”。)On, select()将给定的描述符集替换为子集，子集由准备好进行请求操作的描述符组成，()返回所有集合中准备好的描述符的总数。描述符集以位字段的形式存储在整数数组中。提供的宏用于操作这样的描述符集:(&amp;fdset)初始化描述符集fdset为空集。(fd， &amp;fdset)在fdset中包含一个特定的fd。(fd， &amp;fdset)从fdset删除fd。FD_ISSET(fd， &amp;fdset)是非-如果fd是fdset的成员，否则为0。(&amp;fdset_orig<br>将已经分配的&amp;fdset_copy文件描述符替换为&amp;fdset_orig的副本。这些宏的行为是unde-如果描述符值小于零或大于或等于(通常至少等于系统支持的最大宏数量)。timeout是非空指针，它指定了等待选择完成的最大时间间隔。如果超时是一个空指针，选择无限期。要实现轮询，超时参数应该为nil，指向一个值为零的时间值结构。Timeout不是由select()引起的，可以在后续调用中重用，但是它的样式是在每次调用select()之前重新初始化它。如果没有感兴趣的readfds，和errorfds可以作为空指针给出。</p><h3 id="总结：其实无论上NIO、select、poll都是要遍历所有fd，询问状态。只不过NIO遍历的成本在用户态和内核态的切换。select、poll遍历过程触发一次系统调用（用户态和内核态的切换）把所有fd传递给内核，内核去遍历所有fd，修改IO状态，标识出那些fd是可读、可写"><a href="#总结：其实无论上NIO、select、poll都是要遍历所有fd，询问状态。只不过NIO遍历的成本在用户态和内核态的切换。select、poll遍历过程触发一次系统调用（用户态和内核态的切换）把所有fd传递给内核，内核去遍历所有fd，修改IO状态，标识出那些fd是可读、可写" class="headerlink" title="总结：其实无论上NIO、select、poll都是要遍历所有fd，询问状态。只不过NIO遍历的成本在用户态和内核态的切换。select、poll遍历过程触发一次系统调用（用户态和内核态的切换）把所有fd传递给内核，内核去遍历所有fd，修改IO状态，标识出那些fd是可读、可写"></a>总结：其实无论上NIO、select、poll都是要遍历所有fd，询问状态。只不过NIO遍历的成本在用户态和内核态的切换。select、poll遍历过程触发一次系统调用（用户态和内核态的切换）把所有fd传递给内核，内核去遍历所有fd，修改IO状态，标识出那些fd是可读、可写</h3><p><img src="http://lion-heart.online/blog/2020-07-31-133950.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-02-115418.png" alt="POLL底层实现细节"></p><h4 id="4-每线程，多连接【NIO-多路复用-epoll-】"><a href="#4-每线程，多连接【NIO-多路复用-epoll-】" class="headerlink" title="4.每线程，多连接【NIO+多路复用(epoll)】"></a>4.每线程，多连接【NIO+多路复用(epoll)】</h4><p>网卡中断：三个级别，无论那个级别，数据都是先到主存。中断的cb：将数据和kernelFD进行关联。此操作支持NIO-select-poll，kernel - FD 存在buffer，可以知道你给kernel的fds中那些buffer是有数据可以进行RW。晋级到epoll - kernel同时开辟一个链表结构，将准备好状态的fd保存到链表，用户通过epoll - wait直接获取链表内所有fd，无需再次循环kernel - 红黑树去查看 fd - buffer是否已经存在数据</p><ol><li>package</li><li>buffer</li><li>polling</li></ol><p>抽象一层 – 无需关注硬件实现，中断 -》回调 -〉event事件【遍历所有fd，可读写状态的FD添加到链表里】</p><p>整体流程</p><p>​    在Epoll之前的所有IO模型中，callback【网卡中断的后续内核指令集】只是完成了将网卡发来的数据走内核网络协议栈(2【链路层】,3【网络层】,4【数据传输层】)，最终由DMA关联到kernel FD【四元组的抽象】的buffer。</p><p>​    所以，某一时刻从APP询问内核某一个或某些FD是否有可R/W时，会有状态返回。</p><p>​    Epoll在kernel开辟了两个空间</p><ul><li>红黑树</li><li>链表：app自己分读写，按app来区分</li></ul><p>Q：zk的watch</p><p>Q：mmap()</p><p>Q：zk底层netty()</p><p><img src="http://lion-heart.online/blog/2020-08-02-115345.png" alt="EPOLL底层实现细节"></p><h4 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h4><p>1.epoll_create  =  return epfd -&gt;kernel开辟红黑树</p><p>2.epoll_ctl  =  int epoll_ctl(epfd，op，fd，event(R/W)) -&gt; op: ADD、MOD、DEL。  -》 添加fd4，关注accept事件</p><p>3.epoll_wait =  select </p><p><img src="http://lion-heart.online/blog/2020-08-02-071725.png" alt=""></p><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p><img src="http://lion-heart.online/blog/2020-08-02-130821.png" alt="EPOLL多线程处理"></p><p><img src="http://lion-heart.online/blog/2020-08-02-131928.png" alt="从EPOLL谈NETTY核心"></p><p><img src="http://lion-heart.online/blog/2020-08-02-131632.png" alt="分治重复利用多核CPU资源"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="http://lion-heart.online/blog/2020-07-31-132105.png" alt="文件IO"></p><h2 id="必须要了解的细节过程"><a href="#必须要了解的细节过程" class="headerlink" title="必须要了解的细节过程"></a>必须要了解的细节过程</h2><h2 id="结合这俩张图1-cpu执行流程、2-cpu缓存和bus-了解IO涉及到的所有细节"><a href="#结合这俩张图1-cpu执行流程、2-cpu缓存和bus-了解IO涉及到的所有细节" class="headerlink" title="结合这俩张图1.cpu执行流程、2.cpu缓存和bus 了解IO涉及到的所有细节"></a>结合这俩张图1.cpu执行流程、2.cpu缓存和bus 了解IO涉及到的所有细节</h2><p><img src="http://lion-heart.online/blog/2020-07-31-140507.png" alt="CPU执行流程"></p><p><img src="http://lion-heart.online/blog/2020-07-31-140858.png" alt="CPU芯片和RAM"></p><h3 id="CPU执行指令过程-取指令-—-解码-—-执行，每个过程都是使用CPU不同的部分"><a href="#CPU执行指令过程-取指令-—-解码-—-执行，每个过程都是使用CPU不同的部分" class="headerlink" title="CPU执行指令过程 取指令 — 解码 — 执行，每个过程都是使用CPU不同的部分"></a>CPU执行指令过程 取指令 — 解码 — 执行，每个过程都是使用CPU不同的部分</h3><p>并行计算的意义在于：执行一个指令的同时解码下一个指令–》一个CPU</p><p>产生的问题：乱序执行</p><p>Java里大小循环嵌套问题</p><p><strong>通常我们都知道外层小循环、内层大循环效率会高一些，这是因为高端的CPU会提前把指令放进流水线(指令寄存器)，这叫‘推测执行’，当JUMP的结果出现（java里的控制语句if），如果CPU猜对了，流水线已经塞满正确的指令，可以马上运行，反之就清空流水线。为了尽可能的减少清空流水线的次数，CPU厂商开发了‘分之预测’。正常情况下一个时钟周期CPU执行一条指令，然后‘超标量处理器’的出现，可以在一个时钟周期完成多个指令，这是因为CPU一个时钟周期内不同组件都是并行工作的，比如一个从内存取指令的动作，ALU组件会空闲。所以一次性处理多条指令(取指令+解码)会更好。</strong></p><p><img src="http://lion-heart.online/blog/2020-08-01-070604.png" alt="CPU执行指令和进程上下文切换流程"></p><h3 id="程序加载和运行"><a href="#程序加载和运行" class="headerlink" title="程序加载和运行"></a>程序加载和运行</h3><p><img src="http://lion-heart.online/blog/2020-08-01-111656.png" alt="程序加载和运行"></p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p><img src="http://lion-heart.online/blog/2020-08-01-112433.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-01-112721.png" alt=""></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>CPU – EA – VA – LA –PA</p><p>Bx -cx -dx -ex : 分别为代码段、数据段 – 转换成LA – 再去页表获取到具体的页 – 对应主存</p><p>地址：             机器码：                 汇编指令</p><p>8048300         c7 05 28 90 04 08  movl $0x1,0x8049028</p><h3 id="中断和异常：正常控制流程"><a href="#中断和异常：正常控制流程" class="headerlink" title="中断和异常：正常控制流程"></a>中断和异常：正常控制流程</h3><p>内部为异常</p><ul><li>故障：Fault，执行指令引起的异常事件。如缺页</li><li>自陷/陷阱：Trap，预先安排的事件。是一种自愿中断。</li><li><ul><li><img src="http://lion-heart.online/blog/2020-08-01-125221.png" alt="异常 - 陷阱指令执行流程(int 80)"></li></ul></li><li>终止：abort，硬件故障</li></ul><p>外部为中断</p><p>关中断：如果不关中断，又一条中断请求过来会破坏正在执行保护现在的指令。处理中断过程中要保护现场，因为中断也需要使用寄存器，寄存器里现在存储的是用户进程的指令和数据，如果不做保护现场，虽然可以通过断点回到用户进程，但是已经没有指令和数据信息了。</p><p><img src="http://lion-heart.online/blog/2020-08-01-130236.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-01-130925.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-01-131855.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-01-131749.png" alt=""></p><p>   <img src="http://lion-heart.online/blog/2020-08-01-121123.png" alt=""></p><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>进程上下文：进程代码和数据以及支持进程运行的环境合称为进程的上下文。</p><p>用户上下文：进程的程序块、数据块、堆栈等组成的用户空间信息</p><p>系统上下文</p><ol><li>进程标识</li><li>进程现场：处理器中各寄存器的内容称为<strong>寄存器上下文</strong></li><li>进程控制信息</li><li>内核栈</li></ol><p><img src="http://lion-heart.online/blog/2020-08-01-104004.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-08-01-110806.png" alt=""></p><h3 id="上下文切换：异常控制流程"><a href="#上下文切换：异常控制流程" class="headerlink" title="上下文切换：异常控制流程"></a>上下文切换：异常控制流程</h3><p><strong>具体流程：OS把换下的进程的寄存器上下文保存到OS上下文中的现场信息位置。因为CPU中只有一组eax、ebx寄存器，所有需要运行的进程都需要使用这组寄存器，也就说有且只有一个进程可以独占寄存器。类似于厨房里只有一个锅但是需要吵各种菜，有些需要二遍、三遍，期间需要炒其他菜品就需要先把那些二遍、三遍的菜品放到碗里又叫OS上下文</strong></p><p><img src="http://lion-heart.online/blog/2020-08-01-121603.png" alt=""></p><h3 id="系统回调"><a href="#系统回调" class="headerlink" title="系统回调"></a>系统回调</h3><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>boss               worker</p><p>accept             readWrite</p><pre><code>         select</code></pre><p>多路复用器     poll<br>            epoll</p><p>BIO – NIO – NIO+多路复用器(select/poll) – NIO+多路复用器(epoll)</p><p>BIO：单连接，socket bind listen accept阻塞<br>NIO：多连接，socket bind listen fcntl accept直接返回 问题是资源浪费【系统调用】，引入ByteBuffer和SocketChannel<br>NIO+多路复用器：被动触发</p><p>以上都是同步操作</p><p>IO：同步，用户自己去处理<br>处理：阻塞、非阻塞、阻塞同步、非阻塞异步</p><p>1.BIO和NIO有什么区别，NIO和多路复用器什么关系？<br>BIO：同步阻塞IO，同步体现read和write需要用户去同步处理<br>     阻塞指获取客户端连接阻塞,等待用户输入流阻塞<br>     浪费资源，效率低，每连接每线程</p><p>2.selector和poll有什么区别？<br>selector：fd限制1024，存储fd使用linkedList<br>pool：无fd限制，存储fd使用array，效率低，因为大多数文件描述符在任何时候都处于空闲状态，并且扫描了数千个文件描述符需要时间。</p><p>3.内核如何帮程序遍历fd？事件发生，内核如何通知用户？<br>中断+事件</p><p>4.reactor三种模型了解吗/介绍一下各自特点？<br>reactor三种模型<br>1.单线程模型，boss既负责accept也负责readHandler<br>2.混合模型，boss和worker负责readWrite<br>3.主从模型</p><p>5.boss和worker有什么区别？分别都是负责什么？<br>boss负责accept事件<br>worker负责read/write事件</p><p>IO策略<br>1.如何从单个线程发出多个I/O调用<br>    1.1别始终使用阻塞/同步调用，并可能使用多个线程或进程来实现并发<br>    1.2使用非阻塞调用（例如，将套接字设置为O_NONBLOCK上的write（））启动I / O，并使用就绪通知（例如poll（）或/ dev / poll）来了解何时可以在该通道上启动下一个I / O 。通常仅可用于网络I / O，而不能用于磁盘I / O。<br>    1.3使用异步调用（例如aio_write（））来启动I / O，并使用完成通知（例如，信号或完成端口）来了解I / O何时完成。适用于网络和磁盘I / O。<br>2.如何控制为每个客户端提供服务的代码<br>    每个客户端一个进程（1980年左右开始使用的经典Unix方法）<br>    一个OS级线程可处理许多客户端；每个客户由以下人员控制：<br>        用户级线程（例如，GNU状态线程，带有绿色线程的经典Java）<br>        状态机（有点深奥，但在某些圈子中很流行；我最喜欢）<br>        延续（有点深奥，但在某些圈子中很流行）<br>        每个客户端一个操作系统级别的线程（例如，具有本地线程的经典Java）<br>    每个活动客户端有一个操作系统级线程（例如，具有apache前端的Tomcat； NT完成端口；线程池）<br>    是使用标准O / S服务，还是将一些代码放入内核（例如，在自定义驱动程序，内核模块或VxD中）<br>以下五个组合似乎很受欢迎：</p><p>为每个线程服务许多客户端，并使用非阻塞I / O和级别触发的就绪通知<br>为每个线程服务许多客户端，并使用非阻塞I / O和就绪状态更改通知<br>为每个服务器线程服务许多客户端，并使用异步I / O<br>为每个服务器线程服务一个客户端，并使用阻塞I / O<br>将服务器代码构建到内核中</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>StringTable</title>
      <link href="/2020/07/16/StringTable/"/>
      <url>/2020/07/16/StringTable/</url>
      
        <content type="html"><![CDATA[<h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><p>费曼学习法</p><p> 选择概念【知识点】</p><p> 讲授</p><p> 查漏补缺</p><p> 继续升华</p><p>1.char[]</p><p>2.byte[] 编码集 gbk/u8 —-&gt; java unicode</p><p>3.int[]</p><p>4.new String(“xxx”)</p><p>5.字面量————————–StringTable </p><p> 非对象：类常量池【运行时数据】+类代码区【字节码指令】===&gt; 方法区</p><p> 懒加载：第一次用到字面量时，才会去加载【CPU加载字节码指令时才会去把符号引用转成地址引用，ldc字节码指令加载指定常量池数据】</p><p> 不重复：所有字面量共享同一堆对象，字面量存放在自己的类运行时数据区</p><p>6.拼接创建</p><p> String str = “a” + “b”;</p><p> final String fstr = “a”;</p><p> String str = “a”+fstr;</p><p> String a = “a”;</p><p> String b = “b” + a;</p><p> | |</p><p>  \ / \ /</p><p>  String a = “a”;</p><p>  String b = new StringBuilder().append(“b”).append(a).toString();</p><p>​          | |</p><p>​          \ /</p><p>​          char[] value;</p><p>​          new String(value,0,count)</p><p>load link【verification、preparation、resolution】 initial</p><p>JDK如何保证相同字符串在堆内是同一实例地址？</p><p>除了字面量方式以外的其他方式都无法保证同一实例地址，本质上都是使用new创建，他们都是在堆中创建新的字符串对象。只有字面量方式创建的字符串会放入StringTable中。</p><p>使用StringTable的好处？</p><p>减少内存使用，提升系统性能。</p><p>方便堆内对象管理，有利于GC。</p><p>StringTable如何保证堆内只有一个实例？</p><p>Stringtable内部维护一个hashtable，通过hash表的特性，保证了表内所有的数据都是唯一的不可重复。</p><p>StringTable的hash算法什么？会产生碰撞或冲突？</p><p>如何把非StringTable管理的对象交给StringTable管理的对象？</p><p> JDK提供了intern方法(),分为1.7及其以上和1.6两个版本，区别就是是否将非Stringtable管理的引用直接放到StringTable中还是复制一份放入，导致原对象并非是StringTable管理的问题</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OS</title>
      <link href="/2020/07/12/OS/"/>
      <url>/2020/07/12/OS/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="相关书籍推荐"><a href="#相关书籍推荐" class="headerlink" title="相关书籍推荐"></a>相关书籍推荐</h2><p>读书的原则：不求甚解，观其大略 </p><p>▪《编码：隐匿在计算机软硬件背后的语言》 完成</p><p>▪《深入理解计算机系统》</p><p>▪语言：C JAVA  K&amp;R《C程序设计语言》《C Primer Plus》</p><p>▪ 数据结构与算法： – 毕生的学习 leetCode</p><p>–《Java数据结构与算法》《算法》</p><p>–《算法导论》《计算机程序设计艺术》//难</p><p>▪操作系统：<em>Linux内核源码解析</em>  Linux内核设计与实现 30天自制操作系统</p><p>▪网络：机工《TCP/IP详解》卷一 翻译一般</p><p>▪编译原理：机工 龙书 《编译原理》 《编程语言实现模式》马语</p><p>▪数据库：SQLite源码 Derby - JDK自带数据库</p><h2 id="组成：硬件-软件"><a href="#组成：硬件-软件" class="headerlink" title="组成：硬件+软件"></a>组成：硬件+软件</h2><p><img src="http://lion-heart.online/blog/2020-07-12-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.png" alt=""></p><h2 id="硬件部分基础知识"><a href="#硬件部分基础知识" class="headerlink" title="硬件部分基础知识"></a>硬件部分基础知识</h2><h3 id="一-CPU的制作过程"><a href="#一-CPU的制作过程" class="headerlink" title="一.CPU的制作过程"></a>一.CPU的制作过程</h3><h4 id="1-Intel-cpu的制作过程"><a href="#1-Intel-cpu的制作过程" class="headerlink" title="1.Intel cpu的制作过程"></a>1.Intel cpu的制作过程</h4><p><a href="https://haokan.baidu.com/v?vid=11928468945249380709&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">https://haokan.baidu.com/v?vid=11928468945249380709&amp;pd=bjh&amp;fr=bjhauthor&amp;type=</a><a href="https://haokan.baidu.com/v?vid=11928468945249380709&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">video</a></p><h4 id="2-CPU是如何制作的（文字描述）"><a href="#2-CPU是如何制作的（文字描述）" class="headerlink" title="2.CPU是如何制作的（文字描述）"></a>2.CPU是如何制作的（文字描述）</h4><p><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">https</a><a href="https://www.sohu.com/a/255397866_468626" target="_blank" rel="noopener">://www.sohu.com/a/255397866_468626</a></p><h3 id="二-CPU的原理"><a href="#二-CPU的原理" class="headerlink" title="二.CPU的原理"></a>二.CPU的原理</h3><h4 id="1-计算机需要解决的最根本问题：如何代表数字并运用计算机处理数字"><a href="#1-计算机需要解决的最根本问题：如何代表数字并运用计算机处理数字" class="headerlink" title="1.计算机需要解决的最根本问题：如何代表数字并运用计算机处理数字"></a>1.计算机需要解决的最根本问题：如何代表数字并运用计算机处理数字</h4><h4 id="2-晶体管是如何工作的："><a href="#2-晶体管是如何工作的：" class="headerlink" title="2.晶体管是如何工作的："></a>2.晶体管是如何工作的：</h4><p><a href="https://haokan.baidu.com/v?vid=16026741635006191272&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">https://haokan.baidu.com/v?vid=16026741635006191272&amp;pd=bjh&amp;fr=bjhauthor&amp;type=</a><a href="https://haokan.baidu.com/v?vid=16026741635006191272&pd=bjh&fr=bjhauthor&type=video" target="_blank" rel="noopener">video</a></p><h4 id="3-晶体管的工作原理："><a href="#3-晶体管的工作原理：" class="headerlink" title="3.晶体管的工作原理："></a>3.晶体管的工作原理：</h4><p><a href="https://www.bilibili.com/video/av47388949?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av47388949?p=2</a></p><h4 id="4-总结：硅–-gt-加入特殊元素–》P半导体-N半导体-–〉PN结-–》二极管–〉晶体管-》逻辑开关-–〉基础逻辑电路-–》加法器、累加器、锁存器。。"><a href="#4-总结：硅–-gt-加入特殊元素–》P半导体-N半导体-–〉PN结-–》二极管–〉晶体管-》逻辑开关-–〉基础逻辑电路-–》加法器、累加器、锁存器。。" class="headerlink" title="4.总结：硅–&gt;加入特殊元素–》P半导体 N半导体 –〉PN结 –》二极管–〉晶体管-》逻辑开关 –〉基础逻辑电路 –》加法器、累加器、锁存器。。"></a>4.总结：硅–&gt;加入特殊元素–》P半导体 N半导体 –〉PN结 –》二极管–〉晶体管-》逻辑开关 –〉基础逻辑电路 –》加法器、累加器、锁存器。。</h4><h4 id="5-汇编语言（其实就是机器语言）的执行过程"><a href="#5-汇编语言（其实就是机器语言）的执行过程" class="headerlink" title="5.汇编语言（其实就是机器语言）的执行过程"></a>5.汇编语言（其实就是机器语言）的执行过程</h4><p>汇编语言的本质：机器语言【01001100010】的<strong>助记符</strong> 其实它就是机器语言</p><p>计算机通电 -&gt; CPU读取内存中【固定位置】程序（电信号输入）-&gt;时钟发生器不断震荡通断电【2.6GHz】 -&gt;推动CPU内部一步一步执行（执行多少步取决于指令需要的时钟周期）-&gt;计算完成-&gt;写回（电信号）-&gt;写给显卡输出（sout，或者图形）</p><h4 id="6-Java语言从编写到执行过程【跨平台行，核心就是不同平台JVM对字节码的解释功能】"><a href="#6-Java语言从编写到执行过程【跨平台行，核心就是不同平台JVM对字节码的解释功能】" class="headerlink" title="6.Java语言从编写到执行过程【跨平台行，核心就是不同平台JVM对字节码的解释功能】"></a>6.Java语言从编写到执行过程【跨平台行，核心就是不同平台JVM对字节码的解释功能】</h4><p>A.java【语言语法】 —-javac—- A.class【字节码（java语言级别的汇编）】—-java—-JVM解释【JVM规范，字节码解释成机器语言 】</p><p>物理内存：也是N多晶体管010101代表数据，计算机断电后，所有晶体管断电，数据清空，引出pagecache</p><p> 层级：CPU cacheline  物理内存 pagecahce  硬盘 块</p><h3 id="三-CPU的基本组成"><a href="#三-CPU的基本组成" class="headerlink" title="三.CPU的基本组成"></a>三.CPU的基本组成</h3><h4 id="1-CPU内部各组件介绍、以及之间的协同关系"><a href="#1-CPU内部各组件介绍、以及之间的协同关系" class="headerlink" title="1.CPU内部各组件介绍、以及之间的协同关系"></a>1.CPU内部各组件介绍、以及之间的协同关系</h4><p><img src="http://lion-heart.online/blog/2020-07-12-CPU%E5%86%85%E5%90%84%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8D%8F%E5%90%8C%E5%85%B3%E7%B3%BB.png" alt=""></p><p>计算机各个部件是由<strong>主板</strong>进行联通，主板上有很多电路，当外部设备连接主版或集成到主板上后，这些设备逻辑上就是互相连通，计算机最核心的就是<strong>CPU</strong>和<strong>内存</strong></p><p>CPU上一个组件的整体称呼，组成CPU又由很多组件</p><ol><li><p>PC -&gt; Program Counter 程序计数器：记录当前指令地址【内存类比一个字节数组，读取到其中一个指令，根据指令所占大小，下一条指令自动计算 】。类比JVM PC</p></li><li><p>Registers -&gt; 暂时存储CPU计算需要用到的数据。类比JVM stack里的本地变量表</p></li><li><p>ALU -&gt; Arithmetic &amp; Logic Unit 运算单元。类比JVM stack里的操作数栈</p></li><li><p>CU -&gt; Control Unit 控制单元，影响中断信号。</p></li><li><p>MMU -&gt; Memory Management Unit 内存管理单元</p></li><li><p>cache</p></li></ol><h4 id="2-存储器和缓存"><a href="#2-存储器和缓存" class="headerlink" title="2.存储器和缓存"></a>2.存储器和缓存</h4><p><img src="http://lion-heart.online/blog/2020-07-12-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt=""></p><h5 id="1⃣️缓存出现的意义"><a href="#1⃣️缓存出现的意义" class="headerlink" title="1⃣️缓存出现的意义"></a>1⃣️缓存出现的意义</h5><p>CPU到各介质获取所需数据的所耗费的时间是不同的，离CPU越近速度越快，反之亦然。CPU从register获取数据和从主存获取数据时间差比例为1:100。</p><ul><li><p>局部性原理：数据按块【块大小：4kb(不同平台定义不同)】读取，可以提高效率并充分发挥总线CPU针脚等一次性读取更多数据的能力</p></li><li><p>CPU 发送指令【直接内存访问】给DMA，由DMA从硬盘上读取数据到内存，无需CPU参与</p><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%883.23.18.png" alt=""></p></li></ul><h5 id="2⃣️cacheline"><a href="#2⃣️cacheline" class="headerlink" title="2⃣️cacheline"></a>2⃣️cacheline</h5><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%884.35.59.png" alt=""></p><p>缓存行越大，局部性空间效率越高，但读取时间慢</p><p>缓存行越小，局部性空间效率越低，但读取时间快</p><p>取一个折中值，目前多用：</p><p>64KB</p><p>不同CPU对同一cahceline操作如何保持数据一致性</p><h5 id="3⃣️缓存一致性协议：https-www-cnblogs-com-z00377750-p-9180644-html"><a href="#3⃣️缓存一致性协议：https-www-cnblogs-com-z00377750-p-9180644-html" class="headerlink" title="3⃣️缓存一致性协议：https://www.cnblogs.com/z00377750/p/9180644.html"></a>3⃣️缓存一致性协议：<a href="https://www.cnblogs.com/z00377750/p/9180644.html" target="_blank" rel="noopener">https://www.cnblogs.com/z00377750/p/9180644.html</a></h5><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%884.34.08.png" alt=""></p><h4 id="3-CPU存在的问题"><a href="#3-CPU存在的问题" class="headerlink" title="3.CPU存在的问题"></a>3.CPU存在的问题</h4><h5 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h5><p><a href="https://preshing.com/20120515/memory-reordering-caught-in-the-act/" target="_blank" rel="noopener">https://preshing.com/20120515/memory-reordering-caught-in-the-act/</a></p><p>jvm/jmm/Disorder.java</p><h4 id="4-解决乱序"><a href="#4-解决乱序" class="headerlink" title="4.解决乱序"></a>4.解决乱序</h4><p>分层次概念 </p><h5 id="CPU层面：Intel-gt-原语-mfence-lfence-sfence-或者锁总线"><a href="#CPU层面：Intel-gt-原语-mfence-lfence-sfence-或者锁总线" class="headerlink" title="CPU层面：Intel -&gt; 原语(mfence lfence sfence) 或者锁总线"></a>CPU层面：Intel -&gt; 原语(mfence lfence sfence) 或者锁总线</h5><h5 id="JVM层级：8个hanppens-before原则-4个内存屏障-（LL-LS-SL-SS）"><a href="#JVM层级：8个hanppens-before原则-4个内存屏障-（LL-LS-SL-SS）" class="headerlink" title="JVM层级：8个hanppens-before原则 4个内存屏障 （LL LS SL SS）"></a>JVM层级：8个hanppens-before原则 4个内存屏障 （LL LS SL SS）</h5><h5 id="as-if-serial-不管硬件什么顺序，单线程执行的结果不变，看上去像是serial"><a href="#as-if-serial-不管硬件什么顺序，单线程执行的结果不变，看上去像是serial" class="headerlink" title="as-if-serial : 不管硬件什么顺序，单线程执行的结果不变，看上去像是serial"></a>as-if-serial : 不管硬件什么顺序，单线程执行的结果不变，看上去像是serial</h5><h2 id="软件部分基础知识：OS"><a href="#软件部分基础知识：OS" class="headerlink" title="软件部分基础知识：OS"></a>软件部分基础知识：OS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><a href="https://processon.com/mindmap/5f09c58b637689789d265d39" target="_blank" rel="noopener">基本概念</a></h3><p><img src="http://lion-heart.online/blog/2020-07-12-%E4%B8%BB%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88.png" alt="主要做什么" title="操作系统主要做什么"></p><h3 id="1-内核（kernel）分类"><a href="#1-内核（kernel）分类" class="headerlink" title="1.内核（kernel）分类"></a>1.内核（kernel）分类</h3><h4 id="微内核-弹性部署-5G-IoT，核心只有kernel，其他硬件都是可扩展组件"><a href="#微内核-弹性部署-5G-IoT，核心只有kernel，其他硬件都是可扩展组件" class="headerlink" title="微内核 - 弹性部署 5G IoT，核心只有kernel，其他硬件都是可扩展组件"></a>微内核 - 弹性部署 5G IoT，核心只有kernel，其他硬件都是可扩展组件</h4><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-13%20%E4%B8%8A%E5%8D%885.36.17.png" alt=""></p><h4 id="宏内核-PC-phone，kernel和其他硬件都在一个芯片上"><a href="#宏内核-PC-phone，kernel和其他硬件都在一个芯片上" class="headerlink" title="宏内核 - PC phone，kernel和其他硬件都在一个芯片上"></a>宏内核 - PC phone，kernel和其他硬件都在一个芯片上</h4><p><img src="http://lion-heart.online/blog/2020-07-12-%E7%AE%80%E8%A6%81%E7%BB%93%E6%9E%84.png" alt="简要结构" title="简要结构"></p><h4 id="外核-科研-实验中-为应用定制操作系统-多租户-request-based-GC-JVM"><a href="#外核-科研-实验中-为应用定制操作系统-多租户-request-based-GC-JVM" class="headerlink" title="外核 - 科研 实验中 为应用定制操作系统 (多租户 request-based GC JVM)"></a>外核 - 科研 实验中 为应用定制操作系统 (多租户 request-based GC JVM)</h4><h3 id="2-OS运行机制：cpu分不同的指令级别"><a href="#2-OS运行机制：cpu分不同的指令级别" class="headerlink" title="2.OS运行机制：cpu分不同的指令级别"></a>2.OS运行机制：cpu分不同的指令级别</h3><h4 id="1-两种指令：对于系统的关键访问，需要经过kernel的同意，保证系统健壮性，内核执行的操作-gt-200多个系统调用-sendfile-read-write-pthread-fork"><a href="#1-两种指令：对于系统的关键访问，需要经过kernel的同意，保证系统健壮性，内核执行的操作-gt-200多个系统调用-sendfile-read-write-pthread-fork" class="headerlink" title="1.两种指令：对于系统的关键访问，需要经过kernel的同意，保证系统健壮性，内核执行的操作 - &gt; 200多个系统调用 sendfile read write pthread fork"></a>1.两种指令：对于系统的关键访问，需要经过kernel的同意，保证系统健壮性，内核执行的操作 - &gt; 200多个系统调用 sendfile read write pthread fork</h4><ul><li>特权指令：linux内核跑在ring 0级</li><li>非特权指令：用户程序跑在ring 3</li></ul><h4 id="2-处理器两种状态：两种状态的切换，本质上是内核程序（操作系统）与普通应用程序对CPU控制权的切换"><a href="#2-处理器两种状态：两种状态的切换，本质上是内核程序（操作系统）与普通应用程序对CPU控制权的切换" class="headerlink" title="2.处理器两种状态：两种状态的切换，本质上是内核程序（操作系统）与普通应用程序对CPU控制权的切换"></a>2.处理器两种状态：两种状态的切换，本质上是内核程序（操作系统）与普通应用程序对CPU控制权的切换</h4><ul><li><p>核心态</p></li><li><p>用户态</p></li></ul><h4 id="3-两种程序"><a href="#3-两种程序" class="headerlink" title="3.两种程序"></a>3.两种程序</h4><ul><li><p>内核程序</p></li><li><p>应用程序</p></li></ul><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><blockquote><p> <img src="http://lion-heart.online/blog/2020-02-19-083956.png" alt="用户态与核心态切换"></p></blockquote><h3 id="3-中断、异常"><a href="#3-中断、异常" class="headerlink" title="3.中断、异常"></a>3.中断、异常</h3><p><img src="http://lion-heart.online/blog/2020-07-14-interrupt.png" alt="全流程"></p><p><img src="http://lion-heart.online/blog/2020-07-14-%E4%B8%AD%E6%96%AD.png" alt=""></p><h4 id="1-定义：打断CPU，将CPU的控制权交给内核"><a href="#1-定义：打断CPU，将CPU的控制权交给内核" class="headerlink" title="1.定义：打断CPU，将CPU的控制权交给内核"></a>1.<strong>定义：打断CPU，将CPU的控制权交给内核</strong></h4><p><strong>软件、硬件（键盘、鼠标、网卡等硬件设备）跟操作系统内核打交道的一种机制</strong></p><h4 id="2-中断的分类"><a href="#2-中断的分类" class="headerlink" title="2.中断的分类"></a>2.中断的分类</h4><h5 id="1⃣️-软中断（内中断）"><a href="#1⃣️-软中断（内中断）" class="headerlink" title="1⃣️.软中断（内中断）"></a>1⃣️.软中断（内中断）</h5><blockquote><p> 系统调用</p><p>凡是与<strong>系统资源</strong>有关的操作都必须经过<strong>系统调用</strong>完成，系统调用按功能大致可分为如下几类</p><blockquote><ol><li><strong>设备管理</strong></li><li><strong>文件管理</strong></li><li><strong>进程管理</strong></li><li><strong>进程通信</strong></li><li><strong>内存管理</strong></li></ol><p><strong>本质：可能会影响其他进程的操作，必然需要通过系统调用请求操作系统代为完成</strong></p></blockquote></blockquote><p>int 0x80（c语言通过int函数实现，CPU读取int函数编译后二进制指令并实现中断） 或者 sysenter原语执行过程</p><ul><li><p>通过ax寄存器填入调用号（80中断表对应的系统函数）</p></li><li><p>参数通过bx cx dx si di（寄存器名称）传入内核</p></li><li><p>返回值通过ax返回</p></li><li><p>举例：java读网络 – java fileInputStream().read() – navtive read0() – jvm read() – c库read() - &gt; 内核空间 -&gt; system_call() （系统调用处理程序）-&gt; sys_read()</p></li></ul><h5 id="2⃣️-硬中断（外中断）：硬件触发的中断，键盘、鼠标、网卡、打印机等等"><a href="#2⃣️-硬中断（外中断）：硬件触发的中断，键盘、鼠标、网卡、打印机等等" class="headerlink" title="2⃣️.硬中断（外中断）：硬件触发的中断，键盘、鼠标、网卡、打印机等等"></a>2⃣️.硬中断（外中断）：硬件触发的中断，键盘、鼠标、网卡、打印机等等</h5><h5 id="3⃣️-时钟中断："><a href="#3⃣️-时钟中断：" class="headerlink" title="3⃣️.时钟中断："></a>3⃣️.时钟中断：</h5><p><strong>中断分类</strong></p><blockquote><ul><li>内中断：异常、例外、陷入。中断信号都是来自CPU内部，与当前执行的指令有关</li><li>外中断：中断信号来自CUP外部，与当前执行指令无关</li></ul><p><img src="http://lion-heart.online/blog/2020-02-19-085506.png" alt="截屏2020-02-19下午4.50.54"></p></blockquote><h4 id="3-从汇编角度理解软中断"><a href="#3-从汇编角度理解软中断" class="headerlink" title="3.从汇编角度理解软中断"></a>3.从汇编角度理解软中断</h4><h5 id="搭建汇编环境"><a href="#搭建汇编环境" class="headerlink" title="搭建汇编环境"></a>搭建汇编环境</h5><p>yum install nasm</p><pre><code>;hello.asm;write(int fd, const void *buffer, size_t nbytes);fd 文件描述符 file descriptor - linux下一切皆文件,区分不同介质section data//    数据段    msg db &quot;Hello&quot;, 0xA    len equ $ - msgsection .text//    代码段global _start_start:    mov edx, len    mov ecx, msg    mov ebx, 1 ;文件描述符1 std_out    mov eax, 4 ;write函数系统调用号 4    int 0x80    mov ebx, 0    mov eax, 1 ;exit函数系统调用号    int 0x80</code></pre><p>编译：nasm -f elf  hello.asm -o hello.o</p><p>链接：ld -m elf_i386 -o hello hello.o</p><p>一个程序的执行过程，要么处于用户态，要么处于内核态</p><h4 id="4-进程-线程-纤程"><a href="#4-进程-线程-纤程" class="headerlink" title="4.进程 线程 纤程"></a>4.进程 线程 纤程</h4><blockquote><ol><li>进程在linux中的实现：</li></ol><p>linux中也称为task，是<strong>OS分配资源（主要是内存空间）的基本单位</strong>，VFS</p><p><strong>资源定义</strong>：</p><ul><li>独立的地址空间（虚拟地址空间-寻址空间 ）</li><li>内核数据结构(进程描述符：PCB【process control block 】)</li><li>全局变量</li><li>数据段</li></ul><p><img src="http://lion-heart.online/blog/2020-07-15-%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8B%E5%8D%8811.00.16.png" alt=""></p><p><strong>进程类型</strong></p><ul><li><p>IO密集型大部分时间用于等待IO</p></li><li><p>CPU密集型部分事件用于执行计算</p></li></ul><p><strong>进程优先级</strong></p><ul><li>实时进程 &gt;  普通 进程</li><li>普通进程nice值</li></ul><p>进程的创建和启动：操作系统暴漏出来的函数，称为系统函数，使用fork、exec创建进程</p></blockquote><blockquote><ol start="2"><li>线程在linux中的实现：</li></ol><p>就是一个普通的进程【通过系统调用clone()是fork的包装方法，本质是fork()】，只不过是和其他进程<strong>共享资源</strong>（<strong>内存空间</strong>、全局数据等等），高层面理解：一个进程中不同的执行路径</p></blockquote><blockquote><ol start="3"><li>内核线程：运行在内核空间的线程（GC、定时）</li></ol></blockquote><p>JVM-hotspot进程的实现：需要进行系统调用，由内核fork()出一个轻量级进程，所以一个JVM空间的线程对应一个OS里的线程，是重量级线程。</p><p>纤程：用户态的线程，线程中的线程，切换和调度不需要经过OS</p><p>优势：1：占有资源很少 OS : 线程1M Fiber：4K 2：切换比较简单 3：启动很多个10W+</p><p>目前2020 3 22支持内置纤程的语言：Kotlin Scala Go Python(lib)… Java? （open jdk : loom）</p><h5 id="1-Java中对于纤程的支持：没有内置，盼望内置"><a href="#1-Java中对于纤程的支持：没有内置，盼望内置" class="headerlink" title="1.Java中对于纤程的支持：没有内置，盼望内置"></a>1.Java中对于纤程的支持：没有内置，盼望内置</h5><h6 id="纤程的应用场景"><a href="#纤程的应用场景" class="headerlink" title="纤程的应用场景"></a>纤程的应用场景</h6><p>纤程 vs 线程池：很短的计算任务，不需要和内核打交道，并发量高！</p><h5 id="2-僵尸进程：子挂、父还在，父持有子的PCB"><a href="#2-僵尸进程：子挂、父还在，父持有子的PCB" class="headerlink" title="2.僵尸进程：子挂、父还在，父持有子的PCB"></a>2.僵尸进程：子挂、父还在，父持有子的PCB</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;int main() {        pid_t pid = fork();        if (0 == pid) {                printf(&quot;child id is %d\n&quot;, getpid());                printf(&quot;parent id is %d\n&quot;, getppid());        } else {                while(1) {}        }}</code></pre><h5 id="3-孤儿进程：子在、父退出"><a href="#3-孤儿进程：子在、父退出" class="headerlink" title="3.孤儿进程：子在、父退出"></a>3.孤儿进程：子在、父退出</h5><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;int main() {        pid_t pid = fork();        if (0 == pid) {                printf(&quot;child ppid is %d\n&quot;, getppid());                sleep(10);                printf(&quot;parent ppid is %d\n&quot;, getppid());        } else {                printf(&quot;parent id is %d\n&quot;, getpid());                sleep(5);                exit(0);        }}</code></pre><h4 id="5-进程调度策略"><a href="#5-进程调度策略" class="headerlink" title="5.进程调度策略"></a>5.进程调度策略</h4><h5 id="2-5经典Unix-O-1-调度策略，偏向服务器，对交互程序不友好，时间片，每进程平均分配CPU调度时间"><a href="#2-5经典Unix-O-1-调度策略，偏向服务器，对交互程序不友好，时间片，每进程平均分配CPU调度时间" class="headerlink" title="2.5经典Unix O(1)调度策略，偏向服务器，对交互程序不友好，时间片，每进程平均分配CPU调度时间"></a>2.5经典Unix O(1)调度策略，偏向服务器，对交互程序不友好，时间片，每进程平均分配CPU调度时间</h5><h5 id="2-6采用CFS调度策略：Completely-Fair-Scheduler"><a href="#2-6采用CFS调度策略：Completely-Fair-Scheduler" class="headerlink" title="2.6采用CFS调度策略：Completely Fair Scheduler"></a>2.6采用CFS调度策略：Completely Fair Scheduler</h5><p>按优先级分配时间片的比例，并记录每个进程的执行时间，如果有一个进程执行时间不到他应该分配的比例，优先执行，时间不够进行补偿</p><p>默认调度策略：</p><p>实时进程先按优先级分高低 - FIFO (First In First Out)，优先级一样 - RR（Round Robin）</p><p>普通进程： CFS</p><h2 id="其他部分：内存管理"><a href="#其他部分：内存管理" class="headerlink" title="其他部分：内存管理"></a>其他部分：内存管理</h2><p><img src="http://lion-heart.online/blog/2020-07-14-%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png" alt=""></p><h3 id="1-内存管理的发展历程"><a href="#1-内存管理的发展历程" class="headerlink" title="1.内存管理的发展历程"></a>1.内存管理的发展历程</h3><p>1⃣️：DOS时代 - 同一时间只能有一个进程在运行（也有一些特殊算法可以支持多进程）</p><p>2⃣️：windows9x - 多个进程装入内存，带来了其他问题 </p><ul><li>内存不够用（每个进程都需要空间）【分块（编译后存放硬盘傻姑娘）装入页框】核心就是内存和磁盘都是按块和页交互</li><li>互相打扰（共享内存）【虚拟内存】</li></ul><p>为了解决这两个问题，诞生了现在的内存管理系统：<strong>1.虚拟地址 2.分页装入进程数据段 3.软硬件结合寻址</strong></p><ol><li><p>分页的目的是内存不够用，内存中分成固定大小的页框（最小粒度：4K），把硬盘上的程序分成4K大小的块【OS把程序划分成一个页表】，用到哪一块，加载那一块，加载的过程中，如果内存已经满了，会把最不常用的一块放到swap分区(硬盘上)， 把最新的一块加载进来，这个就是著名的LRU算法</p></li><li><p>虚拟内存的目是解决相互打扰问题，不能直接访问物理地址</p><ol><li>DOS Win31 … 互相干掉</li><li>为了保证互不影响 - 让进程工作在虚拟空间，程序中用到的空间地址不再是直接的物理地址，而是虚拟的地址，这样，A进程永远不可能访问到B进程的空间 </li><li>虚拟空间多大呢？寻址空间 - 64位系统 2 ^ 64，比物理空间大很多 ，单位是位byte</li><li>站在虚拟的角度，进程是独享整个系统 + CPU</li><li>内存映射：偏移量 + 段的基地址 = 线性地址 （虚拟空间） </li><li>线性地址通过 OS + MMU（硬件 Memory Management Unit）</li></ol><p><img src="http://lion-heart.online/blog/2020-07-15-%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8B%E5%8D%8811.00.16.png" alt=""></p><p><img src="http://lion-heart.online/blog/2020-07-15-%E6%88%AA%E5%B1%8F2020-07-15%20%E4%B8%8B%E5%8D%8811.05.37.png" alt=""></p></li><li><p>缺页中断（不是很重要）：</p><ol><li>需要用到页面内存中没有，产生缺页异常（中断），由内核处理并加载</li></ol></li></ol><h2 id="内核同步机制"><a href="#内核同步机制" class="headerlink" title="内核同步机制"></a>内核同步机制</h2><h3 id="关于同步理论的一些基本概念"><a href="#关于同步理论的一些基本概念" class="headerlink" title="关于同步理论的一些基本概念"></a>关于同步理论的一些基本概念</h3><p>•临界区（critical area）: 访问或操作共享数据的代码段  简单理解：synchronized大括号中部分（原子性）</p><p>•竞争条件（race conditions）两个线程同时拥有临界区的执行权</p><p>•数据不一致：data unconsistency 由竞争条件引起的数据破坏</p><p>•同步（synchronization）避免race conditions</p><p>•锁：完成同步的手段（门锁，门后是临界区，只允许一个线程存在） 上锁解锁必须具备原子性</p><p>•原子性（象原子一样不可分割的操作）</p><p>•有序性（禁止指令重排）</p><p>•可见性（一个线程内的修改，另一个线程可见）</p><p>互斥锁 排他锁 共享锁 分段锁</p><h3 id="内核同步常用方法"><a href="#内核同步常用方法" class="headerlink" title="内核同步常用方法"></a>内核同步常用方法</h3><p>1.原子操作 – 内核中类似于AtomicXXX，位于&lt;linux/types.h&gt;,linux提供lock compexc</p><p>2.自旋锁 – 内核中通过汇编支持的cas，位于&lt;asm/spinlock.h&gt;</p><p>3.读-写自旋 – 类似于ReadWriteLock，可同时读，只能一个写 读的时候是<a href="https://orgjinhc.github.io">共享锁</a>，写的时候是<a href="">排他锁</a></p><p>4.信号量 – 类似于Semaphore(PV操作 down up操作 占有和释放） 重量级锁，线程会进入wait，适合长时间持有的锁情况</p><p>5.读-写信号量 – downread upread downwrite upwrite （多个写，可以分段写，比较少用）(分段锁）</p><p>6.互斥体(mutex) – 特殊的信号量（二值信号量）</p><p>7.完成变量 – 特殊的信号量（A发出信号给B，B等待在完成变量上） vfork() 在子进程结束时通过完成变量叫醒父进程 类似于(Latch)</p><p>8.BKL：大内核锁（早期，现在已经不用）</p><p>9.顺序锁（2.6）： – 线程可以挂起的读写自旋锁 序列计数器（从0开始，写时增加(+1)，写完释放(+1)，读前发现单数， 说明有写线程，等待，读前读后序列一样，说明没有写线程打断）</p><p>10.禁止抢占 – preempt_disable()</p><p>11.内存屏障 – 见<a href="">volatile</a></p><h1 id="汇编实现引导程序"><a href="#汇编实现引导程序" class="headerlink" title="汇编实现引导程序"></a>汇编实现引导程序</h1><h2 id="编写汇编码"><a href="#编写汇编码" class="headerlink" title="编写汇编码"></a>编写汇编码</h2><pre><code>; 文件名 boot.asmorg 7c00h                     ; BIOS读入MBR后，从0x7c00h处开始执行; 下面部分和10h有关中断，10h中断用来显示字符mov ax, csmov es, axmov ax, msgmov bp, ax                    ; ES:BP表示显示字符串的地址mov cx, msgLen                ; CX存字符长度mov ax, 1301h                 ; AH=13h表示向TTY显示字符，AL=01h表示显示方式（字符串是否包含显示属性，01h表示不包含）mov bx, 000fh                 ; BH=00h表示页号，BL=0fh表示颜色mov dl, 0                     ; 列int 10hmsg: db &quot;hello world, welcome to OS!&quot;msgLen: equ $ - msg           ; 字符串长度times 510 - ($ - $$) db 0     ; 填充剩余部分dw 0aa55h                     ; 魔数，必须有这两个字节BIOS才确认是MBR</code></pre><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>nasm boot.asm -o boot.bin</p><h2 id="制作启动软盘"><a href="#制作启动软盘" class="headerlink" title="制作启动软盘"></a>制作启动软盘</h2><ol><li>dd if=/dev/zero of=floppy.img bs=1474560 count=1 <strong>生成空白软盘镜像</strong></li><li>dd if=boot.bin of=myos.img bs=512 count=1 <strong>制作包含主引导记录boot.bin的启动镜像文件</strong></li><li>dd if=floppy.img of=myos.img skip=1 seek=1 bs=512 count=2879 <strong>在 bin 生成的镜像文件后补上空白，成为合适大小的软盘镜像，一共2880个扇区，略过第一个</strong></li></ol><h2 id="用软盘启动系统"><a href="#用软盘启动系统" class="headerlink" title="用软盘启动系统"></a>用软盘启动系统</h2><ol><li>将myos.img下载到windows</li><li>VMWare创建空的虚拟机<ol><li>文件 - 创建新的虚拟机 - 典型</li><li>稍后安装操作系统</li><li>其他</li><li>一路next 完成</li><li>虚拟机设置，去掉CD/DVD选项中“启动时连接”</li><li>网络，选择“仅主机模式”，勾选“启动时连接”（好像无所谓）</li><li>添加软盘驱动器 使用软盘映像 找到myos.img</li></ol></li><li>启动虚拟机</li></ol><h2 id="为什么是0x7C00"><a href="#为什么是0x7C00" class="headerlink" title="为什么是0x7C00?"></a>为什么是0x7C00?</h2><p><img src="/Users/jinhongcai/blog/source/_posts/c:%5Cwork%5Ccourses%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%5Cimgs%5C8080%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="img"></p><p>参考：<a href="https://www.glamenv-septzen.net/en/view/6" target="_blank" rel="noopener">https://www.glamenv-septzen.net/en/view/6</a> </p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><h2 id="操作系统-1"><a href="#操作系统-1" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="Android-windows"><a href="#Android-windows" class="headerlink" title="Android / windows"></a>Android / windows</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="Oracle-Mysql"><a href="#Oracle-Mysql" class="headerlink" title="Oracle / Mysql"></a>Oracle / Mysql</h3><h2 id="计算器工作原理"><a href="#计算器工作原理" class="headerlink" title="计算器工作原理"></a>计算器工作原理</h2><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%887.11.40.png" alt=""></p><p>组成</p><p>ISPO模型</p><p>INPUT</p><p>STORE</p><p>PROCESS</p><p>OUTPUT</p><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%885.21.11.png" alt=""></p><p>计算机由电线和电路组成，如何用电来存储或表达信息 ，每条电线代表开或关、1或0、true/false、正/负，也就是1bit俗称1位，用8条线，就能存储0～255之间的数字，俗称1byte（字节） ，用32条线就能存储4亿多数字，并且只有0/1，这也是binary system。二进制亦可表示文字、图片、视频、声音，例如字母A～Z/a～z，可以用数字1～26类似表示 ，图片、视频都是由像素构成（R【253】G【78】B【141】），每张图片都是由成千上万个像素点构成，视频每秒钟现实几十张图片。下面来说说声音，声音是由空气振动产生的，振动也能通过波形图像来表示，波形图也可用数字来构成，通过这样的方法，任何声音都可以分解成一系列数字。</p><p>电路和逻辑</p><p>电路修改和处理信息，输入1输出0，这种电路叫做非，还有或和逻辑门等等很多用法和组合。所有都是根据简单的电路组合成复杂的或批量的处理逻辑。 </p><p>一个简单的加法器就是通过两条线输入经过电路等到结果，如果上0/1，只需要一条输出线，如果上两位就需要两条线了，以此类推，如果计算8bit的加法运算，只需要把简单的电路组合成复杂的电路即可。</p><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%886.41.13-1.png" alt=""></p><p>程序是什么样子？</p><p><img src="http://lion-heart.online/blog/2020-07-12-%E6%88%AA%E5%B1%8F2020-07-12%20%E4%B8%8B%E5%8D%888.06.10.png" alt=""></p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>thinking</title>
      <link href="/2020/02/24/thinking/"/>
      <url>/2020/02/24/thinking/</url>
      
        <content type="html"><![CDATA[<h2 id="Java一切皆对象是否正确"><a href="#Java一切皆对象是否正确" class="headerlink" title="Java一切皆对象是否正确"></a>Java一切皆对象是否正确</h2><p>“对象”的概念依然有其闪光点，把一切事物都抽象成对象不仅是一项不必要的负担，固执地要求所有东西都是一个对象（特别是一直到最底层级别）是一种设计错误；相反，完全逃避“对象”的概念似乎同样太过苛刻。</p><h2 id="编程的过程"><a href="#编程的过程" class="headerlink" title="编程的过程"></a>编程的过程</h2><p>编程的过程就是复杂性管理的过程：业务问题的复杂性，以及依赖的计算机的复杂性。由于这种复杂性，我们的大多数软件项目都失败了。</p><h2 id="沟通"><a href="#沟通" class="headerlink" title="沟通"></a>沟通</h2><p>通信革命使我们相互沟通更加便利</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>编程语言就是<code>创建应用程序</code>的<code>思想结构</code></p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>面向对象编程（Object-Oriented Programming OOP）是一种<code>编程思维方式</code>和<code>编码架构</code></p><p>一个对象具有自己的状态，行为和标识。这意味着对象有自己的内部数据(提供状态)、方法 (产生行为)，并彼此区分（每个对象在内存中都有唯一的地址）。</p><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><p>所有编程语言都提供抽象机制</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li>将学习作为一种生活方式。例如，学习一种以上的语言；没有什么比学习另一种语言更能吸引你的眼球。</li><li>知道在哪里以及如何获得新知识。</li><li>研究现有技术。</li><li>我们是工具使用者，即要善于利用工具。</li><li>学习做最简单的事情。</li><li>了解业务</li><li>应对错误负责。 “我用着没事”是不可接受的策略。查找自己的错误。</li><li>成为领导者：那些沟通和鼓舞别人的人。</li><li>你在为谁服务？</li><li>没有正确的答案……但总是更好的方法。展示和讨论你的代码，不要有情感上的依恋。你不是你的代码。</li><li>这是通往完美的渐进旅程。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>notes</title>
      <link href="/2020/02/23/notes/"/>
      <url>/2020/02/23/notes/</url>
      
        <content type="html"><![CDATA[<h2 id="一、专利"><a href="#一、专利" class="headerlink" title="一、专利"></a>一、专利</h2><h3 id="如何构思一个设计专利？以下分享3招设计思路（仅供参考）"><a href="#如何构思一个设计专利？以下分享3招设计思路（仅供参考）" class="headerlink" title="如何构思一个设计专利？以下分享3招设计思路（仅供参考）"></a>如何构思一个设计专利？以下分享3招设计思路（仅供参考）</h3><ol><li>移花接木</li></ol><p>基于使用场景，对交互方式进行组合/分离，包含（空间、位置、顺序、尺寸）来影响控件的不同状态</p><p>难度：⭐️⭐️⭐️</p><ol start="2"><li>无中生有</li></ol><p>针对尚无出现的功能/体验/品类进行创新性设计，没有具体设定的场景去设计往往更难，需要很深入了解问题才能进行延伸，容易经不起验证</p><p>难度：⭐️⭐️⭐️⭐️⭐️</p><ol start="3"><li>双剑合璧</li></ol><p>基于技术实现的具体功能结合交互形式呈现的新设计方案，需要对技术方面有了解，思考优化/其它路径的解决方法，有门槛</p><p>难度：⭐️⭐️⭐️⭐️</p><p>提示点：仅仅有简单的交互手势无法构成专利门槛，还需要有技术的支撑才能构成有效的设计专利</p><p>最终目的：</p><p>1-用达成目标的方法来逼迫自己进行跨品类、跨行业思考和拓展认知</p><p>例：做moba（王者）可以去了解fps（射击）的核心交互</p><p>2-用不同思维散发方法来让自己思路不再局限于惯性思维，深入思考</p><p>3-提升自己外在的竞争壁垒和团队内的话语权，减少不必要的方案沟通</p><p>4-帮助公司/项目在赛道上脱颖而出，有更好的产品体验，交互的隐性价值也就体现</p><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><h4 id="1-区块链防伪、溯源功能"><a href="#1-区块链防伪、溯源功能" class="headerlink" title="1.区块链防伪、溯源功能"></a>1.区块链防伪、溯源功能</h4><p>口罩</p><p>疫苗</p><h4 id="2-农场业务相关"><a href="#2-农场业务相关" class="headerlink" title="2.农场业务相关"></a>2.农场业务相关</h4><p>农产品溯源，<font size=5 color=red>完成</font></p><p>物流金融</p><p>物流溯源</p><p>一种可能的应用场景为：物联网络中每一个设备分配地址，给该地址所关联一个账户，用户 </p><p>通过向账户中支付费用可以租借设备，以执行相关动作，从而达到租借物联网的应用。 </p><p>典型的应用包括 、温度检测服务、网络摄像头数据调用等等</p><p>另外，随着物联网设备的增多、边沿计算需求的增强，大量设备之间形成分布式自组织的管 </p><p>理模式，并且对容错性要求很高。区块链自身分布式和抗攻击的特点可以很好地融合到这一 </p><p>场景中。</p><h4 id="3-智能配送、提示功能"><a href="#3-智能配送、提示功能" class="headerlink" title="3.智能配送、提示功能"></a>3.智能配送、提示功能</h4><p>类似预计多久到达用户手里，提前做出判断，无需配送员浪费时间在等或打电话沟通，用户的交互性和参与性增强</p><h2 id="二、OKR"><a href="#二、OKR" class="headerlink" title="二、OKR"></a>二、OKR</h2><h3 id="1-个人"><a href="#1-个人" class="headerlink" title="1.个人"></a>1.个人</h3><h3 id="2-工作"><a href="#2-工作" class="headerlink" title="2.工作"></a>2.工作</h3><h2 id="三、总结一年工作"><a href="#三、总结一年工作" class="headerlink" title="三、总结一年工作"></a>三、总结一年工作</h2><h3 id="1-技术点"><a href="#1-技术点" class="headerlink" title="1.技术点"></a>1.技术点</h3><blockquote><p>系统架构升级</p><p>统一日志管理</p><p>实现防重和并发锁</p><p>实现线程池</p><p>设计模式</p></blockquote><h3 id="2-业务"><a href="#2-业务" class="headerlink" title="2.业务"></a>2.业务</h3><blockquote><p>追溯流程</p><p>设备相关流程</p><p>农事流程</p><p>多线程使用场景</p></blockquote><h2 id="四、分享"><a href="#四、分享" class="headerlink" title="四、分享"></a>四、分享</h2><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>线程创建</p><ol><li>进程内存</li><li>os支持</li><li>cpu上下文切换</li><li>os调度算法</li><li>多线程不一定会利用多CPU资源，需要看任务复杂度</li><li>cpu调度的最小单位，执行业务逻辑</li></ol><p>三种线程池实现</p><p>五种阻塞队列实现</p><p>四种拒绝策略实现</p><p>解决并发通过CAS来实现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolExecutor源码解析</title>
      <link href="/2020/02/20/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/20/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h1><h3 id="1、常用变量的解释"><a href="#1、常用变量的解释" class="headerlink" title="1、常用变量的解释"></a>1、常用变量的解释</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. `ctl`，可以看做一个int类型的数字，高3位表示线程池状态，低29位表示worker数量</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. `COUNT_BITS`，`Integer.SIZE`为32，所以`COUNT_BITS`为29</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. `CAPACITY`，线程池允许的最大线程数。1左移29位，然后减1，即为 2^29 - 1</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span><span class="token comment" spellcheck="true">// 4. 线程池有5种状态，按大小排序如下：RUNNING &lt; SHUTDOWN &lt; STOP &lt; TIDYING &lt; TERMINATED</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token comment" spellcheck="true">// 5. `runStateOf()`，获取线程池状态，通过按位与操作，低29位将全部变成0</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 6. `workerCountOf()`，获取线程池worker数量，通过按位与操作，高3位将全部变成0</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 7. `ctlOf()`，根据线程池状态和线程池worker数量，生成ctl值</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* * Bit field accessors that don't require unpacking ctl. * These depend on the bit layout and on workerCount being never negative. */</span><span class="token comment" spellcheck="true">// 8. `runStateLessThan()`，线程池状态小于xx</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateLessThan</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 9. `runStateAtLeast()`，线程池状态大于等于xx</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> c <span class="token operator">>=</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、构造方法"><a href="#2、构造方法" class="headerlink" title="2、构造方法"></a>2、构造方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 基本类型参数校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 空指针校验</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据传入参数`unit`和`keepAliveTime`，将存活时间转换为纳秒存到变量`keepAliveTime `中</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3、提交执行task的过程"><a href="#3、提交执行task的过程" class="headerlink" title="3、提交执行task的过程"></a>3、提交执行task的过程</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// worker数量比核心线程数小，直接创建worker执行任务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 添加wc有可能并发，导致worker数量已经大于核心线程数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// worker数量超过核心线程数，任务直接进入队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池状态不是RUNNING状态，说明执行过shutdown命令，需要对新加入的任务执行reject()操作。</span>        <span class="token comment" spellcheck="true">// 这儿为什么需要recheck，是因为任务入队列前后，线程池的状态可能会发生变化。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这儿为什么需要判断0值，主要是在线程池构造方法中，核心线程数允许为0</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果线程池不是运行状态，或者任务进入队列失败，则尝试创建worker执行任务。</span>    <span class="token comment" spellcheck="true">// 这儿有3点需要注意：</span>    <span class="token comment" spellcheck="true">// 1. 线程池不是运行状态时，addWorker内部会判断线程池状态</span>    <span class="token comment" spellcheck="true">// 2. addWorker第2个参数表示是否创建核心线程</span>    <span class="token comment" spellcheck="true">// 3. addWorker返回false，则说明任务执行失败，需要执行reject操作</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、addworker源码解析"><a href="#4、addworker源码解析" class="headerlink" title="4、addworker源码解析"></a>4、addworker源码解析</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 外层自旋</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这个条件写得比较难懂，我对其进行了调整，和下面的条件等价</span>        <span class="token comment" spellcheck="true">// (rs > SHUTDOWN) || </span>        <span class="token comment" spellcheck="true">// (rs == SHUTDOWN &amp;&amp; firstTask != null) || </span>        <span class="token comment" spellcheck="true">// (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span>        <span class="token comment" spellcheck="true">// 1. 线程池状态大于SHUTDOWN时，直接返回false</span>        <span class="token comment" spellcheck="true">// 2. 线程池状态等于SHUTDOWN，且firstTask不为null，直接返回false</span>        <span class="token comment" spellcheck="true">// 3. 线程池状态等于SHUTDOWN，且队列为空，直接返回false</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内层自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 1.worker数量超过容量</span>              <span class="token comment" spellcheck="true">// 2.worker数量超过核心线程数或最大线程数，具体是哪个值取决入参是在什么条件进入当前方法</span>              <span class="token comment" spellcheck="true">// 1.2情况直接返回false</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 使用CAS的方式增加worker数量。</span>            <span class="token comment" spellcheck="true">// 若增加成功，则直接跳出外层循环进入到第二部分</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token comment" spellcheck="true">// 线程池状态发生变化，对外层循环进行自旋</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 其他情况，直接内层循环进行自旋即可</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// worker的添加必须是串行的，因此需要加锁</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token comment" spellcheck="true">// 这儿需要重新检查线程池状态</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// worker已经调用过了start()方法，则不再创建worker</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// worker创建并添加到workers成功</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 更新`largestPoolSize`变量</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 启动worker线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// worker线程启动失败，说明线程池状态发生了变化（关闭操作被执行），需要进行shutdown相关操作</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5、线程池worker任务单元"><a href="#5、线程池worker任务单元" class="headerlink" title="5、线程池worker任务单元"></a>5、线程池worker任务单元</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * This class will never be serialized, but we provide a     * serialVersionUID to suppress a javac warning.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Thread this worker is running in.  Null if factory fails. */</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Initial task to run.  Possibly null. */</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** Per-thread task counter */</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates with given first task and thread from ThreadFactory.     * @param firstTask the first task (null if none)     */</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这儿是Worker的关键所在，使用了线程工厂创建了一个线程。传入的参数为当前worker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** Delegates main run loop to outer runWorker  */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 省略代码...</span><span class="token punctuation">}</span></code></pre><h3 id="6、核心线程执行逻辑-runworker"><a href="#6、核心线程执行逻辑-runworker" class="headerlink" title="6、核心线程执行逻辑-runworker"></a>6、核心线程执行逻辑-runworker</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用unlock()是为了让外部可以中断</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token comment" spellcheck="true">// 这个变量用于判断是否进入过自旋（while循环）</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这儿是自旋</span>        <span class="token comment" spellcheck="true">// 1. 如果firstTask不为null，则执行firstTask；</span>        <span class="token comment" spellcheck="true">// 2. 如果firstTask为null，则调用getTask()从队列获取任务。</span>        <span class="token comment" spellcheck="true">// 3. 阻塞队列的特性就是：当队列为空时，当前线程会被阻塞等待</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 这儿对worker进行加锁，是为了达到下面的目的</span>            <span class="token comment" spellcheck="true">// 1. 降低锁范围，提升性能</span>            <span class="token comment" spellcheck="true">// 2. 保证每个worker执行的任务是串行的</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// If pool is stopping, ensure thread is interrupted;</span>            <span class="token comment" spellcheck="true">// if not, ensure thread is not interrupted.  This</span>            <span class="token comment" spellcheck="true">// requires a recheck in second case to deal with</span>            <span class="token comment" spellcheck="true">// shutdownNow race while clearing interrupt</span>            <span class="token comment" spellcheck="true">// 如果线程池正在停止，则对当前线程进行中断操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 执行任务，且在执行前后通过`beforeExecute()`和`afterExecute()`来扩展其功能。</span>            <span class="token comment" spellcheck="true">// 这两个方法在当前类里面为空实现。</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 帮助gc</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 已完成任务数加一 </span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 自旋操作被退出，说明线程池正在结束</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>operationSystem</title>
      <link href="/2020/02/19/operationSystem/"/>
      <url>/2020/02/19/operationSystem/</url>
      
        <content type="html"><![CDATA[<h2 id="用户态与核心态"><a href="#用户态与核心态" class="headerlink" title="用户态与核心态"></a><strong>用户态与核心态</strong></h2><h3 id="OS运行机制"><a href="#OS运行机制" class="headerlink" title="OS运行机制"></a>OS运行机制</h3><blockquote><ul><li><p><strong>两种指令</strong></p><ul><li><strong>特权指令</strong></li><li><strong>非特权指令</strong></li></ul></li><li><p><strong>处理器两种状态</strong></p><ul><li><strong>核心态</strong></li><li><strong>用户态</strong></li></ul></li><li><p><strong>两种程序</strong></p><ul><li><strong>内核程序</strong></li><li><strong>应用程序</strong></li></ul><p><strong>核心态与用户态的切换，本质上是操作系统与普通应用程序对CPU控制权的切换</strong></p></li></ul><p><strong>举例：</strong></p><p><img src="http://lion-heart.online/blog/2020-02-19-083956.png" alt="用户态与核心态切换"></p></blockquote><h3 id="中断、异常"><a href="#中断、异常" class="headerlink" title="中断、异常"></a>中断、异常</h3><p><strong>中断分类</strong></p><blockquote><ul><li>内中断：异常、例外、陷入。中断信号都是来自CPU内部，与当前执行的指令有关</li><li>外中断：中断信号来自CUP外部，与当前执行指令无关</li></ul><p>本质：将CPU的控制权交给操作系统</p><p><img src="http://lion-heart.online/blog/2020-02-19-085506.png" alt="截屏2020-02-19下午4.50.54"></p></blockquote><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>凡是与资源有关的操作都必须经过系统调用完成，系统调用按功能大致可分为如下几类****</p><blockquote><ol><li><strong>设备管理</strong></li><li><strong>文件管理</strong></li><li><strong>进程管理</strong></li><li><strong>进程通信</strong></li><li><strong>内存管理</strong></li></ol><p><strong>本质：可能会影响其他进程的操作，必然需要通过系统调用请求操作系统代为完成</strong></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网关</title>
      <link href="/2020/02/11/%E7%BD%91%E5%85%B3/"/>
      <url>/2020/02/11/%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="什么是网关"><a href="#什么是网关" class="headerlink" title="什么是网关"></a>什么是网关</h2><ul><li>服务转发：接收一切请求，转发到后端服务；</li><li>过滤器：完成一系列横切功能，例如权限校验、安防、认证、限流、协议转换、错误码统一、缓存、日志、监控、告警</li></ul><p>总结：服务转发+过滤器</p><h2 id="为什么需要服务网关"><a href="#为什么需要服务网关" class="headerlink" title="为什么需要服务网关"></a>为什么需要服务网关</h2><p>上述所说的横切功能（以权限校验为例）可以写在三个位置：<br>每个服务自己实现一遍；<br>写到一个公共的服务中，然后其他所有服务都依赖这个服务；<br>写到服务网关的前置过滤器中，所有请求过来进行权限校验。</p><p>第一种，缺点太明显，基本不用；<br>第二种，相较于第一点好很多，代码开发不会冗余，但是有两个缺点：<br>由于每个服务引入了这个公共服务，那么相当于在每个服务中都引入了相同的权限校验的代码，由于每个服务都引入了这个公共服务，那么后续升级这个服务可能就比较困难，而且公共服务的功能越多，升级就越难，而且假设要改变了公共服务中的权限校验的方式，想让所有的服务都去使用新的权限校验方式，就需要将之前所有的服务都重新引包，编译部署。</p><p>而服务网关恰好可以解决这样的问题：<br>将权限校验的逻辑写在网关的过滤器中，后端服务不需要关注权限校验的代码，如果想修改权限校验的逻辑，只需要修改网关中的权限校验过滤器即可，而不需要升级所有已存在的微服务。<br>所以，需要服务网关！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>serialization</title>
      <link href="/2020/02/09/serialization/"/>
      <url>/2020/02/09/serialization/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊序列化"><a href="#聊聊序列化" class="headerlink" title="聊聊序列化"></a><strong>聊聊序列化</strong></h1><p>*<em>前提：网络间传输数据的基本形式就是<code>二进制流</code>，也就是1和0。<code>编程语言</code>或者<code>网络框架</code>提供的API中，传输数据的形式是<code>字节</code>，也就是Byte。1byte=8bit，二进制流和字节流本质上是一样的 *</em></p><h3 id="什么是序列化"><a href="#什么是序列化" class="headerlink" title="什么是序列化"></a><strong>什么是序列化</strong></h3><p><strong>使用网络框架的API来传输结构化的数据，必须得先实现结构化的数据与字节流之间的双向转换，这种将结构化数据转换成字节流的过程，我们称为序列化</strong></p><p><strong>### 什么是反序列化</strong></p><p><strong>基于序列化定义，反过来转换，就是反序列化</strong></p><h3 id="为什么要序列化"><a href="#为什么要序列化" class="headerlink" title="为什么要序列化"></a>为什么要序列化</h3><p><strong>那对于我们编写的程序来说,它需要通过网络传输的数据是结构化的数据，例如：一条命令、一段文本或者是一条消息，对应到代码中,这些结构化的数据是<code>类</code>或者<code>结构体</code>来表示，进程之间要通过网络传输结构化的数据,需要通过序列化和反序列化来实现结构化数据和二进制数据的双向转换</strong></p><h3 id="序列化的用途"><a href="#序列化的用途" class="headerlink" title="序列化的用途"></a><strong>序列化的用途</strong></h3><ol><li><strong>网络上传输数据</strong></li><li><strong>将结构化数据保存在到文件</strong></li></ol><h3 id="序列化实现方式"><a href="#序列化实现方式" class="headerlink" title="序列化实现方式"></a><strong>序列化实现方式</strong></h3><ol><li><strong>自己实现</strong><ul><li>优点：根据所需自定义，实现功能</li><li>缺点：无法通用或广泛应用，只适用单应用场景</li></ul></li><li>Java原生<ul><li>优点：语言自带，使用方便，无需引入三方依赖</li><li>缺点：不支持跨语言，性能低，容易OOM</li></ul></li><li><strong>三方实现</strong><ul><li><strong>Google</strong></li><li><strong>Protobuf</strong></li><li><strong>Kryo</strong></li><li><strong>Hessian</strong><ul><li>优点：默认支持跨语言</li><li>缺点：效率低</li></ul></li><li><strong>JSON、XML</strong><ul><li>优点：可读性好，复杂度低</li><li>缺点：性能低</li></ul></li></ul></li></ol><h3 id="序列化方案选择"><a href="#序列化方案选择" class="headerlink" title="序列化方案选择"></a>序列化方案选择</h3><ol><li><strong>序列化后的数据最好是易于人类阅读</strong></li><li><strong>实现的复杂度是否能足够低</strong></li><li><strong>序列化和反序列化的速度越快越好</strong> </li><li><strong>序列化后的信息密度越密越好</strong></li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p><strong>大多数情况下，选择一个高性能的通用序列化框架都可以满足要求在性能可以满足需求的前提下，推荐优先选择JSON这种可读性好的序列化方法，如果说我们需要超高的性能，或者是带宽有限的情况下，可以使用专门的序列化方法，来提升序列化性能，节省传输流量</strong></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查看端口被占用</title>
      <link href="/2020/02/07/%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
      <url>/2020/02/07/%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="查看端口是否被占用"><a href="#查看端口是否被占用" class="headerlink" title="查看端口是否被占用"></a>查看端口是否被占用</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>lsof -i:8080</p><p><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html" target="_blank" rel="noopener">https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316599.html</a></p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>netstat -an | grep 22000</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>question</title>
      <link href="/2020/02/07/question/"/>
      <url>/2020/02/07/question/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h3 id="端口占用问题"><a href="#端口占用问题" class="headerlink" title="端口占用问题"></a>端口占用问题</h3><h3 id="Error-running-‘farm’-Cannot-run-program-“-Users-jinhongcai-Documents-tomcat-apache-tomcat-7-0-6-bin-catalina-sh”-in-directory-“-Users-jinhongcai-Documents-tomcat-apache-tomcat-7-0-6-bin”-error-13-Permission-denied"><a href="#Error-running-‘farm’-Cannot-run-program-“-Users-jinhongcai-Documents-tomcat-apache-tomcat-7-0-6-bin-catalina-sh”-in-directory-“-Users-jinhongcai-Documents-tomcat-apache-tomcat-7-0-6-bin”-error-13-Permission-denied" class="headerlink" title="Error running ‘farm’: Cannot run program “/Users/jinhongcai/Documents/tomcat/apache-tomcat-7.0.6/bin/catalina.sh” (in directory “/Users/jinhongcai/Documents/tomcat/apache-tomcat-7.0.6/bin”): error=13, Permission denied"></a>Error running ‘farm’: Cannot run program “/Users/jinhongcai/Documents/tomcat/apache-tomcat-7.0.6/bin/catalina.sh” (in directory “/Users/jinhongcai/Documents/tomcat/apache-tomcat-7.0.6/bin”): error=13, Permission denied</h3><p><code>mac下非root无法权限操作</code></p><p>修改文件权限 chmod -R 777 *</p><h3 id="com-jd-jsf-gd-error-NoAliveProviderException-JSF-22010-No-alive-provider-The-key-is-jsf-com-jd-farm-service-internal-FarmUnifiedPermissionsService-farm-test-jinhc-current-providers-is-jsf-100-124-60-137-22000-safVersion-210-amp-jsfVersion-1691-amp-interface-com-jd-farm-service-internal-FarmUnifiedPermissionsService-amp-alias-farm-test-jinhc"><a href="#com-jd-jsf-gd-error-NoAliveProviderException-JSF-22010-No-alive-provider-The-key-is-jsf-com-jd-farm-service-internal-FarmUnifiedPermissionsService-farm-test-jinhc-current-providers-is-jsf-100-124-60-137-22000-safVersion-210-amp-jsfVersion-1691-amp-interface-com-jd-farm-service-internal-FarmUnifiedPermissionsService-amp-alias-farm-test-jinhc" class="headerlink" title="com.jd.jsf.gd.error.NoAliveProviderException: [JSF-22010]No alive provider! The key is jsf://com.jd.farm.service.internal.FarmUnifiedPermissionsService:farm-test-jinhc, current providers is [jsf://100.124.60.137:22000/?safVersion=210&amp;jsfVersion=1691&amp;interface=com.jd.farm.service.internal.FarmUnifiedPermissionsService&amp;alias=farm-test-jinhc]"></a>com.jd.jsf.gd.error.NoAliveProviderException: [JSF-22010]No alive provider! The key is jsf://com.jd.farm.service.internal.FarmUnifiedPermissionsService:farm-test-jinhc, current providers is [jsf://100.124.60.137:22000/?safVersion=210&amp;jsfVersion=1691&amp;interface=com.jd.farm.service.internal.FarmUnifiedPermissionsService&amp;alias=farm-test-jinhc]</h3><p><code>思路</code></p><ol><li><strong>查看网络是否畅通</strong><ul><li><img src="http://lion-heart.online/blog/2020-02-07-082056.png" alt="查看网络"></li></ul></li><li><strong>查看实例上面进程端口是否启动成功</strong><ul><li><img src="http://lion-heart.online/blog/2020-02-07-082227.png" alt="查看端口进程"></li><li><img src="http://lion-heart.online/blog/2020-02-07-082309.png" alt="活动监视器"></li></ul></li><li>通过工具查看</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2020/02/04/VUE/"/>
      <url>/2020/02/04/VUE/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h1><p><strong>介绍：vue相对于react，使用起来会更简单，因为vuex, vue router都是官方在维护，比react第三方维护要好很多</strong></p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol><li><strong>了解vue</strong></li><li><strong>搭建vue工程</strong></li><li><strong>webpack相关</strong></li></ol><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><a href="http://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">http://vuejs-templates.github.io/webpack/</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="一、VUE实例"><a href="#一、VUE实例" class="headerlink" title="一、VUE实例"></a>一、VUE实例</h3><p>挂载vue方法</p><ol><li>new 方法构造参数里自行制定</li><li>通过template模板</li></ol><h3 id="二、VUE实例的生命周期方法"><a href="#二、VUE实例的生命周期方法" class="headerlink" title="二、VUE实例的生命周期方法"></a>二、VUE实例的生命周期方法</h3><ol><li><strong>beforeCreate：初始化vue前</strong></li><li><strong>create：初始化vue</strong></li><li><strong>beforeMount：挂载vue前</strong></li><li><strong>mounted：挂载vue后</strong></li><li>改变前</li><li>改变后</li><li>销毁前</li><li>销毁后</li></ol><h3 id="三、数据绑定"><a href="#三、数据绑定" class="headerlink" title="三、数据绑定"></a>三、数据绑定</h3><p>vue实例和template进行数据交换，template能绑定的数据一定是vue实例里定义的</p><p>总结：vue挂载后（mounted）才可以访问当前挂载组件里实例对象，最后完成双向绑定</p><h3 id="四、computed和watch"><a href="#四、computed和watch" class="headerlink" title="四、computed和watch"></a>四、computed和watch</h3><ol><li>computed是vue里的一个对象，里面所有的方法都是可以直接在当前vue内使用<ul><li>只生成新值，不做修改动作</li><li>依赖值发生变化，触发</li></ul></li><li>watch是监听变化做指定操作</li></ol><h3 id="五、原生指令"><a href="#五、原生指令" class="headerlink" title="五、原生指令"></a>五、原生指令</h3><blockquote><p>v-xxx:原生指令,部分指令有缩写方式，例如:id = v-bing:id=”xxx”</p><p>v-text=”xxx” 等价于 </p><p>V-html：可以解析html标签</p><p>V-show：display：none，作用是显示或隐藏节点</p><p>v-if：功能类似v-show，但是会触发动态增删节点</p><p>v-for：遍历数组（元素，索引），集合（val，key，index）</p><p>v-model：数据绑定</p></blockquote><h3 id="六、组件"><a href="#六、组件" class="headerlink" title="六、组件"></a>六、组件</h3><p>定义组件</p><ol><li>new VUE()–&gt;把template的内容挂载到el上，</li><li>.vue文件原理：export出去vue对象(组件)</li><li>prop属性：定义组件可配置行为，使用组件时要求或当前定义的变量有其作用，外部组件用来约束定义prop组件行为 </li></ol><p>注意事项：组件内data要在当前组件内初始化，不可使用全局data。</p><h3 id="七、组件继承"><a href="#七、组件继承" class="headerlink" title="七、组件继承"></a>七、组件继承</h3><h3 id="VUE-router"><a href="#VUE-router" class="headerlink" title="VUE-router"></a>VUE-router</h3><p>使用：导入vue-router，new router定义路由，默认hash路由</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><pre class=" language-bash"><code class="language-bash"><span class="token keyword">.</span>├── build/                      <span class="token comment" spellcheck="true"># webpack config files</span>│   └── <span class="token punctuation">..</span>.├── config/│   ├── index.js                <span class="token comment" spellcheck="true"># main project config</span>│   └── <span class="token punctuation">..</span>.├── src/│   ├── main.js                 <span class="token comment" spellcheck="true"># app entry file</span>│   ├── App.vue                 <span class="token comment" spellcheck="true"># main app component</span>│   ├── components/             <span class="token comment" spellcheck="true"># ui components</span>│   │   └── <span class="token punctuation">..</span>.│   └── assets/                 <span class="token comment" spellcheck="true"># module assets (processed by webpack)</span>│       └── <span class="token punctuation">..</span>.├── static/                     <span class="token comment" spellcheck="true"># pure static assets (directly copied)</span>├── test/│   └── unit/                   <span class="token comment" spellcheck="true"># unit tests</span>│   │   ├── specs/              <span class="token comment" spellcheck="true"># test spec files</span>│   │   ├── eslintrc            <span class="token comment" spellcheck="true"># config file for eslint with extra settings only for unit tests</span>│   │   ├── index.js            <span class="token comment" spellcheck="true"># test build entry file</span>│   │   ├── jest.conf.js        <span class="token comment" spellcheck="true"># Config file when using Jest for unit tests</span>│   │   └── karma.conf.js       <span class="token comment" spellcheck="true"># test runner config file when using Karma for unit tests</span>│   │   ├── setup.js            <span class="token comment" spellcheck="true"># file that runs before Jest runs your unit tests</span>│   └── e2e/                    <span class="token comment" spellcheck="true"># e2e tests</span>│   │   ├── specs/              <span class="token comment" spellcheck="true"># test spec files</span>│   │   ├── custom-assertions/  <span class="token comment" spellcheck="true"># custom assertions for e2e tests</span>│   │   ├── runner.js           <span class="token comment" spellcheck="true"># test runner script</span>│   │   └── nightwatch.conf.js  <span class="token comment" spellcheck="true"># test runner config file</span>├── .babelrc                    <span class="token comment" spellcheck="true"># babel config</span>├── .editorconfig               <span class="token comment" spellcheck="true"># indentation, spaces/tabs and similar settings for your editor</span>├── .eslintrc.js                <span class="token comment" spellcheck="true"># eslint config</span>├── .eslintignore               <span class="token comment" spellcheck="true"># eslint ignore rules</span>├── .gitignore                  <span class="token comment" spellcheck="true"># sensible defaults for gitignore</span>├── .postcssrc.js               <span class="token comment" spellcheck="true"># postcss config</span>├── index.html                  <span class="token comment" spellcheck="true"># index.html template</span>├── package.json                <span class="token comment" spellcheck="true"># build scripts and dependencies</span>└── README.md                   <span class="token comment" spellcheck="true"># Default README file</span></code></pre><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="WebPack原理"><a href="#WebPack原理" class="headerlink" title="WebPack原理"></a><a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">WebPack</a>原理</h4><p>webpack 用于打包前端资源, 前端资源有很多不同的类型 js, css, img, font ，通过http请求加载，开发webapp时都是一整个js加载到浏览器端之后再把所有的内容渲染出来，无法做到按需加载导致性能低下，通过webpack可以做到提升加载效率</p><h4 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h4><p>配置</p><p>插件 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lock</title>
      <link href="/2020/02/01/lock/"/>
      <url>/2020/02/01/lock/</url>
      
        <content type="html"><![CDATA[<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="作用：多线程同步"><a href="#作用：多线程同步" class="headerlink" title="作用：多线程同步"></a>作用：多线程同步</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li><p><strong>内部实现</strong></p><ul><li><p><strong>JVM实现(需要通过OS实现同步,非常消耗系统资源)</strong></p><ul><li><strong>synchronize1.6之前</strong></li><li><strong>synchronize1.6之后</strong></li></ul></li><li><p><strong>内置类实现</strong></p><ul><li><strong>juc下</strong><ul><li><strong>ReentrantLock</strong></li></ul></li></ul></li></ul></li><li><p><strong>外部实现</strong></p></li></ul><h2 id="多线程相关方法拓展"><a href="#多线程相关方法拓展" class="headerlink" title="多线程相关方法拓展"></a>多线程相关方法拓展</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><h4 id="作用：使当前线程阻塞，用于多线程之间通信，与notify、notifyAll组合构建生产消费模型"><a href="#作用：使当前线程阻塞，用于多线程之间通信，与notify、notifyAll组合构建生产消费模型" class="headerlink" title="作用：使当前线程阻塞，用于多线程之间通信，与notify、notifyAll组合构建生产消费模型"></a>作用：使当前线程阻塞，用于多线程之间通信，与notify、notifyAll组合构建生产消费模型</h4><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h3><h3 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h3><h3 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AQS</title>
      <link href="/2020/01/31/AQS/"/>
      <url>/2020/01/31/AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS-简介"><a href="#AQS-简介" class="headerlink" title="AQS 简介"></a>AQS 简介</h1><p><strong>JAVA中的AQS队列从根本上来讲是基于<code>CAS</code>的典型实现，同时也是使用volatile关键字的典型案例。它首先依赖于java中的java.util.concurrent.locks.LockSupport，而<code>LockSupport</code>又是基于<code>Unsafe</code>类来实现同步和操作系统函数的调用，Unsafe又是基于SMT(硬件级别同步多线程技术(CPU))来实现</strong></p><p><strong>实现总结：AQS -&gt; CAS (非阻塞并发算法) + CLH队列 + Volatile + 操作系统函数(park\unpark等) -&gt; LockSupport -&gt; Unsafe(同步和系统函数调用) -&gt; SMT（硬件级别多线程同步技术）</strong></p><h2 id="AQS的由来"><a href="#AQS的由来" class="headerlink" title="AQS的由来"></a>AQS的由来</h2><p><strong><code>java</code> <code>语言层面</code> 实现<code>多线程同步</code>的两种实现方案</strong></p><ul><li><p><strong><a href="http://orgjinhc.github.io/2020/01/28/Synchronized/">Synchronizer</a></strong></p></li><li><p><strong>AbstractQueuedSynchronizer</strong></p></li></ul><p><strong>1.6之前只有synchronize这一种实现同步方案，由于<code>synchronize</code>属于重量级锁，同步需要操作系统的支持，很多不是很复杂的业务逻辑要实现同步就变得非常的耗时，但是不同步又会有线程安全问题，所以aqs就孕育而生了，aqs要解决的首要问题就是<code>synchronize同步效率低的问题(1.6之前)</code>【 synchronize1.6之后也针对效率问题进行了相关的改进，因为程序大部分时间或大部分需要同步的逻辑并不存在大量的竞争，所以synchronize针对锁的种类和类型进行了升级，提出了锁升级或叫锁膨胀流程】</strong></p><h2 id="AQS-的特性"><a href="#AQS-的特性" class="headerlink" title="AQS 的特性"></a>AQS 的特性</h2><ul><li><strong>阻塞等待队列</strong></li><li><strong>共享/独占 两种模式</strong></li><li><strong>公平/非公平 两种处理流程</strong></li><li><strong>可重入</strong></li><li><strong>允许中断</strong></li></ul><p><strong>并发</strong></p><ul><li><strong>交替执行    CAS + spin</strong></li><li><strong>同步执行    CAS + spin + CLH</strong></li></ul><p><strong>并行</strong></p><ul><li><strong>CAS + spin + CLH + 操作系统函数</strong></li></ul><h3 id="lock-方法-开始"><a href="#lock-方法-开始" class="headerlink" title="lock 方法 开始"></a><code>lock</code> 方法 开始</h3><h4 id="lock-时序图"><a href="#lock-时序图" class="headerlink" title="lock 时序图"></a>lock 时序图</h4><p><img src="http://lion-heart.online/blog/2020-09-05-120928.png" alt="AQS时序图"></p><h4 id="自旋获取锁失败（乐观锁）-–-当前线程在阻塞队列进行排队"><a href="#自旋获取锁失败（乐观锁）-–-当前线程在阻塞队列进行排队" class="headerlink" title="自旋获取锁失败（乐观锁） – 当前线程在阻塞队列进行排队"></a>自旋获取锁失败（乐观锁） – 当前线程在阻塞队列进行排队</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Try the fast path of enq; backup to full enq on failure</span>  Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>      <span class="token keyword">return</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="addWaiter-时序图"><a href="#addWaiter-时序图" class="headerlink" title="addWaiter 时序图"></a>addWaiter 时序图</h4><p><img src="http://lion-heart.online/blog/2020-09-05-130932.png" alt="addWaiter时序图"></p><h4 id="acquireQueued-方法"><a href="#acquireQueued-方法" class="headerlink" title="acquireQueued 方法"></a>acquireQueued 方法</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//    当前节点 设置为 head head.ownerThread 从Thread - null</span>        <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>        failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>          <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>      <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="acquireQueued-时序图"><a href="#acquireQueued-时序图" class="headerlink" title="acquireQueued 时序图"></a><code>acquireQueued</code> 时序图</h3><p><img src="http://lion-heart.online/blog/2020-09-05-140942.png" alt="acquireQueued时序图"></p><h3 id="shouldParkAfterFailedAcquire-–-根据state状态的不同走不同逻辑"><a href="#shouldParkAfterFailedAcquire-–-根据state状态的不同走不同逻辑" class="headerlink" title="shouldParkAfterFailedAcquire – 根据state状态的不同走不同逻辑"></a><code>shouldParkAfterFailedAcquire</code> – 根据<code>state</code>状态的不同走不同逻辑</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>      node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="引出原子值含义AbstractQueuedSynchronizer-state"><a href="#引出原子值含义AbstractQueuedSynchronizer-state" class="headerlink" title="引出原子值含义AbstractQueuedSynchronizer.state"></a>引出原子值含义<code>AbstractQueuedSynchronizer.state</code></h5><ul><li><strong>SIGNAL：此节点的后继节点被(或即将被)阻塞(通过park)，因此当前节点在释放或取消时必须取消其后继节点。为了避免争用，获取方法必须首先表明它们需要一个信号，然后重试原子获取，然后，失败时阻塞</strong></li><li><strong>CANCELLED：由于超时或中断，此节点被取消。节点永远不会离开这个状态。特别是，具有已取消节点的线程将不再阻塞。出现异常或主动中断线程会出现此状态</strong> </li><li><strong>CONDITION：此节点当前位于条件队列上。它不会被用作同步队列节点</strong><br><strong>直到传输，此时状态将被设置为0</strong></li><li><strong>PROPAGATE：一个被释放的节点应该被传播到其他节点。这是设置(只针对头节点)</strong><br><strong>即使其他操作已经介入，doreleased也必须确保传播继续。</strong></li></ul><h3 id="parkAndCheckInterrupt-–-通过LockSupport-park-阻塞当前线程"><a href="#parkAndCheckInterrupt-–-通过LockSupport-park-阻塞当前线程" class="headerlink" title="parkAndCheckInterrupt – 通过LockSupport - park - 阻塞当前线程"></a><code>parkAndCheckInterrupt</code> – 通过LockSupport - park - 阻塞当前线程</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//    何时唤醒？    需要等待 持有锁的线程 进行 unpack操作</span>  LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//    Thread.interrupt() 中断线程</span>  <span class="token comment" spellcheck="true">//    Thread.interrupted()  获取中断状态、复位</span>  <span class="token comment" spellcheck="true">//    由于当前线程无法响应其他线程对当前线程的 中断 ，所以最后需要返回当前线程是否被中断过 acquireQueued需要根据是否 中断 进行安全中断</span>  <span class="token keyword">return</span> Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="lock-方法结束"><a href="#lock-方法结束" class="headerlink" title="lock 方法结束"></a><code>lock</code> 方法结束</h3><h3 id="relese方法-开始"><a href="#relese方法-开始" class="headerlink" title="relese方法 开始"></a><code>relese</code>方法 开始</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//    存在重入情况,所有重入都释放完毕 返回true</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    队列是否初始化，并且队列内是否有阻塞的线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//    如果状态为负(即 - 可能需要信号)试着发出信号。如果这个操作失败，或者通过等待线程改变状态，这是可以的。</span>    <span class="token comment" spellcheck="true">//    阻塞线程的状态是由下一个节点去修改状态,等价于回复状态也需要通过未阻塞的线程去唤醒和修改状态</span>  <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    异常或中断的线程 直接从阻塞队列中移除</span>  <span class="token comment" spellcheck="true">//    为什么从尾部开始移除？队列头存放的是取消或已经释放的线程对象，需要从尾部向前开始寻找需要被唤醒的线程对象</span>  Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    s <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        s <span class="token operator">=</span> t<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>    LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="relese方法-结束"><a href="#relese方法-结束" class="headerlink" title="relese方法 结束"></a><code>relese</code>方法 结束</h2><h3 id="公平锁-和-非公平锁-区别"><a href="#公平锁-和-非公平锁-区别" class="headerlink" title="公平锁 和 非公平锁 区别"></a>公平锁 和 非公平锁 区别</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    Lock 方法</span><span class="token comment" spellcheck="true">//    非公平锁,可以看到直接通过 CAS 去获取锁</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    公平锁方法,直接通过阻塞队列实现</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    tryAcquire 方法</span><span class="token comment" spellcheck="true">//    公平锁,只要阻塞队列已经初始化完毕,无需CAS直接 addWaiter操作</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Read fields in reverse initialization order</span>  Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>  Node s<span class="token punctuation">;</span>  <span class="token keyword">return</span> h <span class="token operator">!=</span> t <span class="token operator">&amp;&amp;</span>    <span class="token punctuation">(</span><span class="token punctuation">(</span>s <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>thread <span class="token operator">!=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//    非公平锁,每次都需要再次尝试 CAS 抢占锁</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="ReentrantLock：持有锁的线程不在队列中"><a href="#ReentrantLock：持有锁的线程不在队列中" class="headerlink" title="ReentrantLock：持有锁的线程不在队列中"></a>ReentrantLock：<code>持有锁的线程不在队列中</code></h2><p><code>加锁流程</code></p><blockquote><p><img src="http://lion-heart.online/blog/2020-02-02-070427.png" alt="Aqs加锁流程"></p><p><img src="http://lion-heart.online/blog/2020-09-05-235557.png" alt="AQS加锁流程"></p></blockquote><h2 id="AQS概念"><a href="#AQS概念" class="headerlink" title="AQS概念"></a>AQS概念</h2><ul><li><p>队列（双向链表）</p><ul><li>元素（Node）<ul><li>prev</li><li>next</li><li>Thread</li><li>waitState（默认值为0）</li></ul></li></ul></li><li><p>AbstractQueuedSynchronizer.state</p><ul><li>SIGNAL：此节点的后继节点被(或即将被)阻塞(通过park)，因此当前节点在释放或取消时必须取消其后继节点。为了避免争用，获取方法必须首先表明它们需要一个信号，然后重试原子获取，然后，失败时阻塞</li><li>CANCELLED：由于超时或中断，此节点被取消。节点永远不会离开这个状态。特别是，具有已取消节点的线程将不再阻塞。</li><li>CONDITION：此节点当前位于条件队列上。它不会被用作同步队列节点<br>直到传输，此时状态将被设置为0</li><li>PROPAGATE：一个被释放的节点应该被传播到其他节点。这是设置(只针对头节点)<br>即使其他操作已经介入，doreleased也必须确保传播继续。</li></ul></li><li><ul><li><img src="http://lion-heart.online/blog/2020-01-31-103600.png" alt="AQS.state"></li></ul></li></ul><h2 id="AQS使用方式"><a href="#AQS使用方式" class="headerlink" title="AQS使用方式"></a>AQS使用方式</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>blockingStatus</title>
      <link href="/2020/01/31/blockingStatus/"/>
      <url>/2020/01/31/blockingStatus/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>根据进入阻塞状态的方式不同，阻塞状态也会有细微的差异</strong></p><h2 id="阻塞状态分类"><a href="#阻塞状态分类" class="headerlink" title="阻塞状态分类"></a>阻塞状态分类</h2><ul><li>sleeping</li><li>on object monitor</li><li>parking</li></ul><p><strong>实际上这几种“阻塞”状态，恰恰就是Java中不同的锁机制实现</strong></p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><strong>Java中对悲观锁思想的实现就是我们最常使用的synchronized关键字，前面的文章有针对synchronize原理做解释<a href="http://orgjinhc.github.io/2020/01/28/Synchronized/"><code>Synchronized原理分析</code></a> ，Monitor机制就是synchronized锁机制升级为“重量级锁”后的工作机制，也就是JVM对操作系统级别的互斥锁(Mutex Lock)的管理过程</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>collection</title>
      <link href="/2020/01/31/collection/"/>
      <url>/2020/01/31/collection/</url>
      
        <content type="html"><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><h2 id="一图熟知Java容器"><a href="#一图熟知Java容器" class="headerlink" title="一图熟知Java容器"></a>一图熟知Java容器</h2><p><img src="http://lion-heart.online/blog/2020-01-31-073317.png" alt="容器图解"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ordering</title>
      <link href="/2020/01/31/ordering/"/>
      <url>/2020/01/31/ordering/</url>
      
        <content type="html"><![CDATA[<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>多线程程序按照书写的逻辑是没问题的，但是线上确实出问题了，方法调用次序颠倒，变量赋值异常等等情况时，那我们需查看happens-before原则来检查是否代码被cpu进行了重排序</code></p><h3 id="happens-before-原则：针对CPU进行约束"><a href="#happens-before-原则：针对CPU进行约束" class="headerlink" title="happens-before 原则：针对CPU进行约束"></a>happens-before 原则：针对CPU进行约束</h3><blockquote><ul><li><strong>程序次序规则</strong></li><li><strong>锁定规则</strong>：</li><li><strong>volatile变量规则</strong>：对一个变量的写操作先发生与后面对这个变量的读操作</li><li><strong>传递规则</strong></li><li><strong>线程启动规则</strong></li><li><strong>线程中断规则</strong></li><li><strong>线程终结规则</strong></li><li><strong>对象终结规则</strong> </li></ul></blockquote><h3 id="遵循happens-before原则进行代码优化、指令重排，提高执行效率，不影响在JVM内执行结果"><a href="#遵循happens-before原则进行代码优化、指令重排，提高执行效率，不影响在JVM内执行结果" class="headerlink" title="遵循happens-before原则进行代码优化、指令重排，提高执行效率，不影响在JVM内执行结果"></a>遵循happens-before原则进行代码优化、指令重排，提高执行效率，不影响在<code>JVM</code>内执行结果</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized</title>
      <link href="/2020/01/28/Synchronized/"/>
      <url>/2020/01/28/Synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="nchronized同步锁的底层实现"><a href="#nchronized同步锁的底层实现" class="headerlink" title="nchronized同步锁的底层实现"></a>nchronized同步锁的底层实现</h1><h2 id="synchronize是什么"><a href="#synchronize是什么" class="headerlink" title="synchronize是什么"></a>synchronize是什么</h2><blockquote><p>Java语言的关键字，可用来给对象和方法或者代码块加锁</p></blockquote><h2 id="synchronize作用"><a href="#synchronize作用" class="headerlink" title="synchronize作用"></a>synchronize作用</h2><p><code>先看段代码</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Synchronized</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> CountDownLatch COUNT_DOWN_LATCH <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object LOCK_OBJ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"Thread3"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        COUNT_DOWN_LATCH<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">lockedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LOCK_OBJ<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"currentThread : [{}]"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            COUNT_DOWN_LATCH<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unLockedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"currentThread : [{}]"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            COUNT_DOWN_LATCH<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>对应的输出结果</code></p><blockquote><p><strong>unLockedPrint</strong></p><blockquote><p>12:06:32.738 [Thread1] INFO lock.Synchronized - currentThread : [Thread1]<br>12:06:32.738 [Thread3] INFO lock.Synchronized - currentThread : [Thread3]<br>12:06:32.738 [Thread2] INFO lock.Synchronized - currentThread : [Thread2]</p></blockquote><p><strong>lockedPrint</strong></p><blockquote><p>12:11:31.173 [Thread1] INFO lock.Synchronized - currentThread : [Thread1]<br>12:11:32.179 [Thread3] INFO lock.Synchronized - currentThread : [Thread3]<br>12:11:33.179 [Thread2] INFO lock.Synchronized - currentThread : [Thread2]</p></blockquote><p><strong>结论</strong>：lockedPrint方法可以按照我们期望的流程间隔1s输出结果，通过synchronize关键字修饰类和对象可以<code>确保多个线程同一时刻，只能有一个线程处于方法或同步块中</code></p></blockquote><h2 id="synchronize的目的"><a href="#synchronize的目的" class="headerlink" title="synchronize的目的"></a>synchronize的目的</h2><blockquote><p>多线程并发环境下保证同步和数据安全</p></blockquote><h2 id="synchronize的原理"><a href="#synchronize的原理" class="headerlink" title="synchronize的原理"></a>synchronize的原理</h2><p><strong>synchronize加、释放锁流程图</strong></p><p><img src="http://lion-heart.online/blog/2020-01-28-043438.png" alt="synchronize整体流程"></p><p><strong>流程：多线程同时访问同步方法或代码块时，线程必须先获取对象监视器才有方法执行权。获取失败进入同步队列，线程状态变为BLOCKED状态。只有当持有锁的线程释放锁后，唤醒阻塞在同步队列中的线程，使其重新尝试获取监视器锁，往复此流程，如果持有锁的线程调用wait()方法，当前线程释放monitor，线程状态变成WAITING，等待其他线程唤醒，如若唤醒则从等待队列进入到同步队列继续抢夺monitor持有权</strong></p><h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><blockquote><p>​    <strong>Monitor是一个<code>同步工具</code>，也可以说是一种<code>同步机制</code>，java所提供的同步机制、互斥锁机制，这个机制的保障来源于监视锁<code>Monitor</code>，它内置于每一个Object对象中，任何一个对象都有自己的监视器</strong></p><p>​    <strong><font color = red size = 5>疑问</font>：代码里添加synchronize关键字可以实现线程安全是因为synchronize关键字是通过monitor同步机制实现的，那监视器对象或锁信息在哪？</strong></p><p>​    <strong>为了解决上面的疑问，我们还需要了解对象在内存中存储的布局，一图看懂对象存储布局</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-012949.png" alt="对象存储布局"></p><h5 id="一、对象存储布局"><a href="#一、对象存储布局" class="headerlink" title="一、对象存储布局"></a>一、<code>对象存储布局</code></h5><ol><li><strong>Java对象头</strong>：下面重点介绍</li><li><strong>实例数据</strong>：各种类型的字段内容（父类 + 子类）</li><li><strong>对齐补充</strong>：占位符（没有其他作用），虚拟机内存管理系统要求对象起始位置必须是 8 的整数倍，实例数据部分没有对齐，则填充（1.是方便CPU进行计算，2.GC更高效的回收）</li></ol><h5 id="二、Java对象头主要包括两部分数据"><a href="#二、Java对象头主要包括两部分数据" class="headerlink" title="二、Java对象头主要包括两部分数据"></a>二、Java对象头主要包括两部分数据</h5><ul><li><strong>类型指针（Klass Pointer）</strong>：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例（数组无法制定大小，还需要存储数组长度）</li><li><strong>标记字段(Mark Word)</strong>：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等,它是实现轻量级锁和偏向锁的关</li></ul><h5 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h5><p><strong><code>32</code>位<code>HotSpot</code>虚拟机Java对象头存储结构</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-021240.png" alt="Java对象头存储结构"></p><p><strong>再来看下虚拟机源码中对象头的数据结构，位置：markOop.hpp</strong></p><p><img src="http://lion-heart.online/blog/2020-01-30-030826.png" alt="Java对象头数据结构"></p><p><strong>对比对象头数据存储图和数据结构图可以得知</strong></p><p><strong>39行指定的是<code>无锁态</code></strong></p><p><strong>40行指定的是<code>偏向态</code></strong></p><p><strong>42行指定的是<code>清量级锁</code>、<code>重量级锁</code>、<code>GC标记</code></strong></p><p><strong>epoch：保存偏向时间戳</strong></p><p><strong>lock：锁标志位（枚举如下图）</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-022643.png" alt="lock枚举"></p><p><strong>锁标识位注解</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-022850.png" alt="锁标志位解释"></p><p><strong><font color =red size = 5 >结论</font>：在hotspot虚拟机中，不管是32/64位JVM，都是1bit偏向锁+2bit锁标志位（两个锁位用于描述三种状态:锁定/解锁/监视），同时根据枚举得知，只有锁标识位为10才触发监视器锁，也就是我们常说的重量级锁</strong></p><p><strong>回答开篇的两个问题</strong></p><ol><li><p><strong>锁信息在哪</strong></p><blockquote><p><strong>synchronized的底层实现是完全依赖JVM虚拟机Java对象header中的Mark Word来标识对象加锁状态</strong></p></blockquote></li><li><p><strong>监视器锁在哪</strong></p><blockquote><p><strong>Hotspot，Monitor是ObjectMonitor.class提供服务，基于C++里ObjectMonitor.hpp实现</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-094610.png" alt="openJDK,ObjectMonitor实现"></p><p><strong>Steps流程图</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-092753.png" alt="Steps"></p><p><strong>ObjectMonitor方法如下</strong></p><p><img src="http://lion-heart.online/blog/2020-01-29-095205.png" alt="ObjectMonitor方法列表"></p><p><font color = red size = 5>结论</font>：<strong>结合开篇synchronize加锁、释放锁流程图可知，加锁通过enter方法，解锁通过exit方法</strong></p></blockquote></li></ol></blockquote><h4 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h4><h5 id="JDK1-6之前加锁和解锁流程"><a href="#JDK1-6之前加锁和解锁流程" class="headerlink" title="JDK1.6之前加锁和解锁流程"></a>JDK1.6之前加锁和解锁流程</h5><p><strong>通过ObjectMonitor的enter()方法获取锁，通过exit()方法释放锁，这也是导致我们经常会说<code>synchronize</code>是<code>重量级锁的</code>原因，因为<code>java的线程</code>是映射到<code>操作系统的原生线程</code>，如果要wait或notify一个线程就需要OS帮助，需要从<code>用户态</code>切换到<code>内核态</code>，这种转换需要花费很多<code>处理器时间</code></strong></p><p><code>enter()</code></p><pre class=" language-c++"><code class="language-c++">void ATTR ObjectMonitor::enter(TRAPS) {  Thread * const Self = THREAD ;  void * cur ;  //    通过CAS尝试把monitor的`_owner`字段设置为当前线程  cur = Atomic::cmpxchg_ptr (Self, &_owner, NULL) ;  if (cur == NULL) {     assert (_recursions == 0   , "invariant") ;     assert (_owner      == Self, "invariant") ;     return ;  }  //    如果旧值和当前线程一样，说明当前线程已经持有锁，此次为重入，_recursions自增，并获得锁。  if (cur == Self) {     // TODO-FIXME: check for integer overflow!  BUGID 6557169.     _recursions ++ ;     return ;  }  // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程  if (Self->is_lock_owned ((address)cur)) {    assert (_recursions == 0, "internal state error");    _recursions = 1 ;    _owner = Self ;    OwnerIsThread = 1 ;    return ;  }    // 更改java线程状态以指示在监视器上阻塞    JavaThreadBlockedOnMonitorEnterState jtbmes(jt, this);    DTRACE_MONITOR_PROBE(contended__enter, this, object(), jt);    if (JvmtiExport::should_post_monitor_contended_enter()) {      JvmtiExport::post_monitor_contended_enter(jt, this);    }    OSThreadContendState osts(Self->osthread());    ThreadBlockInVM tbivm(jt);    Self->set_current_pending_monitor(this);        //    通过自旋执行ObjectMonitor::EnterI方法等待锁的释放    for (;;) {      jt->set_suspend_equivalent();      //    当前线程被封装成ObjectWaiter对象node，通过CAS把node节点push到_cxq列表中，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒*******enter重的原因********      EnterI (THREAD) ;      if (!ExitSuspendEquivalent(jt)) break ;          _recursions = 0 ;      _succ = NULL ;      exit (false, Self) ;      jt->java_suspend_self();    }    Self->set_current_pending_monitor(NULL);}</code></pre><p><code>exit():</code>通过退出monitor的方式实现锁的释放，并通知被阻塞的线程</p><pre class=" language-c++"><code class="language-c++">void ATTR ObjectMonitor::exit(bool not_suspended, TRAPS) {   Thread * Self = THREAD ;   if (THREAD != _owner) {     if (THREAD->is_lock_owned((address) _owner)) {       // Transmute _owner from a BasicLock pointer to a Thread address.       // We don't need to hold _mutex for this transition.       // Non-null to Non-null is safe as long as all readers can       // tolerate either flavor.       assert (_recursions == 0, "invariant") ;       _owner = THREAD ;       _recursions = 0 ;       OwnerIsThread = 1 ;     } else {       // NOTE: we need to handle unbalanced monitor enter/exit       // in native code by throwing an exception.       // TODO: Throw an IllegalMonitorStateException ?       TEVENT (Exit - Throw IMSX) ;       assert(false, "Non-balanced monitor enter/exit!");       if (false) {          THROW(vmSymbols::java_lang_IllegalMonitorStateException());       }       return;     }   }  //    根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog方法唤醒该节点封装的线程，唤醒操作最终由unpark完成 *********exit()*********  int QMode = Knob_QMode ;  //    ....}</code></pre><h5 id="JDK1-6对加锁的实现引入大量的优化来减少锁操作开销"><a href="#JDK1-6对加锁的实现引入大量的优化来减少锁操作开销" class="headerlink" title="JDK1.6对加锁的实现引入大量的优化来减少锁操作开销"></a>JDK1.6对加锁的实现引入大量的优化来减少锁操作开销</h5><p>还有我们经常说的对synchronize的升级也是1.6之后对锁的<code>实现</code>和<code>类型</code>进行了优化，目的是降低加锁、释放锁的开销，出现了<code>自旋锁</code>、<code>偏向锁</code>、<code>轻量级锁</code>、<code>重量级</code>锁等等，下面我们会一起讨论</p><h6 id="偏向锁（Biased-Locking）：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作"><a href="#偏向锁（Biased-Locking）：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作" class="headerlink" title="偏向锁（Biased Locking）：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作"></a><code>偏向锁</code>（Biased Locking）：目的是消除共享资源在无多线程竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作</h6><h6 id="轻量级锁（Lightweight-Locking）：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放"><a href="#轻量级锁（Lightweight-Locking）：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放" class="headerlink" title="轻量级锁（Lightweight Locking）：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放"></a><code>轻量级锁</code>（Lightweight Locking）：目的是在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放</h6><h6 id="锁粗化（Lock-Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗"><a href="#锁粗化（Lock-Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗" class="headerlink" title="锁粗化（Lock Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗"></a><code>锁粗化</code>（Lock Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗</h6><h6 id="锁消除（Lock-Elimination）：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁"><a href="#锁消除（Lock-Elimination）：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁" class="headerlink" title="锁消除（Lock Elimination）：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁"></a><code>锁消除</code>（Lock Elimination）：JIT在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这些锁</h6><h6 id="适应性自旋（Adaptive-Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1-6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间"><a href="#适应性自旋（Adaptive-Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1-6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间" class="headerlink" title="适应性自旋（Adaptive Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间"></a><code>适应性自旋</code>（Adaptive Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间</h6><p> ######<code>流程</code></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-30-085923.png" alt="整体流程"></p><p><code>引用</code>：<a href="https://blog.csdn.net/qq_29753285/article/details/81299509?utm_source=blogxgwz0" target="_blank" rel="noopener">Java多线程：锁的底层实现</a></p></blockquote><p>synchronized关键字修饰的代码段，在JVM被编译为monitorenter、monitorexit指令来获取和释放互斥锁，解释器执行monitorenter时会进入到<code>InterpreterRuntime.cpp</code>的<code>InterpreterRuntime::monitorenter</code>函数，具体实现如下：</p><pre class=" language-c++"><code class="language-c++">//  JavaThread* thread:java线程//  BasicObjectLock:包含一个BasicLock和一个指向Object对象的指针oopIRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))  //    UseBiasedLocking:开启偏向锁  if (UseBiasedLocking) {        //    尝试获取偏向锁    ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK);  } else {    //    轻量级锁的获取    ObjectSynchronizer::slow_enter(h_obj, elem->lock(), CHECK);  }}//    fast_enter实现void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) { //    如果开启了偏向锁 if (UseBiasedLocking) {      //    如果不在安全点    if (!SafepointSynchronize::is_at_safepoint()) {      //    .............    } else {      //    当前处于安全点，调用revoke_at_safepoint      BiasedLocking::revoke_at_safepoint(obj);    } } //    如果未开启偏向锁，或竞争偏向锁失败 slow_enter (obj, lock, THREAD) ;}//    revoke_at_safepoint实现BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) {    1. 判断当前对象是否为可偏向（101），且偏向时间戳已过期（没有其他线程在占用该对象），如果是，则进入步骤2，否则进入步骤3     2. 执行CAS操作将markword中的线程ID替换为本线程ID。如果成功则进入步骤4，否则进入步骤3     3. 存在竞争，当达到全局安全点（safepoint），获得偏向锁的线程被挂起，撤销偏向锁，并升级为轻量级，升级完成后被阻塞在安全点的线程继续执行同步代码块；     4. 执行同步代码}</code></pre><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="CAS-乐观锁机制"><a href="#CAS-乐观锁机制" class="headerlink" title="CAS:乐观锁机制"></a>CAS:乐观锁机制</h3><blockquote><p> CAS（Compare And Swap）比较并替换。在Java中，主要使用在<code>Atomic</code>包下，都是基于<code>Unsafe</code>类相关方法</p><p> 涉及三个值：<strong>内存中</strong>真正存的值（可能被其他线程改变）、逻辑上的<strong>原值</strong>、（当前线程）要写入的<strong>新值</strong>。通过循环检查内存中的值是不是原来的值，以此来判断是不是正有其他线程在改变它。判断成功立即写入新值，这一步是原子的</p><p> <strong>Unsafe：提供了一些绕开JVM的更底层功能，基于它的实现可以提高效率。它所分配的内存不被GC回收，同时提供了JNI某些功能的简单替代</strong></p><p> <strong>结论：利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。</strong></p></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><h5 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h5><pre class=" language-java"><code class="language-java">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>atomic<span class="token punctuation">.</span>AtomicInteger#<span class="token function">compareAndSet</span><span class="token punctuation">(</span>原值，新值<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6214790243416807050L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置为使用Unsafe.compareAndSwapInt进行更新</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//    初始化获取内存偏移值</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span>                <span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">/**   *    expect：期望值（原值）   *    update：修改值（目标值）   */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//    this代表当前AtomicInteger对象</span>      <span class="token comment" spellcheck="true">//    valueOffset:value值得内存地址偏移量</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe theUnsafe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//    拿到调用它的那个Class的ClassLoader判断是否是SystemDomainLoader,如果不是则抛安全异常</span>    <span class="token comment" spellcheck="true">//    简而言之就是判断是否可以信任调用者返给他实例</span>    <span class="token annotation punctuation">@CallerSensitive</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Unsafe <span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>VM<span class="token punctuation">.</span><span class="token function">isSystemDomainLoader</span><span class="token punctuation">(</span>caller<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SecurityException</span><span class="token punctuation">(</span><span class="token string">"Unsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> theUnsafe<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//    java实现:`unsafe.compareAndSwapInt(this, valueOffset, expect, update)`</span>  <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> i1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="自定义Unsafe类相关方法"><a href="#自定义Unsafe类相关方法" class="headerlink" title="自定义Unsafe类相关方法"></a>自定义Unsafe类相关方法</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonalUnsafe</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> changeValue <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> ageOffsetByCustom <span class="token operator">=</span> <span class="token number">00</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String AGE <span class="token operator">=</span> <span class="token string">"age"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//  通过反射实例化Unsafe</span>        Field f <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  设置暴力访问</span>        f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  获取私有方法</span>        Unsafe unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//实例化Person</span>        <span class="token keyword">long</span> ageOffsetByActual <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token punctuation">(</span>Person<span class="token punctuation">)</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateInstance</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        person<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        person<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Field field <span class="token operator">:</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>AGE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ageOffsetByActual <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}:对应的内存偏移地址:{}"</span><span class="token punctuation">,</span> field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//  通过内存偏移地址修改age的值</span>        <span class="token comment" spellcheck="true">//  错误的内存地址</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"custom offset result:{}"</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> ageOffsetByCustom<span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> changeValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//  内存中真正存的值和逻辑上的原值不相等</span>        <span class="token keyword">int</span> illegalAgeExpectValue <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"custom expect result:{}"</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> ageOffsetByActual<span class="token punctuation">,</span> illegalAgeExpectValue<span class="token punctuation">,</span> changeValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * ageOffsetByActual:内存中真正存的值         * person.getAge():逻辑上的原值         * 100:要写入的新值         * 通过循环检查内存中的值是不是原来的值，以此来判断是不是正有其他线程在改变它         *         */</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"actual result:{}"</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> ageOffsetByActual<span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> changeValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"age修改后的值:{},地址:{}"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span>AGE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Data</span><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>compareAndSwapInt</code>，是一个native方法，该方法的实现位于<code>unsafe.cpp</code>中</p><p><img src="http://lion-heart.online/blog/2020-01-28-093824.png" alt="Unsafe.CompareAndSwapInt"></p><blockquote><ol><li><p><strong>JNIHandles::resolve就是把obj（Persion）转换为oop</strong></p></li><li><p><strong>然后调用index_oop_from_field_offset_long(p, offset)方法，其中offset为修改的字段在对象所占内存中的偏移位置，最终得到的addr就是该字段在内存中的位置，这里可以简单理解为对象地址加上offset</strong></p></li><li><p><strong>得到字段地址addr之后就会调用核心的Atomic::cmpxchg方法，该方法定义在atomic.hpp中</strong></p><blockquote><pre class=" language-java"><code class="language-java">inline jint Atomic<span class="token operator">:</span><span class="token operator">:</span><span class="token function">cmpxchg</span> <span class="token punctuation">(</span>jint exchange_value<span class="token punctuation">,</span> <span class="token keyword">volatile</span> jint<span class="token operator">*</span> dest<span class="token punctuation">,</span> jint compare_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//    判断是否是多处理器</span>    <span class="token keyword">int</span> mp <span class="token operator">=</span> os<span class="token operator">:</span><span class="token operator">:</span><span class="token function">isMP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    _asm <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//    变量内存位置放edx</span>        mov edx<span class="token punctuation">,</span> dest          <span class="token comment" spellcheck="true">//    要更新的值放ecx</span>        mov ecx<span class="token punctuation">,</span> exchange_value          <span class="token comment" spellcheck="true">//    原内存值放eax  </span>        mov eax<span class="token punctuation">,</span> compare_value         <span class="token comment" spellcheck="true">//    原内存值放eax  </span>        <span class="token function">LOCK_IF_MP</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span> ≈        <span class="token comment" spellcheck="true">//     这句是真正的CAS操作</span>        cmpxchg dword ptr <span class="token punctuation">[</span>edx<span class="token punctuation">]</span><span class="token punctuation">,</span> ecx        <span class="token comment" spellcheck="true">//    dword ptr 将 [edx] 强制类型转换成双字</span>        <span class="token comment" spellcheck="true">//    cmpxchg 将 eax 里 内存原值 与（转换后的）对象值 比较</span>        <span class="token comment" spellcheck="true">//    如果相等，就是没别的线程在改变这个对象，那么这个线程就可以改了，将ecx值更新到这个对象。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> <strong>LOCK_IF_MP:会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（lock cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果），LOCK前缀导致处理器在执行指令时会置上LOCK#信号，于是该指令就被作为一个原子指令（atomic instruction）执行。在多处理器环境下,置上LOCK#信号可以确保任何一个处理器能独占使用任何共享内存，而且LCOK前缀的指令的目标操作数只能是内存寻址方式。</strong></p></blockquote></li><li><p><strong>最后用返回的内存中的值和期望值做比较直接返回</strong></p></li></ol></blockquote><p>结论：</p><ul><li>Intel使用缓存锁定来保证指令执行的原子性</li><li><strong>禁止</strong>该指令与前面和后面的指令<strong>重排序</strong></li><li>把<strong>写缓冲</strong>区的所有数据<strong>刷新</strong>到内存中</li><li><em>读-修改-写(read-modify-write)原子化操作</em></li><li>LOCK指令会使紧跟在其后面的指令变成 原子操作（atomic instruction）。暂时的锁一下总线，指令执行完了，总线就解锁了<ul><li>锁总线</li><li>锁缓存</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Fail_fast_safe</title>
      <link href="/2020/01/27/Fail_fast_safe/"/>
      <url>/2020/01/27/Fail_fast_safe/</url>
      
        <content type="html"><![CDATA[<h2 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail-fast"></a>fail-fast</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * fail-fast *     java.util包下集合类在用迭代器遍历一个集合对象时，遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modify Exception *     原因：迭代器遍历集合时，使用一个modCount变量来记录当遍历过程中集合对象结构发生了变化 *          使用hashNext.next()就会检测modCount和expected值是否相等，否则抛出cme *     modCount:列表在结构上被修改的次数 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">failFast</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer next <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"next:[{}]"</span><span class="token punctuation">,</span> next<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><img src="http://lion-heart.online/blog/2020-01-28-020958.png" alt="结构"></p><h2 id="fail-safe"><a href="#fail-safe" class="headerlink" title="fail-safe"></a>fail-safe</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * fail-safe * java.util.concurrent包下集合类都是安全失败,在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。 * 原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Cme */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">failSafe</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ConcurrentHashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">modify</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">>></span> iterator <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"next:[{}]"</span><span class="token punctuation">,</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span>ConcurrentMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Relection</title>
      <link href="/2020/01/27/Relection/"/>
      <url>/2020/01/27/Relection/</url>
      
        <content type="html"><![CDATA[<h1 id="简介：Java是一种强类型、静态类型检查的语言"><a href="#简介：Java是一种强类型、静态类型检查的语言" class="headerlink" title="简介：Java是一种强类型、静态类型检查的语言"></a>简介：Java是一种强类型、静态类型检查的语言</h1><p>这里有俩概念我们先了解一下，<code>强类型</code>和<code>静态类型</code>，那与之的应该有弱类型和动态类型了？</p><p><img src="http://lion-heart.online/blog/2020-01-27-025435.png" alt="语言类型划分"></p><p>上图的标准里解释了各种语言类型的划分，那到底是按照什么维度去划分强弱、动态静态这些概念的呢？</p><p><img src="http://lion-heart.online/blog/2020-01-27-025629.png" alt="各类型划分"></p><p>总结：强、弱、静态、动态</p><ul><li>动态类型：运行时做type check</li><li>静态类型：编译期做type check</li><li>强类型：一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。举个例子：如果你定义了一个double类型变量a,不经过强制类型转换那么程序int b = a无法通过编译</li><li>弱类型：它与强类型语言定义相反,允许编译器进行隐式的类型转换</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="带着问题看反射"><a href="#带着问题看反射" class="headerlink" title="带着问题看反射"></a>带着问题看反射</h3><blockquote><ol><li>什么是反射机制</li><li>反射机制的作用</li><li>反射是如何实现的</li><li>反射的优缺点</li><li>反射机制会不会有性能问题</li></ol></blockquote><h3 id="学习反射"><a href="#学习反射" class="headerlink" title="学习反射"></a>学习反射</h3><h4 id="What"><a href="#What" class="headerlink" title="What"></a>What</h4><p>在Java<code>运行时环境</code>中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种<code>动态获取类的信息</code>以及<code>动态调用对象的方法</code>的功能来自于Java 语言的<code>反射</code>（Reflection）机制</p><h4 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h4><p>由开篇可知java是强类型、静态类型语言，这句话代表什么呢？</p><p>程序中对象的类型都是在编译期就确定下来的，也就是说在java应用如果确定了一种数据类型，通过编译器的编译后，直接生成字节码文件，那么这个变量的类型就永远不会改变了，并且当前类的所有信息都是确定的不可修改的，如果要修改（添加新类/给类添加属性或方法）只能重新编写代码，通过编译器编译生成字节码文件</p><p><code>结论</code>：</p><ul><li><strong>反射的核心是 JVM 在运行时动态加载类或调用方法/访问属性，并可以在运行过程中动态的创建对象,甚至是修改程序的动态行为（获取类的所有方法，并访问类的私有方法在类之外的地方）</strong></li></ul><p><code>体现</code>：</p><ul><li><strong>在运行时判断任意一个对象所属的类</strong></li><li><strong>在运行时构造任意一个类的对象</strong></li><li><strong>在运行时判断任意一个类所具有的成员变量和方法</strong></li><li><strong>在运行时调用任意一个对象的方法</strong></li></ul><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><h5 id="一图看懂反射"><a href="#一图看懂反射" class="headerlink" title="一图看懂反射:"></a><strong><code>一图看懂反射</code>:</strong></h5><blockquote><p><img src="http://lion-heart.online/blog/2020-01-27-051347.png" alt="类加载"></p></blockquote><h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a><strong><code>流程</code>：</strong></h5><blockquote><p>java源文件（内存） —&gt; java字节码文件（硬盘）—&gt; JVM(Load) —&gt; java字节码文件 —&gt; Class类 —&gt; Class对象</p></blockquote><h5 id="字节码对象组成："><a href="#字节码对象组成：" class="headerlink" title="字节码对象组成："></a><strong><code>字节码对象组成</code>：</strong></h5><blockquote><ol><li>构造器对象 — Constructor</li><li>成员变量 — Field</li><li>成员方法 — Method  </li></ol></blockquote><h5 id="字节码文件加载机制"><a href="#字节码文件加载机制" class="headerlink" title="字节码文件加载机制"></a><code>字节码文件加载机制</code></h5><blockquote><ol><li>new一个类/子类</li><li>访问类静态方法/类静态成员变量</li><li>反射创建字节码对象<ul><li>Object.getClass()</li><li>类.class()</li><li>Class.forName()</li></ul></li><li>java命令执行字节码文件</li></ol><p><font color = green size = 5>结论</font>：所有以上加载机制只有第一次执行指令才会触发字节码问价加载，以后都说通过缓存执行</p></blockquote><p><font color = red size = 6>本质</font>：<strong><code>反射操作的就是字节码对象</code></strong></p><h4 id="Advantages-And-Disadvantages"><a href="#Advantages-And-Disadvantages" class="headerlink" title="Advantages And Disadvantages"></a>Advantages And Disadvantages</h4><blockquote><p><strong>Advantages</strong></p><ul><li><strong>反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中</strong></li></ul></blockquote><blockquote><p><strong>Disadvantages</strong></p><ul><li><strong>效率低：反射包括了一些动态类型，JVM无法对这些代码进行优化</strong></li><li><strong>安全性问题：使用反射技术要求程序必须在一个没有安全限制的环境中运行</strong></li><li><strong>反射破坏了代码的封装性和抽象性，并降低了可移植性</strong></li></ul></blockquote><h4 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h4><blockquote><p><strong>反射调用效率慢的原因</strong></p><ol><li><strong>接口的通用性，java的invoke方法是传object和object[]数组的。基本参数类型需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC</strong></li><li><strong>编译器难以对动态调用的代码提前做优化</strong></li><li><strong>反射需要按名检索类和方法，有一定的时间开销</strong></li></ol></blockquote><p><font color = red size = 6>总结</font>：<strong><code>应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</code></strong>o</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Transaction</title>
      <link href="/2020/01/24/Transaction/"/>
      <url>/2020/01/24/Transaction/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>做任何事前都需要先给自己定一个小目标，然后带着目标去学，在学的同时不断的提出问题，边学边想这样的学习方式最有效也记忆最深，学完后总结出来讲给身边的人，给他人讲明白，你才算是真正吸收了并转换为自己的东西。</p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li><p>理解事物原则、实现原理</p></li><li><p>掌握Spring事物机制、实现</p></li><li><p>了解分布式系统</p></li><li><p>掌握分布式事务实现原理、方法、思想</p></li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li><p>事物是干什么的</p></li><li><p>那些是事物要关心的问题</p><ul><li><p>数据的并发访问、修改</p></li><li><p>不同请求之间的数据隔离</p></li><li><p>多服务共同完成同一业务请求，保证都成功或都失败</p></li><li><p>异常发生时数据的回滚</p></li></ul></li><li><p>单体架构如何解决数据一致性问题</p></li><li><p>分布式架构下又如何解决</p></li></ol><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>先看下我们学习的路线 <img src="http://lion-heart.online/blog/2020-01-23-034516.png" alt="transaction"></p><h2 id="一、事物"><a href="#一、事物" class="headerlink" title="一、事物"></a>一、事物</h2><h3 id="事物是什么"><a href="#事物是什么" class="headerlink" title="事物是什么"></a><strong>事物是什么</strong></h3><blockquote><p>事物：通过一种<strong>可靠、一致</strong>的方式，访问和操作<strong>数据库</strong>中数据的<strong>程序单元</strong></p></blockquote><h3 id="事物原则-ACID"><a href="#事物原则-ACID" class="headerlink" title="事物原则(ACID)"></a><strong>事物原则(ACID)</strong></h3><blockquote><ul><li><strong>原子性（Atomicity）：事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败</strong></li><li><font color=red><strong>一致性</strong>(Consistency)</font>：<strong>事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态</strong></li><li><ul><li><strong>1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等)</strong> </li><li><strong>2.系统的状态反应数据库本应描述的 现实世界的真实状态</strong></li></ul></li><li><strong>隔离性（Isolation）：并发执行的事务不会相互影响,其对数据的影响和它们串行执行时一样</strong></li><li><strong>持久性（Durability）：事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失</strong></li></ul></blockquote><h3 id="事务特点"><a href="#事务特点" class="headerlink" title="事务特点"></a>事务特点</h3><ol><li><p><strong>事务的四个原则中，一致性是事务的根本追求，而在某些情况下会对事务的一致性造成破坏</strong></p><ul><li><strong>事务的并发执行</strong></li><li><strong>事务故障或系统故障</strong></li></ul></li><li><p><strong>数据库系统通过<code>并发控制</code>和<code>日志恢复</code>来避免这种情况的发生</strong></p><ul><li><strong>并发控制技术保证了事务的隔离性,使数据库的一致性状态不会因为并发执行的操作被破坏</strong></li><li><strong>日志恢复技术保证了事务的原子性,使一致性状态不会因事务或系统故障被破坏。同时使已提交的对数据库的修改不会因系统崩溃而丢失,保证了事务的持久性</strong></li></ul></li></ol><h3 id="事务原则实现原理"><a href="#事务原则实现原理" class="headerlink" title="事务原则实现原理"></a>事务原则实现原理</h3><ul><li><p><strong>事务的原子性是通过 undo log 来实现的</strong></p></li><li><p><strong>事务的持久性是通过 redo log 来实现的</strong></p></li><li><p><strong>事务的隔离性是通过 (读写锁+MVCC)来实现的</strong></p></li><li><p><strong>事务的一致性是通过原子性，持久性，隔离性来实现的</strong></p></li></ul><h4 id="原子性实现原理：Undo-log"><a href="#原子性实现原理：Undo-log" class="headerlink" title="原子性实现原理：Undo log"></a>原子性实现原理：Undo log</h4><p><strong>在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现<code>多版本并发控制(MVCC)</code>, 在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态</strong></p><p><strong>注意：undo log是逻辑日志，可以理解为：</strong></p><ul><li><strong>当delete一条记录时，undo log中会记录一条对应的insert记录</strong></li><li><strong>当insert一条记录时，undo log中会记录一条对应的delete记录</strong></li><li><strong>当update一条记录时，它记录一条对应相反的update记录</strong></li></ul><h4 id="持久性实现原理：Redo-log"><a href="#持久性实现原理：Redo-log" class="headerlink" title="持久性实现原理：Redo log"></a>持久性实现原理：Redo log</h4><p><strong>和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态</strong></p><h4 id="故障及故障恢复"><a href="#故障及故障恢复" class="headerlink" title="故障及故障恢复"></a>故障及故障恢复</h4><ul><li><p>事务的执行流程如下：</p></li><li><ul><li>系统会为每个事务开辟一个私有工作区</li><li>事务读操作将从磁盘中拷贝数据项到工作区中,在执行写操作前所有的更新都作用于工作区中的拷贝. </li><li>事务的写操作将把数据输出到内存的缓冲区中,等到合适的时间再由缓冲区管理器将数据写入到磁盘</li></ul></li><li><p>由于数据库存在立即修改和延迟修改,所以在事务执行过程中可能存在以下情况: </p></li><li><ul><li><p>在事务提交前出现故障,但是事务对数据库的部分修改已经写入磁盘数据库中。这导致了事务的原子性</p><p>被破坏</p></li><li><p>在系统崩溃前事务已经提交,但数据还在内存缓冲区中,没有写入磁盘。系统恢复时将丢失此次已提交的</p><p>修改。这是对事务持久性的破坏。</p></li></ul></li></ul><h4 id="故障及故障恢复-1"><a href="#故障及故障恢复-1" class="headerlink" title="故障及故障恢复"></a>故障及故障恢复</h4><ul><li>撤销事务undo:将事务更新的所有数据项恢复为日志中的旧值</li><li>重做事务redo:将事务更新的所有数据项恢复为日志中的新值</li><li>事务正常回滚/因事务故障中止将进行redo</li><li>系统从崩溃中恢复时将先进行redo再进行undo</li></ul><h3 id="事物隔离级别"><a href="#事物隔离级别" class="headerlink" title="事物隔离级别"></a><strong>事物隔离级别</strong></h3><table><thead><tr><th align="center">级别\问题</th><th align="center">脏读</th><th align="center">幻读</th><th align="center">不可重复读</th><th align="center">并发粒度</th></tr></thead><tbody><tr><td align="center">READ UNCOMMITTED</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">——-</td></tr><tr><td align="center">READ COMMITTED</td><td align="center"></td><td align="center">✅</td><td align="center">✅</td><td align="center">—–</td></tr><tr><td align="center">REPEATABLE READ</td><td align="center"></td><td align="center"></td><td align="center">✅</td><td align="center">—</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">-</td></tr></tbody></table><h4 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a><strong>问题解释</strong></h4><blockquote><ul><li><strong>脏读：事务读取到其他事务还<code>未提交的数据</code>，涉及到事务回滚，当前数据就是脏数据</strong></li></ul><ul><li><strong>不可重复读：两次读之间有其他事务对<code>共享数据</code>进行<code>修改</code></strong></li><li><strong>幻读：两次读之间有其他事务进行增删动作，是在<code>可重复读</code>的事务隔离级别下会出现的一种问题，简单来说，<code>可重复读</code>保证了当前事务不会读取到其他事务已提交的 <code>UPDATE</code> 操作。但同时，也会导致当前事务无法感知到来自其他事务中的 <code>INSERT</code> 或 <code>DELETE</code> 操作，这就是<code>幻读</code>。</strong></li><li><strong>更新丢失：和别的事务读到相同的东西，各自写，自己的写被覆盖了。（谁写的快谁的更新就丢失了）</strong></li></ul></blockquote><h4 id="隔离级别如何做到解决上述问题的呢"><a href="#隔离级别如何做到解决上述问题的呢" class="headerlink" title="隔离级别如何做到解决上述问题的呢"></a><strong>隔离级别如何做到解决上述问题的呢</strong></h4><ol><li><strong>LBCC：Lock Based Concurrency Control</strong></li><li><strong>MVCC：Multi Version Concurrency Control</strong></li></ol><table><thead><tr><th align="center">级别\读写</th><th align="center">读</th><th align="center">写</th></tr></thead><tbody><tr><td align="center">READ UNCOMMITTED</td><td align="center">不加锁</td><td align="center">行级共享锁</td></tr><tr><td align="center">READ COMMITTED</td><td align="center">行级共享锁（读完释放）</td><td align="center">行级排他锁（事物结束释放）</td></tr><tr><td align="center">REPEATABLE READ</td><td align="center">行级共享锁（事物结束释放）</td><td align="center">行级排他锁（事物结束释放）</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">表级共享</td><td align="center">表级排他</td></tr></tbody></table><p>上面的表格里又涉及到俩新概念：<strong><code>共享锁</code>、<code>排他锁</code></strong></p><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p><strong>定义：用于管理对<code>共享资源</code>的<code>访问控制</code></strong></p><p>这里只介绍InnoDB存储引擎，InnoDB既支持行级锁（row-level locking），也支持表级锁（table-level locking），但默认情况下是采用行级锁，<font color = red size = 5 ><strong>重点</strong></font>：InnoDB行锁基于索引，否则退化为表锁</p><h5 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h5><table><thead><tr><th align="center">锁粒度\区别</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">表锁</td><td align="center">开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低</td></tr><tr><td align="center">行锁</td><td align="center">开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高</td></tr></tbody></table><hr><table><thead><tr><th align="center">锁类型</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">共享锁</td><td align="center">行级别读锁（S锁），多事物对共享资源共享同一把锁，阻塞其他类型的锁</td></tr><tr><td align="center">排他锁</td><td align="center">行级别写锁（X锁），事物独占排他锁</td></tr><tr><td align="center">自增主键锁</td><td align="center"></td></tr><tr><td align="center">范围锁</td><td align="center"></td></tr><tr><td align="center">意向共享锁</td><td align="center">表级别读锁（IS），提高加锁效率</td></tr><tr><td align="center">意向排他锁</td><td align="center">表级别写锁（IX），提高加锁效率</td></tr></tbody></table><hr><table><thead><tr><th align="center">锁算法</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">记录锁</td><td align="center">存在于包括<code>主键索引</code>在内的<code>唯一索引</code>中，锁定单条索引记录，可退化为临键锁</td></tr><tr><td align="center">GAP（间隙）锁</td><td align="center">存在于<code>非唯一索引</code>中，锁定<code>开区间</code>范围内的一段间隔，它是基于<strong>临键锁</strong>实现的</td></tr><tr><td align="center">Next-key（临键）锁：默认算法</td><td align="center">特殊的<strong>间隙锁</strong>，通过<strong>临键锁</strong>可以解决<code>幻读</code>的问题。 每个数据行上的<code>非唯一索引列</code>上都会存在一把<strong>临键锁</strong>，锁住一段<strong>左开右闭区间</strong>的数据</td></tr></tbody></table><p><strong><font color = red size = 5>结论</font>：在根据<code>非唯一索引</code> 对记录行进行 <code>UPDATE \ FOR UPDATE \ LOCK IN SHARE MODE</code> 操作时，InnoDB 会获取该记录行的 <code>临键锁</code> ，并同时获取该记录行下一个区间的<code>间隙锁</code></strong></p><h2 id="二、Spring对事物的支持"><a href="#二、Spring对事物的支持" class="headerlink" title="二、Spring对事物的支持"></a>二、Spring对事物的支持</h2><h3 id="Spring事物机制"><a href="#Spring事物机制" class="headerlink" title="Spring事物机制"></a>Spring事物机制</h3><ul><li><p><strong>TransactionDefinition：<code>事物定义（隔离级别和传播行为）</code></strong></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-24-065702.png" alt="TransactionDefinitionon"></p></blockquote></li><li><p><strong>PlatformTransactionManager：<code>事物管理器</code></strong></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-24-065830.png" alt="PlatformTransactionManager"></p><p><strong>几种常用的默认实现</strong></p><blockquote><pre class=" language-java"><code class="language-java">DataSourceTransactionManagerJpaTransactionManagerJmsTransactionManager</code></pre></blockquote></blockquote></li><li><p><strong>TransactionStatus：<code>事物状态管理</code></strong></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-24-065912.png" alt="TransactionStatus"></p></blockquote></li></ul><h3 id="XA与JTA"><a href="#XA与JTA" class="headerlink" title="XA与JTA"></a>XA与JTA</h3><p><strong>XA：一种协议或规范，XA协议采用<code>两阶段提交</code>方式来管<code>分布式事务</code></strong></p><blockquote><p>架构原理</p><p><img src="http://lion-heart.online/blog/2020-01-24-080733.png" alt="XA模型"></p></blockquote><p><strong>JTA：Java Transaction API Java根据XA规范提供的事务处理标准</strong></p><blockquote><p><strong>原理</strong></p><p><img src="http://lion-heart.online/blog/2020-01-24-075246.png" alt="JTA事物管理原理"></p><p><strong>核心组件</strong></p><ol><li>AP</li><li>TransactionManager</li><li>ResourceManager</li><li>XID</li></ol><p><strong>弊端</strong></p><ol><li><strong>两阶段提交</strong></li><li><strong>事务时间无法控制，很容易发生死锁或锁定时间太长</strong></li><li><strong>低性能、低吞吐量</strong></li></ol><p><strong>流程</strong></p><ol><li><p><strong>第一阶段为 准备（prepare）阶段。即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。</strong> </p></li><li><p><strong>第二阶段为提交阶段（commit）。当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。</strong> </p><blockquote><p><strong>流程图以及流程如下</strong></p><p><img src="http://lion-heart.online/blog/2020-01-25-032734.png" alt="JTA原理"></p><pre class=" language-java"><code class="language-java">创建、启动TMo<span class="token punctuation">.</span>s<span class="token punctuation">.</span>t<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>JtaTransactionManager          <span class="token operator">:</span> Creating <span class="token keyword">new</span> <span class="token class-name">transaction</span> with name <span class="token punctuation">[</span>类<span class="token operator">+</span>方法<span class="token punctuation">]</span><span class="token operator">:</span> PROPAGATION_REQUIRED<span class="token punctuation">,</span>ISOLATION_DEFAULT<span class="token punctuation">;</span> <span class="token string">''</span>c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>imp<span class="token punctuation">.</span>BaseTransactionManager    <span class="token operator">:</span> <span class="token function">createCompositeTransaction</span> <span class="token punctuation">(</span> <span class="token number">10000</span> <span class="token punctuation">)</span><span class="token operator">:</span> created <span class="token keyword">new</span> <span class="token class-name">ROOT</span> transaction with id <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">.</span>tm0000100003o<span class="token punctuation">.</span>s<span class="token punctuation">.</span>t<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>JtaTransactionManager          <span class="token operator">:</span> Participating in existing transactionc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>imp<span class="token punctuation">.</span>CompositeTransactionImp   <span class="token operator">:</span> <span class="token function">registerSynchronization</span> <span class="token punctuation">(</span> com<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>Sync2Sync<span class="token annotation punctuation">@66ea0a4d</span> <span class="token punctuation">)</span> <span class="token keyword">for</span> transaction <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">.</span>tm0000100003RM加入TMr$ExtendedEntityManagerInvocationHandler <span class="token operator">:</span> Joined JTA transaction执行RM事务org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>SQL                        <span class="token operator">:</span> insert into <span class="token function">customer</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> password<span class="token punctuation">,</span> role<span class="token punctuation">,</span> user_name<span class="token punctuation">)</span> <span class="token function">values</span> <span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>提交RM资源到TMc<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AbstractDataSourceBean   <span class="token operator">:</span> AtomikosDataSoureBean <span class="token string">'dataSource'</span><span class="token operator">:</span> <span class="token function">getConnection</span> <span class="token punctuation">(</span> null <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AbstractDataSourceBean   <span class="token operator">:</span> AtomikosDataSoureBean <span class="token string">'dataSource'</span><span class="token operator">:</span> init<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>imp<span class="token punctuation">.</span>CompositeTransactionImp   <span class="token operator">:</span> <span class="token function">addParticipant</span> <span class="token punctuation">(</span> XAResourceTransaction<span class="token operator">:</span> 3132372E302E302E312E746D30303030313030303033<span class="token operator">:</span>3132372E302E302E312E746D31 <span class="token punctuation">)</span> <span class="token keyword">for</span> transaction <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">.</span>tm0000100003c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>xa<span class="token punctuation">.</span>XAResourceTransaction  <span class="token operator">:</span> XAResource<span class="token punctuation">.</span><span class="token function">start</span> <span class="token punctuation">(</span> 3132372E302E302E312E746D30303030313030303033<span class="token operator">:</span>3132372E302E302E312E746D31 <span class="token punctuation">,</span> XAResource<span class="token punctuation">.</span>TMNOFLAGS <span class="token punctuation">)</span> on resource dataSource represented by XAResource instance xads0<span class="token operator">:</span> conn0<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SAc<span class="token punctuation">.</span>a<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>imp<span class="token punctuation">.</span>CompositeTransactionImp   <span class="token operator">:</span> <span class="token function">registerSynchronization</span> <span class="token punctuation">(</span> com<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy$JdbcRequeueSynchronization<span class="token annotation punctuation">@7b60aac</span> <span class="token punctuation">)</span> <span class="token keyword">for</span> transaction <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">.</span>tm0000100003c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy  <span class="token operator">:</span> atomikos connection proxy <span class="token keyword">for</span> conn1<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SA<span class="token operator">:</span> calling <span class="token function">prepareStatement</span><span class="token punctuation">(</span>insert into <span class="token function">customer</span> <span class="token punctuation">(</span>id<span class="token punctuation">,</span> password<span class="token punctuation">,</span> role<span class="token punctuation">,</span> user_name<span class="token punctuation">)</span> <span class="token function">values</span> <span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy  <span class="token operator">:</span> atomikos connection proxy <span class="token keyword">for</span> conn1<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SA<span class="token operator">:</span> <span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy  <span class="token operator">:</span> atomikos connection proxy <span class="token keyword">for</span> conn1<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SA<span class="token operator">:</span> calling getWarnings<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy  <span class="token operator">:</span> atomikos connection proxy <span class="token keyword">for</span> conn1<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SA<span class="token operator">:</span> calling clearWarnings<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>AtomikosConnectionProxy  <span class="token operator">:</span> atomikos connection proxy <span class="token keyword">for</span> conn1<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SA<span class="token operator">:</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>xa<span class="token punctuation">.</span>XAResourceTransaction  <span class="token operator">:</span> XAResource<span class="token punctuation">.</span><span class="token function">end</span> <span class="token punctuation">(</span> 3132372E302E302E312E746D30303030313030303033<span class="token operator">:</span>3132372E302E302E312E746D31 <span class="token punctuation">,</span> XAResource<span class="token punctuation">.</span>TMSUCCESS <span class="token punctuation">)</span> on resource dataSource represented by XAResource instance xads0<span class="token operator">:</span> conn0<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SATM提交阶段o<span class="token punctuation">.</span>s<span class="token punctuation">.</span>t<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>JtaTransactionManager          <span class="token operator">:</span> Initiating transaction commitcom<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>Sync2Sync        <span class="token operator">:</span> <span class="token function">beforeCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> called on Synchronization<span class="token operator">:</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>synchronization<span class="token punctuation">.</span>RegisteredSynchronization<span class="token annotation punctuation">@40f07161</span>c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>imp<span class="token punctuation">.</span>CompositeTransactionImp   <span class="token operator">:</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token function">done</span> <span class="token punctuation">(</span>by application<span class="token punctuation">)</span> of transaction <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token punctuation">.</span>tm0000100003c<span class="token punctuation">.</span>a<span class="token punctuation">.</span>datasource<span class="token punctuation">.</span>xa<span class="token punctuation">.</span>XAResourceTransaction  <span class="token operator">:</span> XAResource<span class="token punctuation">.</span><span class="token function">commit</span> <span class="token punctuation">(</span> 3132372E302E302E312E746D30303030313030303033<span class="token operator">:</span>3132372E302E302E312E746D31 <span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">)</span> on resource dataSource represented by XAResource instance xads0<span class="token operator">:</span> conn0<span class="token operator">:</span> url<span class="token operator">=</span>jdbc<span class="token operator">:</span>h2<span class="token operator">:</span>mem<span class="token operator">:</span>testdb user<span class="token operator">=</span>SAcom<span class="token punctuation">.</span>atomikos<span class="token punctuation">.</span>icatch<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>Sync2Sync        <span class="token operator">:</span> <span class="token function">afterCompletion</span> <span class="token punctuation">(</span> STATUS_COMMITTED <span class="token punctuation">)</span> called  on Synchronization<span class="token operator">:</span> org<span class="token punctuation">.</span>hibernate<span class="token punctuation">.</span>resource<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>synchronization<span class="token punctuation">.</span>RegisteredSynchronization<span class="token annotation punctuation">@40f07161</span>o<span class="token punctuation">.</span>j<span class="token punctuation">.</span>s<span class="token punctuation">.</span>OpenEntityManagerInViewInterceptor <span class="token operator">:</span> Closing JPA EntityManager in OpenEntityManagerInViewInterceptoro<span class="token punctuation">.</span>s<span class="token punctuation">.</span>orm<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>EntityManagerFactoryUtils    <span class="token operator">:</span> Closing JPA EntityManager</code></pre></blockquote></li></ol><p><strong>局限性</strong></p><ul><li><strong>只适用单服务多数据源的场景</strong></li></ul><p><strong>扩展</strong></p><blockquote><p><strong>多服务实现分布式事务架构</strong></p><p><img src="http://lion-heart.online/blog/2020-01-25-071911.png" alt="JTA实现多服务的分布式事务"></p></blockquote></blockquote><p><strong>Spring分布式事务实现</strong></p><p>一致性选择</p><blockquote><p>强一致性方案</p><ul><li>JTA（性能差、只限于单服务内多数据场景）</li></ul><p>弱、最终一致性方案</p><ul><li>最大努力一次提交（自己设计保证事务方法一致性）</li><li>链式事物</li></ul></blockquote><p>场景选择</p><blockquote><ul><li>MQ - DB ： 最大努力一次提交</li><li>多DB ： 链式事物</li></ul></blockquote><h2 id="三、分布式系统"><a href="#三、分布式系统" class="headerlink" title="三、分布式系统"></a>三、分布式系统</h2><h3 id="1-一致性理论"><a href="#1-一致性理论" class="headerlink" title="1.一致性理论"></a>1.一致性理论</h3><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><ul><li><strong>Consistency：一致性（分布式环境下多个节点的数据是否一致）</strong></li><li><strong>Availability：可用性（分布式服务能一直保证可用状态。当用户发出一个请求后，服务能在有限时间内返回结果）</strong></li><li><strong>Partition Tolerance：分区容错性（特指对网络分区的容忍性）</strong></li></ul><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><ul><li><strong>基本可用（Basically Available）</strong>：指分布式系统在出现故障时，允许损失部分的可用性来保证核心可用</li><li><strong>软状态（Soft State）</strong>：指允许分布式系统存在中间状态，该中间状态不会影响到系统的整体可用性</li><li><strong>最终一致性（Eventual Consistency）</strong>：指分布式系统中的所有副本数据经过一定时间后，最终能够达到一致的状态</li></ul><h3 id="2-一致性模型"><a href="#2-一致性模型" class="headerlink" title="2.一致性模型"></a>2.一致性模型</h3><ul><li>强一致性：数据更新成功后，任意时刻所有节点的数据都是一致的，一般采用同步的方式实现。</li><li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li><li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值</li></ul><h3 id="3-一致性引发的问题"><a href="#3-一致性引发的问题" class="headerlink" title="3.一致性引发的问题"></a>3.一致性引发的问题</h3><blockquote><p><code>一致性</code>其实又包含了<strong><code>数据一致性</code></strong>和<strong><code>事务一致性</code></strong></p><p>数据一致性</p><ul><li>强一致性：数据更新成功后，任意时刻所有节点的数据都是一致的，一般采用同步的方式实现。</li><li>弱一致性：数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。</li><li>最终一致性：弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值</li></ul><p>事务一致性</p><ul><li><p>强一致性就是当前事务必须满足ACID所有事务原则</p></li><li><p>弱一致性就是在外部服务没有完成之前，用户发起查询请求，可以查看单独的某个服务结果</p></li><li><p>最终一致性是弱一致性的降级方案，如果某个事物发生不可逆的错误，最终要么要不回滚，要么人工介入解决问题</p></li></ul></blockquote><h2 id="四、分布式事务"><a href="#四、分布式事务" class="headerlink" title="四、分布式事务"></a>四、分布式事务</h2><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p>消息驱动的分布式事务实现（最终一致性）</p><blockquote><p>注意问题</p><ul><li>消息中间件需要支持事务</li><li>需要支持回滚操作</li><li>保证幂等性</li></ul><p>问题处理方式</p><ol><li>定时任务获取所有超时订单，自动回滚操作</li><li>保存出错消息，人工处理</li></ol></blockquote></li><li><p>事件溯源的分布式事务实现（最终一致性）</p></li><li><p>TCC（最终一致性）</p><blockquote><ul><li>tryCharge()，参数检查、资源预留</li><li>confirmCharge()，业务操作，保证幂等性</li><li>commitCharge()，完成事务，保证幂等性</li></ul></blockquote></li></ol><p>总结</p><ul><li>事务同步</li><li>重试和幂等性</li><li>根据具体架构场景具体分析</li></ul><h2 id="五、分布式实践"><a href="#五、分布式实践" class="headerlink" title="五、分布式实践"></a>五、分布式实践</h2><ul><li>保证高可用</li><li>保证事务同步</li><li>保证幂等性</li><li>合理设计流程</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac终端DIY配置</title>
      <link href="/2020/01/22/Mac%E7%BB%88%E7%AB%AFDIY%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/22/Mac%E7%BB%88%E7%AB%AFDIY%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2020/01/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/01/21/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="一、线程池的由来（属于JUC包内知识点）"><a href="#一、线程池的由来（属于JUC包内知识点）" class="headerlink" title="一、线程池的由来（属于JUC包内知识点）"></a>一、线程池的由来（属于JUC包内知识点）</h2><blockquote><p> <strong>扩展知识：<a href="http://orgjinhc.github.io/2020/01/21/JavaBasic_ThreadAndProcessRelation/">线程or进程</a></strong></p></blockquote><h3 id="先从问题来开始阐述线程池的由来"><a href="#先从问题来开始阐述线程池的由来" class="headerlink" title="先从问题来开始阐述线程池的由来"></a>先从问题来开始阐述线程池的由来</h3><h4 id="1-为什么要使用多线程-并发编程"><a href="#1-为什么要使用多线程-并发编程" class="headerlink" title="1.为什么要使用多线程/并发编程"></a>1.为什么要使用多线程/并发编程</h4><blockquote><p><font color=gray size=4><strong>并发编程等目的是为了让程序运行更快</strong></font></p></blockquote><h4 id="2-多线程一定比单线程效率高-执行快"><a href="#2-多线程一定比单线程效率高-执行快" class="headerlink" title="2.多线程一定比单线程效率高/执行快"></a>2.多线程一定比单线程效率高/执行快</h4><blockquote><p><strong>这里又要区分环境是单核还是多核情况，但是无论是什么环境，答案都是否定的</strong></p><table><thead><tr><th>线程数量\环境</th><th>单核</th><th>多核</th></tr></thead><tbody><tr><td>单线程</td><td>理论上cup无需上下文切换,耗时:程序执行时间</td><td>程序执行耗时在一个时间片内可以处理完的情况下等价与单核单线程</td></tr><tr><td>多线程</td><td>cpu频繁的上下文切换</td><td>核数和线程数相同情况下,等比单线程单核</td></tr></tbody></table><p><strong>结论</strong>：<strong>单线程无论是在单核或多核情况下，速度一致。多线程多核比单核快。</strong></p><hr><p>​     <font color=green><strong>上下文切换概念</strong></font></p><blockquote><p><strong>相关概念</strong></p><ul><li><p><strong>线程：能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程</strong></p></li><li><p><strong>寄存器： CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）</strong></p></li><li><p><strong>PC：一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</strong></p></li></ul><p><strong>上下文（某一时间点CPU寄存器和PC的内容）切换（有时也称做进程切换或任务切换）：是指CPU从一个进程或线程切换到另一个进程或线程</strong></p><p><strong>稍微详细描述一下，上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</strong></p><ol><li><strong>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处</strong></li><li><strong>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复</strong></li><li><strong>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程</strong></li></ol><p><strong>上下文切换有时被描述为<a href="http://www.linfo.org/kernel.html" target="_blank" rel="noopener">内核</a>挂起 CPU 当前执行的进程，然后继续执行之前挂起的众多进程中的某一个。尽管这么说对于澄清概念有所帮助，但是这句话本身可能有一点令人困惑。因为通过定义可以知道，进程是指一个程序运行的实例。所以说成挂起一个进程的运行可能更适合一些。</strong></p></blockquote><p>​    <font color=green><strong>上下文切换的消耗</strong></font></p><pre><code>&gt; **每秒几十上百次的上下文切换中，每次切换都需要纳秒量级的时间。上下文切换对系统来说意味着消耗大量的 CPU 时间，是操作系统中时间消耗最大的操作**</code></pre><p>​     <font color = green><strong>如何减少上下文切换</strong></font></p><blockquote><ol><li><strong>无锁并发编程：避免竞争锁造成的上下文切换</strong></li><li><strong>CAS算法：Compare and Swap,核心方法compareAndSetInt</strong></li><li><strong>使用最少线程：避免创建不必要的线程</strong></li><li><strong>使用协程：在单线程里实现多任务的调用，并在单线程里维护多个任务间的切换</strong></li></ol></blockquote><hr><p><font color = green><strong>此次测试代码如下</strong></font></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcurrentTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">900000</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">serial</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">concurrency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    a<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a="</span> <span class="token operator">+</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            b<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"concurrency : "</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"ms,b="</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">serial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            b<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"serial : "</span> <span class="token operator">+</span> time <span class="token operator">+</span> <span class="token string">"ms,a="</span> <span class="token operator">+</span> a <span class="token operator">+</span> <span class="token string">",b="</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></blockquote><h4 id="3-代码中如何体现多线程如何创建线程"><a href="#3-代码中如何体现多线程如何创建线程" class="headerlink" title="3.代码中如何体现多线程如何创建线程"></a>3.代码中如何体现多线程如何创建线程</h4><blockquote><ol><li><p><font color = green ><strong>第一种方式</strong></font></p><pre class=" language-java"><code class="language-java">Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong><font color = green >第二种方式</font></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p><strong><font color = green >第三种方式</font></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadTask</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"create Thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p><strong><font color = green >其他情况例如：使用Callable、Future、线程池等情况咱们先不考虑</font></strong></p></li></ol></blockquote><h4 id="4-创建线程的过程"><a href="#4-创建线程的过程" class="headerlink" title="4.创建线程的过程"></a>4.创建线程的过程</h4><blockquote><p><strong>线程的创建需要模式的切换（用户态切换内核态），所以创建线程会消耗OS资源，并且每一个java线程都会与OS到线程（轻量级进程）一一对应，频繁的创建和销毁会让系统的大部分时间都浪费在资源到申请和回收</strong></p><p><strong>源码分析</strong></p><ol><li><p>新创建的线程或任务并不会直接执行Runnable代码或逻辑</p></li><li><p>必须执行start()方法后才会执行</p><p><img src="http://lion-heart.online/blog/2020-01-21-124119.png" alt="线程start方法源码"></p></li><li><p>start0()方法执行后，由JVM通过JNI去调用C或C++代码的标准库pThread，之后才会和os线程建立起映射关系</p></li><li><p>为什么new Thread必须传入一个Runnable对象，源码注释如下</p><pre class=" language-java"><code class="language-java">If <span class="token keyword">this</span> thread was constructed using a separate<span class="token operator">&lt;</span>code<span class="token operator">></span>Runnable<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">></span> run object<span class="token punctuation">,</span> then that<span class="token operator">&lt;</span>code<span class="token operator">></span>Runnable<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">></span> object's <span class="token operator">&lt;</span>code<span class="token operator">></span>run<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">></span> method is called<span class="token punctuation">;</span>otherwise<span class="token punctuation">,</span> <span class="token keyword">this</span> method does nothing and returns<span class="token punctuation">.</span><span class="token operator">&lt;</span>p<span class="token operator">></span>Subclasses of <span class="token operator">&lt;</span>code<span class="token operator">></span>Thread<span class="token operator">&lt;</span><span class="token operator">/</span>code<span class="token operator">></span> should override <span class="token keyword">this</span> method<span class="token punctuation">.</span></code></pre></li><li><p>最后由JVM调用Runnable的run方法</p></li></ol></blockquote><p><font color=red size = 4><strong>结论：使用多线程/并发编程的目的是为了提高程序的吞吐量，但是如果频繁的创建和销毁线程又会大大降低系统的吞吐量，有没有什么办法让我们创建的线程不会被回收或使用后不会被销毁呢，答案是肯定的，那就是线程池</strong></font></p><h2 id="二、使用线程池的目的"><a href="#二、使用线程池的目的" class="headerlink" title="二、使用线程池的目的"></a>二、使用线程池的目的</h2><h4 id="结合线程池的由来，目的就非常清晰了，预先创建好线程，方便直接使用"><a href="#结合线程池的由来，目的就非常清晰了，预先创建好线程，方便直接使用" class="headerlink" title="结合线程池的由来，目的就非常清晰了，预先创建好线程，方便直接使用"></a>结合线程池的由来，目的就非常清晰了，预先创建好线程，方便直接使用</h4><p><font color=red size = 4><strong>结论：就是为了线程复用，从而达到降低系统开销</strong></font></p><h2 id="三、使用线程池好处"><a href="#三、使用线程池好处" class="headerlink" title="三、使用线程池好处"></a>三、使用线程池好处</h2><ol><li><strong>重复利用已有线程继续执行任务，避免线程创建和销毁造成的消耗</strong></li><li><strong>提高系统吞吐量</strong></li><li><strong>针对系统性能情况对线程数进行合理的管控</strong></li></ol><h2 id="四、线程池分类"><a href="#四、线程池分类" class="headerlink" title="四、线程池分类"></a>四、线程池分类</h2><ol><li><strong>ThreadPollExecutor</strong></li><li><strong>ScheduledThreadPoolExecutor</strong></li><li><strong>ForkJoinPool</strong></li></ol><h2 id="五、线程池原理"><a href="#五、线程池原理" class="headerlink" title="五、线程池原理"></a>五、线程池原理</h2><h3 id="宏观了解线程池"><a href="#宏观了解线程池" class="headerlink" title="宏观了解线程池"></a>宏观了解线程池</h3><h4 id="线程池全貌"><a href="#线程池全貌" class="headerlink" title="线程池全貌"></a>线程池全貌</h4><blockquote><p><img src="https://lion-heart.online/blog/2020-01-21-221504.png?x-oss-process=style/lion-heart" alt="线程池"></p></blockquote><h4 id="线程池数据结构"><a href="#线程池数据结构" class="headerlink" title="线程池数据结构"></a>线程池数据结构</h4><blockquote><p><img src="https://lion-heart.online/blog/2020-01-21-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1.png?x-oss-process=style/lion-heart" alt="数据结构"></p></blockquote><h4 id="线程池的类图"><a href="#线程池的类图" class="headerlink" title="线程池的类图"></a>线程池的类图</h4><blockquote><p><img src="http://lion-heart.online/blog/2020-01-21-225457.png" alt="类图"></p><ol><li><strong>Executor：一个执行已提交Runnable任务的对象。该接口提供了一种将任务提交与如何运行每个任务的机制(包括线程使用、调度等细节)分离的方法</strong></li><li><strong>ExectorService：提供用于管理终止方法的执行程序，以及可以产生一个或多个异步任务的未来跟踪进度的方法</strong></li><li><strong>AbstractExecutorService：ExectorService默认实现，同时定义标准</strong></li><li><strong>ThreadPoolExecutor：定义创建线程池的标准以及各种情况对应的策略，方法执行前后的增强逻辑</strong></li></ol></blockquote><h4 id="线程池工作原理"><a href="#线程池工作原理" class="headerlink" title="线程池工作原理"></a>线程池工作原理</h4><h6 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h6><blockquote><p><font color = green size = 5><strong>先看源码ThreadPoolExecutor.execute()方法</strong></font></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-21-233135.png" alt="ThreadPoolExecutor.execute()"></p><ol><li><strong>第一个if()：如果运行的线程小于corePoolSize，则尝试使用给定的命令作为第一个任务来启动新线程。对addWorker的调用会自动地检查runState和workerCount，从而通过返回false来防止在不应该添加线程的情况下添加错误警报。</strong></li><li><strong>第二个if()：如果一个任务可以成功地排队，那么我们仍然需要再次检查是否应该添加一个线程(因为现有的线程在最后一次检查后死亡)，或者池在进入这个方法后关闭。因此，我们重新检查状态，如果有必要，如果停止，则回滚排队;如果没有，则启动新线程。</strong></li><li><strong>最外层else if()：如果无法对任务排队，则尝试添加新线程。如果它失败了，我们知道我们被关闭或饱和，因此拒绝任务。</strong></li></ol></blockquote><p><font color = green size = 5><strong>流程图</strong></font></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-21-233828.png" alt="ThreadPoolExecutor提交任务"></p></blockquote><p><font color = green size = 5><strong>活动图</strong></font></p><blockquote><p><img src="http://lion-heart.online/blog/2020-01-22-070915.png" alt="活动图"></p></blockquote></blockquote><h6 id="处理任务"><a href="#处理任务" class="headerlink" title="处理任务"></a>处理任务</h6><blockquote><p><font color=green size=5> <strong>分析</strong> </font></p><blockquote><p><strong><font color=gray size = 6>对于概念我们已经理解具体含义，这里我们只关注addWorker()方法，先给出源码</font></strong></p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>                mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                        <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                            largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                        workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>                <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong><font color = red size = 5>重点</font></strong>：<font color=green>代码的第6行/第17行/第27行，产生一个新问题Worker是什么？</font></p><p><strong><font color = gray size = 6>继续往下看，源码如下</font></strong></p><blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Worker是一种数据结构，本身是一个Runnable，同时又是一个Thread。</strong></p><p><strong>线程复用的本质是同一个线程可以执行不同任务。</strong></p><p><strong>Worker就是用来封装任务的一种结构，用来执行本身和所有添加到池/队列的任务，同时自己必须还要是一个可执行的任务，否则自己无法被系统调用，也就无从复用一说。重点关注构造函数和下面的run()方法。结合addWorker()的7和27行可知，添加Worker后，Worker作为一个可执行的任务被操作系统调用，执行完自身任务后，Worker去BlockingQueue里获取任务并执行。</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong><font color=gray size=6>只需要关注第8行。我们在看一下第8行具体逻辑</font></strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>还是只关心我们要关注的部分，代码的第23行。Worker执行完自身的任务后从workQueue里获取要执行的任务，此时就达到了线程复用逻辑。</p></blockquote></blockquote></blockquote><h2 id="四、线程池适用场景"><a href="#四、线程池适用场景" class="headerlink" title="四、线程池适用场景"></a>四、线程池适用场景</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaBasic_ThreadAndProcessRelation</title>
      <link href="/2020/01/21/JavaBasic_ThreadAndProcessRelation/"/>
      <url>/2020/01/21/JavaBasic_ThreadAndProcessRelation/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="本篇Blog主要介绍进程、线程、线程池之间的依赖关系以及它们之间的必然联系"><a href="#本篇Blog主要介绍进程、线程、线程池之间的依赖关系以及它们之间的必然联系" class="headerlink" title="本篇Blog主要介绍进程、线程、线程池之间的依赖关系以及它们之间的必然联系"></a>本篇Blog主要介绍进程、线程、线程池之间的依赖关系以及它们之间的必然联系</h2><h3 id="一、先给出Wiki上有关相关概念定义，然后我们再带着疑惑或问题去了解它们"><a href="#一、先给出Wiki上有关相关概念定义，然后我们再带着疑惑或问题去了解它们" class="headerlink" title="一、先给出Wiki上有关相关概念定义，然后我们再带着疑惑或问题去了解它们"></a>一、先给出Wiki上有关相关概念定义，然后我们再带着疑惑或问题去了解它们</h3><h4 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h4><p><font color=green><strong>进程</strong>（Process）</font>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行<font color=green><strong>资源分配</strong></font>和<font color=green><strong>调度</strong></font>的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是<font color=green><strong>线程的容器</strong></font>。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>看完上述描述，除了标粗的关键字外，其他的你可以都忘掉，除非你有超强的记忆力。</p><h4 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h4><p><font color=green><strong>线程</strong>（Thread）</font>是<font color=green><strong>操作系统</strong></font>能够进行<font color=green><strong>运算调度</strong></font>的最小单位。是<a href="https://baike.baidu.com/item/进程" target="_blank" rel="noopener">进程</a>中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>线程可以为操作系统内核调度的内核线程，也可以是用户进程自行调度的用户线程。</p><p>在多核或多CPU使用多线程程序设计的好处是显而易见，即提高了程序的执行吞吐率。在单CPU单核的计算机上，使用多线程技术，也可以把进程中负责I/O处理、人机交互而常被阻塞的部分与密集计算的部分分开来执行，编写专门的workhorse线程执行密集计算，从而提高了程序的执行效率。</p><p>又是一堆概念，还是记住关键字，然后其他的就可以忘记了。</p><h4 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3.线程池"></a>3.线程池</h4><p>简单理解就是有很多可以直接使用的线程的一个容器</p><h3 id="二、带着问题去看本篇内容，你会更容易理解"><a href="#二、带着问题去看本篇内容，你会更容易理解" class="headerlink" title="二、带着问题去看本篇内容，你会更容易理解"></a>二、带着问题去看本篇内容，你会更容易理解</h3><h4 id="1-进程与线程区别？"><a href="#1-进程与线程区别？" class="headerlink" title="1.进程与线程区别？"></a>1.进程与线程区别？</h4><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p><strong>进程</strong>：线程容器，拥有独立的逻辑内存，同时又共享操作系统里所有文件、网络句柄。</p></blockquote><p><img src="http://lion-heart.online/blog/2020-01-21-%E8%BF%9B%E7%A8%8B.png" alt="进程"></p><blockquote><p><strong>线程</strong>：CPU运算调度的最小单元，作为载体同时也拥有属于自己的结构，线程是程序中一个单一顺序的控制流，当前控制流中的所有本地变量或函数都会存放到栈中。每个线程都有独立的pc指针，指向代码所在的内存。</p></blockquote><p><img src="http://lion-heart.online/blog/2020-01-21-080013.jpg" alt="线程"></p><h5 id="线程分类"><a href="#线程分类" class="headerlink" title="线程分类"></a>线程分类</h5><p><img src="http://lion-heart.online/blog/2020-02-19-121609.png" alt="线程分类"></p><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><p><img src="/Users/jinhongcai/Desktop/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="线程状态"></p><h4 id="2-并发与并行"><a href="#2-并发与并行" class="headerlink" title="2.并发与并行"></a>2.并发与并行</h4><blockquote><p><strong>它们虽然都说是同一时刻”多个进程/线程同时运行”，但是它们的”同时”不是一个概念</strong></p><ol><li><p><strong>并行的”同时”是同一时刻可以多个进程/线程在运行(处于running)</strong></p></li><li><p><strong>并发的”同时”是经过上下文快速切换，使得看上去多个进程同时都在运行的现象，是一种OS欺骗用户的现象</strong></p></li></ol></blockquote><h2 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h2><ol><li><p>单标志检查</p><ul><li><p>特点：确保进程互斥访问临界区</p><p>​            进程间必须交替进入临界区</p></li><li><p>缺点：违背“空闲让进”</p></li></ul></li><li><p>双标志先检查（先检查后上锁）</p><ul><li>特点：确保进程互斥访问临界区</li><li>缺点：存在俩进程都进不了临界区的”饥饿”现象</li></ul></li><li><p>双标志后检查（先上锁后检查）</p><ul><li>特点：确保进程互斥访问临界区</li><li>缺点：存在俩进程都进不了临界区的”饥饿”现象</li></ul></li><li><p>Perteson</p><ul><li><p>优点：确保进程互斥访问临界区</p><p>​           不会出现“饥饿”现象</p></li><li><p>缺点：不能进入临界区的进程还是会占用处理机</p></li></ul></li></ol><h3 id="同步经典问题"><a href="#同步经典问题" class="headerlink" title="同步经典问题"></a>同步经典问题</h3><h4 id=""><a href="#" class="headerlink" title=""></a><img src="http://lion-heart.online/blog/2020-02-20-040517.png" alt="生产者-消费者"></h4><h4 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h4><h4 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h4><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="死锁条件：同时满足发生死锁"><a href="#死锁条件：同时满足发生死锁" class="headerlink" title="死锁条件：同时满足发生死锁"></a>死锁条件：同时满足发生死锁</h4><blockquote><ol><li><strong>互斥条件：共享资源在一段时间内仅为一个线程所占有，此时若有其他线程请求该资源，则请求线程只能等待</strong></li><li><strong>不剥夺条件：线程未释放共享资源之前，不能被其他线程强行夺走</strong></li><li><strong>请求和保持条件：线程在以持有资源的情况下，又提出新的资源请求，而该资源已被其他线程持有，此时请求线程被阻塞，但对自己已获得的资源保持不放</strong></li><li><strong>循环等待条件：存在线程资源的循环等待链，链中每个线程持有的资源同时被链中下一个线程所请求</strong></li></ol></blockquote><h4 id="预防死锁：破坏死锁条件中的一个或多个"><a href="#预防死锁：破坏死锁条件中的一个或多个" class="headerlink" title="预防死锁：破坏死锁条件中的一个或多个"></a>预防死锁：破坏死锁条件中的一个或多个</h4><h4 id="避免死锁：银行家算法"><a href="#避免死锁：银行家算法" class="headerlink" title="避免死锁：银行家算法"></a>避免死锁：银行家算法</h4><h4 id="死锁的检查和解触"><a href="#死锁的检查和解触" class="headerlink" title="死锁的检查和解触"></a>死锁的检查和解触</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>OSS-CDN-DNS杂谈</title>
      <link href="/2020/01/20/OSS-CDN-DNS%E6%9D%82%E8%B0%88/"/>
      <url>/2020/01/20/OSS-CDN-DNS%E6%9D%82%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h3 id="OSS"><a href="#OSS" class="headerlink" title="OSS"></a>OSS</h3><p><strong>OSS(Object Storage System)</strong>:对象存储系统.一般而言,我们只会把网站所需要的静态文件,而不会存储动态数据或文件.例如将网站的图片、视频、样式等文件存储在OSS.存储在OSS上的资源会通过一个url让你可以直接使用.总之,OSS是帮助网站存储文件的一个服务.</p><p>那有人就会产生疑问:我们已经有自己的服务器了,为什么还要将文件传到OSS上,然后提供的url来使用呢？<br>实际上我们现在的服务端开发工作中,即我们在搭建服务器环境,设计服务端架构的时候,必须要清楚认知系统的定位,即CUP密集型或IO密集型.如果IO密型那我们系统的瓶颈就是IO,如果把一些大块的文件（图片、视频）放在OSS,可以有效的降低访客访问（下载）这些文件对服务器带来的IO压力,让服务器运行起来更加流畅.这是我们使用OSS服务的最根本原因.</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。CDN通过网络途径将源站内容分发至最接近用户的边缘节点，使用用户就近获取所需内容，大大提高了用户访问速度和成功率，直接解决了网络访问不畅的问题。<br>使用CDN好处？<br>我们先来对比下在未使用CDN之前用户的一次请求经历了那些过程，首先你通过浏览器输入了一个你喜欢的内容，请求通过自家路由器，再到区域电信运营商，再到主干网，再通过网络路由、DNS找到你的服务器，再把需要的资源下载到浏览器进行展示。中间任何一个环节的网络不好，都会导致网站访问变慢，甚至访问失败。<br>而使用CDN之后，你把域名解析到CDN提供的一个中间地址，再在CDN服务商处设置你的服务器真实IP。当用户访问你的网站的时候，CDN服务商把你的网站资源缓存在自己的服务器上，并把距离访客最近服务器上的缓存返回给访客，这样直接加快了网站的访问速度.</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统（Domain Name System缩写DNS，Domain Name被译为域名）是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><p>域名系统(Domain Name System,DNS)是Internet上解决网上机器命名的一种系统。就像拜访朋友要先知道别人家怎么走一样，Internet上当一台主机要访问另外一台主机时，必须首先获知其地址，TCP/IP中的IP地址是由四段以“.”分开的数字组成，记起来总是不如名字那么方便，所以，就采用了域名系统来管理名字和IP的对应关系。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>释放Mac占用端口</title>
      <link href="/2020/01/20/%E9%87%8A%E6%94%BEMac%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3/"/>
      <url>/2020/01/20/%E9%87%8A%E6%94%BEMac%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="端口占用问题"><a href="#端口占用问题" class="headerlink" title="端口占用问题"></a>端口占用问题</h1><p>结论:问题很常见,只要是涉及到独立进程的工具或应用都会涉及到默认的端口已经被占用情况,常见的手段就是释放对应端口或变更默认端口号</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h3><p>放假第一天,一定要从写Blog开始,但是当查看排版和样式的时候出现了一个小问题</p><p><img src="https://lion-heart.online/blog/2020-01-20-080616.png" alt="问题"></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="先查看所有端口-4000端口-是否存在被占用情况"><a href="#先查看所有端口-4000端口-是否存在被占用情况" class="headerlink" title="先查看所有端口/4000端口,是否存在被占用情况"></a>先查看所有端口/4000端口,是否存在被占用情况</h3><p><img src="http://lion-heart.online/blog/2020-01-20-080711.png" alt="查看端口"></p><p>马上定位问题,接下我们就来解决它</p><h3 id="终断它-并重新查看"><a href="#终断它-并重新查看" class="headerlink" title="终断它,并重新查看"></a>终断它,并重新查看</h3><p><img src="http://lion-heart.online/blog/2020-01-20-%E9%87%8A%E6%94%BE%E7%AB%AF%E5%8F%A3-%E9%87%8D%E6%96%B0%E6%9F%A5%E7%9C%8B.png" alt=""></p><p>4000端口已经中断,我们重新查看发现4000端口已无使用</p><h2 id="重新启动"><a href="#重新启动" class="headerlink" title="重新启动"></a>重新启动</h2><p><img src="http://lion-heart.online/blog/2020-01-20-081710.png" alt="启动成功"></p><p>启动成功,搞定</p><h2 id="附查看本机ip地址方法"><a href="#附查看本机ip地址方法" class="headerlink" title="附查看本机ip地址方法"></a>附查看本机ip地址方法</h2><h3 id="一、通过终端查看"><a href="#一、通过终端查看" class="headerlink" title="一、通过终端查看"></a>一、通过终端查看</h3><p><img src="http://lion-heart.online/blog/2020-02-07-034458.png" alt="终端查看"></p><h3 id="二、系统设置"><a href="#二、系统设置" class="headerlink" title="二、系统设置"></a>二、系统设置</h3><p><img src="http://lion-heart.online/blog/2020-02-07-034808.png" alt="系统设置"></p><p><img src="http://lion-heart.online/blog/2020-02-07-034758.png" alt="系统设置"></p><p><img src="http://lion-heart.online/blog/2020-02-07-034822.png" alt="TCP:IP"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="/2020/01/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2020/01/19/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><h2 id="一、什么是单元测试"><a href="#一、什么是单元测试" class="headerlink" title="一、什么是单元测试"></a>一、什么是单元测试</h2><h2 id="二、单元测试的作用"><a href="#二、单元测试的作用" class="headerlink" title="二、单元测试的作用"></a>二、单元测试的作用</h2><h2 id="三、常用的测试方法"><a href="#三、常用的测试方法" class="headerlink" title="三、常用的测试方法"></a>三、常用的测试方法</h2><h2 id="四、单元测试的优点"><a href="#四、单元测试的优点" class="headerlink" title="四、单元测试的优点"></a>四、单元测试的优点</h2><ul><li>验证行为</li></ul><h2 id="五、单元测试的原则"><a href="#五、单元测试的原则" class="headerlink" title="五、单元测试的原则"></a>五、单元测试的原则</h2><ul><li><p>单元测试只需要测试对外提供的接口即可</p></li><li><p>单元测试要满足简单性、可读性、隔离性</p><ol><li>简单性：需要遵守设计原则</li><li>可读性：降低复杂度</li><li>测试代码之间不能互相影响</li></ol></li><li><p>测试代码和源码同等重要,需要被同时维护</p><ol><li>重构源码的同时也要重构测试代码</li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VIM操作集合</title>
      <link href="/2020/01/18/VIM%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/"/>
      <url>/2020/01/18/VIM%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="常用VIM操作"><a href="#常用VIM操作" class="headerlink" title="常用VIM操作"></a>常用VIM操作</h2><p><a href="https://www.jianshu.com/p/f243ceba710b" target="_blank" rel="noopener" title="VIM使用说明">VIM使用说明</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/2020/01/17/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/01/17/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown语法"><a href="#MarkDown语法" class="headerlink" title="MarkDown语法"></a>MarkDown语法</h1><p>#+space 代表标题，随着#的数量增加标题级别以此递增</p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><ul><li>加粗</li></ul><p>使用**  <strong>包裹</strong></p><ul><li>斜体</li></ul><p>使用*    <em>包裹</em></p><ul><li>斜体+粗体</li></ul><p>使用** *   <strong><em>包裹</em></strong></p><ul><li>删除线</li></ul><p>使用～～<del>包裹</del></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br>n个…</p><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>三个或者三个以上的 - 或者 * 都可以</p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><pre><code>![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</code></pre><h4 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h4><pre><code>[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加</code></pre><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h6 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h6><p>语法：<br>无序列表用 - + * 任何一种都可以</p><h6 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h6><p>数字加点</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><pre><code>表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略</code></pre><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h6 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h6><p>``</p><h6 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h6><pre><code>(```)    public void fun(){         sys();    }    fun();(```)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020 新年计划</title>
      <link href="/2020/01/17/2020%20%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/"/>
      <url>/2020/01/17/2020%20%E6%96%B0%E5%B9%B4%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="2020-计划"><a href="#2020-计划" class="headerlink" title="2020 计划"></a><strong>2020</strong> 计划</h1><hr><h3 id="制定目标"><a href="#制定目标" class="headerlink" title="制定目标"></a>制定目标</h3><h4 id="技术路线-P6-T7"><a href="#技术路线-P6-T7" class="headerlink" title="技术路线 P6/T7"></a>技术路线 P6/T7</h4><h6 id="P6要求"><a href="#P6要求" class="headerlink" title="P6要求"></a><strong>P6要求</strong></h6><blockquote><ol><li>基础<strong>扎实</strong></li><li>框架原理<strong>清晰</strong></li><li>中间件<strong>思想</strong></li><li>业务领域<strong>熟悉</strong></li></ol></blockquote><h6 id="T7要求"><a href="#T7要求" class="headerlink" title="T7要求"></a><strong>T7要求</strong></h6><blockquote><ol><li>业务比例偏重</li><li>领导力/执行力</li><li>框架/中间件原理</li><li>基础</li></ol></blockquote><h3 id="根据目标制定实行计划"><a href="#根据目标制定实行计划" class="headerlink" title="根据目标制定实行计划"></a>根据目标制定实行计划</h3><ul><li>5:00AM：刷题</li><li>7:00AM：背题</li><li>9:00AM</li><li>1:00PM</li><li>3:00PM</li><li>5:00PM</li><li>7:00PM</li><li>9:00PM：背题</li></ul><h3 id="为实现目标积累资源与条件"><a href="#为实现目标积累资源与条件" class="headerlink" title="为实现目标积累资源与条件"></a>为实现目标积累资源与条件</h3><p><strong>从下面四个方面提升</strong></p><blockquote><ol><li><strong>基础篇</strong></li><li><strong>框架原理篇</strong></li><li><strong>中间件篇</strong></li><li><strong>架构篇</strong></li></ol></blockquote><h3 id="马上付诸现实行动"><a href="#马上付诸现实行动" class="headerlink" title="马上付诸现实行动"></a>马上付诸现实行动</h3><table><thead><tr><th>目标</th><th align="center">知识点</th><th align="center">连接</th><th align="center">进度</th><th align="center">更新时间</th></tr></thead><tbody><tr><td>Java基础</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:21</td></tr><tr><td>框架原理</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:27</td></tr><tr><td>中间件原理</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:28</td></tr><tr><td>架构实践</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:30</td></tr><tr><td>项目</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:32</td></tr><tr><td>展望</td><td align="center"></td><td align="center"></td><td align="center">0</td><td align="center">2020-01-21 12:01:33</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
