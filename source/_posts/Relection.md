title: 反射
author: 靳宏财
top: true
cover: true
toc: true
summary: java反射相关概念
categories: Java基础
tags:

  - 反射

---



# 简介：Java是一种强类型、静态类型检查的语言

这里有俩概念我们先了解一下，`强类型`和`静态类型`，那与之的应该有弱类型和动态类型了？



![语言类型划分](http://lion-heart.online/blog/2020-01-27-025435.png)

上图的标准里解释了各种语言类型的划分，那到底是按照什么维度去划分强弱、动态静态这些概念的呢？

![各类型划分](http://lion-heart.online/blog/2020-01-27-025629.png)

总结：强、弱、静态、动态

- 动态类型：运行时做type check
- 静态类型：编译期做type check
- 强类型：一个变量不经过强制转换，它永远是这个数据类型，不允许隐式的类型转换。举个例子：如果你定义了一个double类型变量a,不经过强制类型转换那么程序int b = a无法通过编译
- 弱类型：它与强类型语言定义相反,允许编译器进行隐式的类型转换

## 反射

### 带着问题看反射

> 1. 什么是反射机制
> 2. 反射机制的作用
> 3. 反射是如何实现的
> 4. 反射的优缺点
> 5. 反射机制会不会有性能问题

### 学习反射

#### What

在Java`运行时环境`中，对于任意一个类，可以知道这个类有哪些属性和方法。对于任意一个对象，可以调用它的任意一个方法。这种`动态获取类的信息`以及`动态调用对象的方法`的功能来自于Java 语言的`反射`（Reflection）机制

#### Effect

由开篇可知java是强类型、静态类型语言，这句话代表什么呢？

程序中对象的类型都是在编译期就确定下来的，也就是说在java应用如果确定了一种数据类型，通过编译器的编译后，直接生成字节码文件，那么这个变量的类型就永远不会改变了，并且当前类的所有信息都是确定的不可修改的，如果要修改（添加新类/给类添加属性或方法）只能重新编写代码，通过编译器编译生成字节码文件

`结论`：

- **反射的核心是 JVM 在运行时动态加载类或调用方法/访问属性，并可以在运行过程中动态的创建对象,甚至是修改程序的动态行为（获取类的所有方法，并访问类的私有方法在类之外的地方）**

`体现`：

- **在运行时判断任意一个对象所属的类**
- **在运行时构造任意一个类的对象**
- **在运行时判断任意一个类所具有的成员变量和方法**
- **在运行时调用任意一个对象的方法**

#### Implementation

##### **`一图看懂反射`:**

> ![类加载](http://lion-heart.online/blog/2020-01-27-051347.png)

##### **`流程`：**

> java源文件（内存） ---> java字节码文件（硬盘）---> JVM(Load) ---> java字节码文件 ---> Class类 ---> Class对象

##### **`字节码对象组成`：**

> 1. 构造器对象 --- Constructor
> 2. 成员变量 --- Field
> 3. 成员方法 --- Method  

#####  `字节码文件加载机制`

> 1. new一个类/子类
> 2. 访问类静态方法/类静态成员变量
> 3. 反射创建字节码对象
>    - Object.getClass()
>    - 类.class()
>    - Class.forName()
> 4. java命令执行字节码文件
>
> <font color = green size = 5>结论</font>：所有以上加载机制只有第一次执行指令才会触发字节码问价加载，以后都说通过缓存执行

<font color = red size = 6>本质</font>：**`反射操作的就是字节码对象`**

#### Advantages And Disadvantages

> **Advantages**
>
> - **反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中**

> **Disadvantages**
>
> - **效率低：反射包括了一些动态类型，JVM无法对这些代码进行优化**
> - **安全性问题：使用反射技术要求程序必须在一个没有安全限制的环境中运行**
> - **反射破坏了代码的封装性和抽象性，并降低了可移植性**

#### Performance

> **反射调用效率慢的原因**
>
> 1. **接口的通用性，java的invoke方法是传object和object[]数组的。基本参数类型需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC**
> 2. **编译器难以对动态调用的代码提前做优化**
> 3. **反射需要按名检索类和方法，有一定的时间开销**

<font color = red size = 6>总结</font>：**`应该避免在经常被执行的代码或对性能要求很高的程序中使用反射`**